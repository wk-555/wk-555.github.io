<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落风的风</title>
  
  
  <link href="https://wukang555.github.io/atom.xml" rel="self"/>
  
  <link href="https://wukang555.github.io/"/>
  <updated>2022-05-17T12:23:40.338Z</updated>
  <id>https://wukang555.github.io/</id>
  
  <author>
    <name>Wu kang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>背包问题-力扣题解</title>
    <link href="https://wukang555.github.io/2021/11/20/%E7%AE%97%E6%B3%95_09_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://wukang555.github.io/2021/11/20/%E7%AE%97%E6%B3%95_09_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-20T14:55:00.000Z</published>
    <updated>2022-05-17T12:23:40.338Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划之背包问题。</p><a id="more"></a><blockquote><p>讲解背包问题最经典的当属《背包九讲》，之前看了前面一点点，现在又忘了，所以还是的写笔记</p><p>面试需要，不做太深入的了解。这里仅学习零一背包、完全背包和多重背包问题</p><p>[1] 参考了<a href="https://github.com/tianyicui/pack">背包九讲</a>  背包九讲就是讲背包的永远滴神</p></blockquote><h1 id="1-背包问题介绍"><a href="#1-背包问题介绍" class="headerlink" title="1 背包问题介绍"></a>1 背包问题介绍</h1><h2 id="1-1-背包问题的基本描述和分类"><a href="#1-1-背包问题的基本描述和分类" class="headerlink" title="1.1 背包问题的基本描述和分类"></a>1.1 背包问题的基本描述和分类</h2><blockquote><p>背包问题的基本描述：有N件物品和一个最多能装重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。</p></blockquote><ul><li>01背包：每种物品仅有一件，可以选择放或不放。求解将哪些物品装入背包可使价值总和最大。</li><li>完全背包：每种物品都有无限件可用，求解将哪些物品装入背包可使价值总和最大。</li><li>多重背包：每件物品的数量由nums[i]表示，求解价值总和最大的装法。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213518.png" alt="416.分割等和子集1" style="zoom:80%;"><h2 id="1-2-背包问题的基本解法（01背包为例）"><a href="#1-2-背包问题的基本解法（01背包为例）" class="headerlink" title="1.2 背包问题的基本解法（01背包为例）"></a>1.2 背包问题的基本解法（01背包为例）</h2><blockquote><p>就是动态规划，但不同问题，遍历计算的顺序大不相同。</p><p>动态规划的三大要点：1状态  2确定初始化和重点 3列出状态转移方程</p></blockquote><p><strong>为什么要用动态规划？</strong></p><p>一个物品存在选择或者不选择两种情况，暴力解法就是2^n种选择。显然需要用动态规划保存状态来降低时间复杂度。</p><p><strong>基础的01背包案例：背包容量为n、一共有m个物品，物品重量数组W[1:m]，价值数组V[1:m]</strong></p><ul><li>状态<code>dp[i][j]</code>表示从前<code>i</code>个的物品种任意取，放进容量为<code>j</code>的背包，能获得的最大价值总和</li><li>初始化状态和终点<ul><li> <code>dp[i][0]=0</code>（容量为0的背包取出的价值为0）<code>dp[0][j]=0</code> （没有任何物品取出价值为0）</li><li><code>dp[i][j]=dp[i-1][j]</code>（因为多一个物品一定比少一个物品获得可能的结果更大，所以可以用上一个状态表示初始值）</li><li>终点：<code>dp[m][n]</code> 一共有m个物品，背包容量为n</li></ul></li><li>状态转移方程<ul><li>若(j-W[i-1]&gt;0),就表示W[i-1]元素可以作为填充背包的一部分，即</li><li><code>dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-W[i-1]]+V[i-1]);</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack01</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] W, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示将前i个元素的组合、装入容量为j的背包 能获得的最大价值</span></span><br><span class="line">    <span class="comment">//显然dp[i][j]的值一定大于等于dp[i-1][j]，可以所谓基础值</span></span><br><span class="line">    <span class="comment">//初始化 dp[..][0] = 0;</span></span><br><span class="line">    <span class="comment">//终点 dp[n][m]</span></span><br><span class="line">    <span class="comment">//动态迭代</span></span><br><span class="line">    <span class="comment">//先令dp[i][j]=dp[i-1][j],,若(j-W[i-1]&gt;0),就表示W[i-1]元素可以作为填充背包的一部分，则</span></span><br><span class="line">    <span class="comment">//dp[i][j] = max(dp[i-1][j],dp[i-1][j-W[i-1]]+V[i-1]);</span></span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-W[i-<span class="number">1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由遍历过程我们可以知道，<code>dp[i][j]</code>层都是由<code>dp[i-1][j]</code>层推导过来的，其实可以只使用一维数组保存状态。</p><p><strong>要注意到，此时<code>j</code>的循环必须是从大到小的逆序循环！！ 因为<code>dp[i][j]</code>是由<code>dp[i-1][j]</code>  <code>dp[i-1][j-w[i-1]]</code>推导而来，，每次求<code>j</code>的位置的值 用到了<code>j</code>位置和<code>j</code>之前位置的元素！！！</strong></p><p>代码如下，不再赘述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack01</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] W, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];<span class="comment">//表示容量为j的背包的最大价值和</span></span><br><span class="line">    <span class="keyword">int</span> n = W.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-W[i-<span class="number">1</span>]&gt;=<span class="number">0</span>) dp[j] = Math.max(dp[j],dp[j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-01背包题解"><a href="#2-01背包题解" class="headerlink" title="2 01背包题解"></a>2 01背包题解</h1><blockquote><p>了解概念之后、直接刷题学习</p><p>0/1背包类型：5m、53e、55m、62m、70e、91m、121e、139m、152m、198m、 213m、300m、303e、309m、322m、338m、377m、<strong>416m</strong>、647m、673m、698m</p><p>416 1049 494 474</p></blockquote><h2 id="92-·-背包问题"><a href="#92-·-背包问题" class="headerlink" title="92 · 背包问题"></a><a href="https://www.lintcode.com/problem/92/">92 · 背包问题</a></h2><blockquote><p>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为<code>A[i]</code></p></blockquote><p>思路：<code>dp[i][j]</code> 表示使用前<code>i</code>个物品最多能将容量为<code>j</code>的背包装的容量大小</p><ul><li>初始化<code>dp[i][0]=0  dp[0][j]=0</code>  <code>dp[i][j] = dp[i-1][j]</code></li><li>迭代方程<code>if(j&gt;A[i-1]) dp[i][j] = dp[i-1][j-A[i-1]]+A[i-1]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// `dp[i][j]` 表示使用前`i`个物品最多能将容量为`j`的背包装的容量大小</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=A[i-<span class="number">1</span>]) dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+A[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><blockquote><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote><p>思路：<strong>做这道题需要做一个等价转换：两子集元素和相等即表示：是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。</strong></p><p>所以题目变成了，是否可以挑出一些数来是他们的和等于sum/2。挑选的过程就类似与背包选择的过程。经典的背包问题是能装多满、这里问的是是否刚好等于，所以状态数组<code>dp[][]</code>是boolean类型的</p><ul><li>状态<code>dp[i][j]</code> 表示使用前<code>i</code>个元素，是否存在一个组合使其和为<code>j</code><ul><li>i从0到n-1，，j从0到target</li></ul></li><li>初始化 <code>dp[i][0]=false</code>; <code>dp[0][j]=true(if nums[0]==j)</code> ;<code>dp[i][j] = dp[i - 1][j]</code></li><li>终点 <code>dp[n-1][sum/2]</code>;</li><li>动态迭代 <code>if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true;</code></li></ul><p>依然可以看到<code>dp[i][j] = dp[i - 1][j]</code>类似的初始化，因为多一个元素一定比少一个元素的结果更理想，</p><p>然后动态迭代时，同样也用到了<code>dp[i-1][j-nums[i]]</code> 之前的状态，即使用nums[i]和不使用nums[i]存在明显的先后关系！！</p><p>代码：细节挺多的，不容易ak</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个数是否能组合出j的整数和</span></span><br><span class="line">        <span class="comment">//目标值target就是sum的一半</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[i][<span class="number">0</span>] = <span class="keyword">false</span>; <span class="comment">//可写可不写</span></span><br><span class="line">        <span class="comment">//0个数一定组合不出来什么 这样的初始状态无意义 所以要从1个数开始</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target) dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>; <span class="comment">//这里的判断别忘记加</span></span><br><span class="line">        <span class="comment">//for(int j=0;j&lt;=target;j++) dp[0][j] = nums[0]==j? true:false;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>][j-nums[i]]) dp[i][j] = <span class="keyword">true</span> ; </span><br><span class="line">                <span class="comment">//这里必须这么写 防止把true变为了false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h2><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p>下意识看到觉得好难，然后思路是回溯….</p><p>方法一：回溯法（为什么不需要用for循环呢？)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自己再尝试一下回溯写法</span></span><br><span class="line">        backtrack(nums,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sumIndex == target) count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做加法的选择</span></span><br><span class="line">        sumIndex += nums[index];</span><br><span class="line">        backtrack(nums,target,index+<span class="number">1</span>);</span><br><span class="line">        sumIndex -= nums[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做减法的选择</span></span><br><span class="line">        sumIndex -= nums[index];</span><br><span class="line">        backtrack(nums,target,index+<span class="number">1</span>);</span><br><span class="line">        sumIndex +=nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//还是先写一遍递归的吧 最适合面试A</span></span><br><span class="line">        helper(<span class="number">0</span>,<span class="number">0</span>,nums,target);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> SumIndex, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(SumIndex==target) count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helper(index+<span class="number">1</span>,SumIndex+nums[index], nums,target);</span><br><span class="line">            helper(index+<span class="number">1</span>,SumIndex-nums[index],nums,target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：动态规划（01背包问题）</strong></p><p>思路：看起来不像01背包、但其实就是01背包</p><ul><li><code>dp[i][j]</code> 表示前i个元素可以组成j值的组合数目</li><li>动态规划问题，建议先考虑迭代方程（这样你才知道需要初始化哪些位置：因为不一定总是第1行第1列）</li><li><code>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</code> //总是由上一行推导这一行，所以初始化第一行就ok</li><li> <code>dp[0][j]</code> //第一个元素组合出j的种数，，那就是<code>dp[0][nums[i]] += 1; dp[0][-nums[i]] += 1</code>; 就完事  ！！注意用+=因为这两个可能是同一个位置！！</li><li>最后因为<code>j</code>可能为负数，且范围是[-1000,1000], 所以<code>j</code>索引的位置总是+1000，使索引非负</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j] 表示前i个元素可以组成j值的组合数目</span></span><br><span class="line">        <span class="keyword">int</span> m = nums.length; <span class="keyword">int</span> n = <span class="number">2001</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1000</span>;j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]+<span class="number">1000</span>&gt;=<span class="number">0</span>) dp[i][j+<span class="number">1000</span>] += dp[i-<span class="number">1</span>][j-nums[i]+<span class="number">1000</span>]; </span><br><span class="line">                <span class="keyword">if</span>(j+nums[i]+<span class="number">1000</span>&lt;=<span class="number">2000</span>) dp[i][j+<span class="number">1000</span>] += dp[i-<span class="number">1</span>][j+nums[i]+<span class="number">1000</span>]; </span><br><span class="line">                <span class="comment">//if(j==0) System.out.println(dp[i][j+1000]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][target+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说他是零一背包的问题呢？因为都是由上一行的状态推导这一行，并且推导过程需要减去（加上）<code>nums[i]</code></p><ul><li><code>dp[i][j] += dp[i-1][j-nums[i]]</code></li><li><code>dp[i][j] += dp[i-1][j+nums[i]]</code></li></ul><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h2><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p></blockquote><p>思路：就是多了一维的01背包问题</p><ul><li><code>dp[i][j][k]</code> 表示前<code>i</code>索引的字符串 满足0的个数&lt;=j &amp;&amp; 1的个数&lt;=k的最大子集的大小</li><li><code>dp[i][j][k] = dp[i-1][k][j]</code>; <code>dp[i][j][k] = dp[i-1][j-a][k-b]+1</code>    a、b分别表示strs[i]中0和1的个数</li><li>初始化：01背包问题都是有上一行推导下一行、所以只用初始化第一行<code>dp[0][j][k] =1 if(j&gt;=a&amp;&amp;k&gt;=b)</code></li></ul><p>代码：其实代码简单、就是不容易想到是01背包问题…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//恐怖如斯，，我思路和题解完全一致..多了一维的01背包问题</span></span><br><span class="line">        <span class="comment">//dp[i][j][k] 表示前i索引的字符串 满足0的个数&lt;=j &amp;&amp; 1的个数&lt;=k的最大子集的大小</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] temp = getCount(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=temp[<span class="number">0</span>];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=temp[<span class="number">1</span>];k--)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j][k]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                    temp = getCount(strs[i]);</span><br><span class="line">                    <span class="keyword">if</span>(temp[<span class="number">0</span>]&lt;=j&amp;&amp;temp[<span class="number">1</span>]&lt;=k) dp[i][j][k] = Math.max(dp[i][j][k], dp[i-<span class="number">1</span>][j-temp[<span class="number">0</span>]][k-temp[<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getCount(String s)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;0&#x27;</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-完全背包题解"><a href="#3-完全背包题解" class="headerlink" title="3 完全背包题解"></a>3 完全背包题解</h1><blockquote><p><strong>518</strong> 377  322 279 139</p><p>70 爬楼梯是完全背包？我不会写了</p></blockquote><h2 id="440-·-背包问题-III"><a href="#440-·-背包问题-III" class="headerlink" title="440 · 背包问题 III"></a><a href="https://www.lintcode.com/problem/440/">440 · 背包问题 III</a></h2><blockquote><p>给定 <code>n</code> 种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p><p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p><p><strong>样例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4], m &#x3D; 10</span><br><span class="line">输出: 15</span><br><span class="line">解释: 装入三个物品 1 (A[1] &#x3D; 3, V[1] &#x3D; 5), 总价值 15.</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路一：先来一个01背包的解法。（01生万物）</strong></p><ul><li>   完全背包问题，<strong>三层循环</strong></li><li>   <code>dp[i][j]</code>表示前<code>i</code>索引物品任意取，背包容量为<code>j</code>时的最大价值</li><li><pre><code>动态迭代 第`i`索引物品最多使用的个数是 `m/A[i]`   所以次数`k`取0到`m/A[i]`</code></pre></li><li>   ``dp[i][j] = max(dp[i][j], dp[i-1][j-k<em>A[i-1]]+k</em>V[i-1])`</li><li>   初始化 <code>dp[0][j]=j/A[0]*A[0]</code>; <code>dp[i][j]=dp[i-1][j] </code>终点<code>dp[n-1][m]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 完全背包问题，三层循环</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示前i索引物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;=m/A[i];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k*A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*A[i]]+k*V[i] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><ul><li><p><code>dp[i][j]=dp[i-1][j] </code> 同样采用了多用一个元素一定比少用一个元素结果更理想的01背包思想！！</p></li><li><p>动态迭代方程采用<code>dp[i-1][j-k*A[i]]+k*V[i]</code>，表示在上一行的选择基础上、选择k个A[i]元素的价值，，取其中的最大值就好了。就是多了一层k循环的01背包问题</p></li></ul><p><strong>思路二：对于时间问题的简化</strong></p><p>01背包问题是每个物品只能选一次、所以我们只能在上一行未选择A[i]这个元素的基础上继续做选择（选或者不选），，，而完全背包的问题是A[i]这个元素可以选择任意次，所以<strong>我们可以直接在本行已选择A[i]的基础上继续选择！！！</strong>，这就是完全背包和01背包最根本的区别，<strong>所需的改动也仅仅是动态方程中从上行<code>[i-1]</code>选还是从本行<code>[i]</code>选</strong></p><p>一旦我们从本行选择、就无需每次都遍历k次，直接减少一层循环！！因为本行的<code>dp[i][j]</code>用到了本行的<code>dp[i][j-A[i]]</code>所以，<code>j</code>一定过要从小到大遍历！！</p><ul><li> <code>dp[i][j]</code>表示前<code>i</code>索引物品任意取，背包容量为<code>j</code>时的最大价值</li><li>动态迭代： <code>dp[i][j] = max(dp[i][j], dp[i][j-k*A[i-1]]+k*V[i-1])</code></li><li>注意因为 <code>dp[i</code>][j]用到了<code>dp[i][j-k*A[i-1]]</code>，所以<code>j</code>的循环要从小到大</li><li>初始化 <code>dp[0][j]=j/A[0]*A[0]</code>;   <code>dp[i][j]=dp[i-1</code>][j] 终点<code>dp[n-1</code>][m]</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法二：完全背包问题的时间优化</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示前i索引物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(j-A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i][j-A[i]]+V[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路三：进一步对空间问题的简化</strong></p><p>因为求本行的数据只用到了上一行<code>j</code>位置的数据，和本行<code>j</code>之前的数据，所以一维数组就可以(和01背包的空间优化是一个思路)</p><ul><li><code>dp[j]</code>表示示前<code>i</code>个物品任意取，背包容量为<code>j</code>时的最大价值</li><li>动态迭代 j从0迭代到m，，i还是从1迭代到n，，O(mn)时间复杂度</li><li><code>dp[j] = Math.max(dp[j], dp[j-A[i]]+V[i])</code>;</li><li>初始化 <code>dp[j]== j/A[0]*A[0]</code>; 终点<code>dp[m]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法三：完全背包 时间空间都优化</span></span><br><span class="line">        <span class="comment">//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">                <span class="keyword">if</span>(j-A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i]]+V[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以完全背包问题的时间空间简化版本、和01背包的空间优化版本，其实就只有一个<code>j</code>遍历顺序的差别</strong></p><h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h2><blockquote><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><p><strong>思路：完全背包问题，注意第一行的初始化方式！！</strong></p><ul><li><code>dp[i][j]</code>表示前<code>i</code>索引的硬币，能够拼成<code>j</code>的组合数</li><li><code>dp[i][j] += dp[i][j-coins[i]]</code></li><li>初始化 <code>if(j%coins[0]==0) dp[0][j] = 1</code>,,, <code>dp[i][j]= dp[i-1][j]</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型完全背包问题</span></span><br><span class="line">        <span class="comment">//dp[i][j]表示前i索引的硬币，能够拼成j的组合数</span></span><br><span class="line">        <span class="keyword">int</span> m = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化 只要j%coins[0]==0 dp[0][j]=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++) <span class="keyword">if</span>(j%coins[<span class="number">0</span>]==<span class="number">0</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i]&gt;=<span class="number">0</span>) dp[i][j] += dp[i][j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：完全背包，优化空间</strong></p><ul><li><code>dp[j]</code>表示前<code>i</code>索引的硬币，能够拼成<code>j</code>的组合数</li><li><code>dp[j] += [j-coins[i]]</code></li><li>初始化 <code>if(j%coins[0]==0) dp[j] = 1</code>,,, <code>dp[j]= dp[j]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型完全背包问题 优化空间</span></span><br><span class="line">        <span class="comment">//dp[j]表示前i索引的硬币，能够拼成j的组合数</span></span><br><span class="line">        <span class="keyword">int</span> m = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化 只要j%coins[0]==0 dp[0][j]=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++) <span class="keyword">if</span>(j%coins[<span class="number">0</span>]==<span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">                <span class="keyword">if</span>(j-coins[i]&gt;=<span class="number">0</span>) dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>完全背包问题和01背包问题的区别在于是否可以重复选择，对应到代码层面，就是当前行是由当前行推导（完全背包）还是由上一行推导（01背包）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划之背包问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wukang555.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="力扣" scheme="https://wukang555.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://wukang555.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包问题" scheme="https://wukang555.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-力扣题解</title>
    <link href="https://wukang555.github.io/2021/11/18/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wukang555.github.io/2021/11/18/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-11-18T14:55:00.000Z</published>
    <updated>2022-05-17T12:23:17.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/comments/377874">“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。”</a></p><p><a href="https://leetcode-cn.com/problems/3sum/comments/401721">“十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”</a></p><a id="more"></a><blockquote><p>[1] 定义部分参考了力扣官方<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/xceyqr/">力扣小卡片-动态规划</a></p><p>[2] 使用方法和力扣题目来自于<a href="https://greyireland.gitbook.io/algorithm-pattern/ji-chu-suan-fa-pian/dp">开源模板-动态规划</a></p><p>[3] 文章结构和代码全凭个人理解、错误之处敬请指出；除标注外皆原创、保留权力</p></blockquote><h2 id="1-如何使用动态规划"><a href="#1-如何使用动态规划" class="headerlink" title="1 如何使用动态规划"></a>1 如何使用动态规划</h2><p>​        动态规划（Dynamic programming，简称 DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划不是某一种具体的算法，而是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。[1]</p><p>​        现阶段的刷题就是为了面试撕代码，所以第一节直接讲怎么用，第二节再讲DP是什么。</p><h3 id="1-1-使用场景-2"><a href="#1-1-使用场景-2" class="headerlink" title="1.1 使用场景[2]"></a>1.1 使用场景[2]</h3><ul><li><strong>满足以下条件之一</strong><ul><li>求最大/最小值（Maximum/Minimum ）</li><li>求是否可行（Yes/No ）</li><li>求可行个数（Count(*) ）</li></ul></li><li><strong>满足不能排序或者交换（Can not sort / swap ）</strong></li></ul><h3 id="1-2-四点要素-2"><a href="#1-2-四点要素-2" class="headerlink" title="1.2 四点要素[2]"></a>1.2 四点要素[2]</h3><ul><li>状态 State<ul><li><strong>灵感，创造力，存储小规模问题的结果</strong></li></ul></li><li>方程 Function<ul><li>状态之间的联系，怎么通过小的状态，来算大的状态</li></ul></li><li>初始化 Intialization<ul><li>最极限的小状态是什么, 起点</li></ul></li><li>答案 Answer<ul><li>最大的那个状态是什么，终点</li></ul></li></ul><h3 id="1-3-示例模板-斐波那契数"><a href="#1-3-示例模板-斐波那契数" class="headerlink" title="1.3 示例模板-斐波那契数"></a>1.3 <a href="https://leetcode-cn.com/problems/fibonacci-number/">示例模板-斐波那契数</a></h3><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p></blockquote><p>​        以最为简单的斐波拉契数作为例子，<strong>方便理解动态规划算法的使用流程</strong>。<strong>四点要素中我觉得最重要的是状态</strong>，状态用来存储小规模问题的结果、状态的选择需要创造力，但就应试考试而言、我们通过经验来弥补就好了。其次是状态转移方程、基本只要能列出方程就离解题不远了。本题而言、方程已经直接给了就可以直接上手：</p><ul><li>动态规划 <code>dp[i]</code>表示<code>F(i)</code>的值</li><li>初始化 <code>dp[0]=0, dp[1]=1</code>; 终点求<code>dp[n]</code></li><li>状态转移方程 <code>dp[i]=dp[i-1]+dp[i-2]</code>;</li></ul><p>模板代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        至于怎么减少空间复杂度，重复利用<code>dp</code>数组的空间，其实是细支末节，并不很难，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//重复利用空间</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-介绍动态规划-1"><a href="#2-介绍动态规划-1" class="headerlink" title="2 介绍动态规划[1]"></a>2 介绍动态规划[1]</h2><p>​        应用这种动态规划算法思想解决问题的可行性，对<strong>子问题与原问题的关系</strong>，以及<strong>子问题之间的关系</strong>这两方面有一些要求，它们分别对应了<strong>最优子结构</strong>和<strong>重复子问题</strong>。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>一个问题的最优解是由它的各个子问题的最优解决定的。将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。找到了最优子结构，也就能推导出一个状态转移方程 $f(n)$</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213436.png" alt="img"></p><h3 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h3><p>重复子问题规定的是子问题与子问题的关系。动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。</p><p>动态规划算法中关于最优子结构和重复子问题的理解的关键点：</p><ul><li>证明问题的方案中包含一种选择，选择之后留下一个或多个子问题</li><li>设计子问题的递归描述方式</li><li>证明对原问题的最优解包括了对所有子问题的最优解</li><li>证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）</li></ul><h2 id="3-力扣题解"><a href="#3-力扣题解" class="headerlink" title="3 力扣题解"></a>3 力扣题解</h2><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h3><blockquote><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标<code>i</code>或<code> i + 1</code> 。</p></blockquote><p>思路：</p><ul><li>这题状态的选择很有创造性，<strong>从底部往上动态查找</strong></li><li><code>dp[i][j]</code>表示 第<code>i</code>行的<code>j</code>节点出发 到第<code>n</code>行的最小路径和</li><li>初始化<code> dp</code>为原集合 目标<code>dp[0][0]</code></li><li>动态迭代 <code>dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1])+arr[i][j]</code></li></ul><p>代码：空间优化就是一维数组，代码就不再列出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">1</span>) <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化最后一层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][j] = triangle.get(m-<span class="number">1</span>).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><blockquote><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213441.jpg" alt="img" style="zoom: 67%;"><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>思路：</p><ul><li>原地动态规划<code> dp[i][j]</code>表示从左上角到<code>i,j</code>处的最小路径和</li><li>初始化<code>dp[0][i], dp[j][0]</code>累计即可  终点<code>dp[m-1][n-1]</code></li><li>动态规划方程<code> dp[i][j] = grid[i][j]+ Math.min(dp[i-1][j],dp[i][j-1])</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                grid[i][j] += Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例 1：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213444.jpg" alt="img" style="zoom:67%;"><p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2</p></blockquote><p>思路：</p><ul><li>状态就是某网格的路径数 有障碍物时当前为0</li><li><code>dp[i][j]</code>表示从左上角到<code>i,j</code>位置的路径数目</li><li>初始化 第一行第一列为1 如果出现障碍物后面全0 终点<code>dp[m-1][n-1]</code></li><li>动态迭代 有障碍物则0，如果没有就<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li></ul><p>代码：其实如果新建一个<code>dp[][]</code>数组后细节处更不易出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//排除干扰</span></span><br><span class="line">        <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;j++) obstacleGrid[j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里第一行要从第二个开始了 因为第一列初始化已经修改了值！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++) obstacleGrid[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    obstacleGrid[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    obstacleGrid[i][j]=obstacleGrid[i-<span class="number">1</span>][j]+obstacleGrid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><blockquote><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p>思路：动态规划——维护每个点是否可达的数组</p><ul><li><code>dp[i] </code>表示能否跳到<code>i+1</code>这个节点</li><li><code>dp[0] = true</code>  求<code>dp[n-1]</code>;</li><li><strong>动态迭代求<code>dp[i]</code>时，从<code>i-1</code>处向前找</strong></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;n&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">//默认为false</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//动态迭代求dp[i]时，从i-1处向前找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span>&amp;&amp;i-j&lt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p></blockquote><p>这个动态规划怎么这么慢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示从索引i到j的子串是否是回文串</span></span><br><span class="line">        <span class="comment">//动态迭代 dp[i][j] = dp[i+1][j-1] &amp;&amp; s.charAt(i)==s.charAt(j);</span></span><br><span class="line">        <span class="comment">//两层循环 外层长度从1到n  内层索引 i从0到n-l</span></span><br><span class="line">        <span class="comment">//初始化 需要初始长度为1 和长度为2 的dp</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> length=<span class="number">1</span>;length&lt;=n;length++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n-length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+length-<span class="number">1</span>;  <span class="comment">//[i,j]</span></span><br><span class="line">                <span class="keyword">if</span>(length==<span class="number">1</span>) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(length==<span class="number">2</span>) dp[i][j] = s.charAt(i)==s.charAt(j);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s.charAt(i)==s.charAt(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;length&gt;maxLength)&#123;</span><br><span class="line">                    maxLength = length;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的频率不是一般的高，暴力解法也来爽一爽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想先写一个暴力解法</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">                String cur = s.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(cur)&amp;&amp; cur.length()&gt;maxLength)&#123;</span><br><span class="line">                    left = i; right = j;</span><br><span class="line">                    maxLength = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(s.length()-i-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h3><blockquote><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 最少分割次数 。</p><p>示例 1：</p><p>输入：s = “aab”<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。</p></blockquote><p>思路：</p><ul><li><code>dp[i]</code>表示1到i的子串的最小分割次数 <code>dp = new int[n+1]</code>; <code>dp[]</code>的长度比字符串s大1</li><li><code>dp[i]</code>的初始化为<code>dp[i-1]+1</code>,,并且<code>dp[1]=0; dp[0]=-1</code>，终点<code>dp[n]</code></li><li><code>dp[i]</code>的求解需要利用遍历，<code>j</code>从<code>0</code>遍历到<code>i-1</code> 如果有<code>[j+1,i]</code>部分是回文的(对应于<code>s(j,i-1)</code> )则<code>dp[i]=Math.min(dp[i],dp[j]+1)</code></li></ul><p>代码：运行相当之慢，好像判断是否回文哪里可以用动态规划优化一下（回头再看吧…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=-<span class="number">1</span>; dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//[j+1,i]为回文则取小值</span></span><br><span class="line">                <span class="keyword">if</span>(isBack(s,j,i-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBack</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)!=s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><ul><li>和分割回文子串的最小次数是一类题，<code>dp[i]</code>的求解需要 <code>dp[]数组</code>从<code>0</code>往<code>i</code>的遍历 找找迭代方程中的需要的那个元素</li><li><code>dp[i]</code>表示<strong>以<code>i</code>索引元素结尾的</strong>严格增子序列的长度！！！<code>dp[i]</code>非递增，而是代表类它自己那个递增序列的长度</li><li>初始化 <code>dp[0]=1; dp[i]=1</code> 终点不是<code>dp[n-1]</code>，而是**<code>dp[i]</code>数组的最大值**</li><li>动态迭代<code> j</code>有<code>0</code>到<code>i-1</code>,<code>if(nums[j]&lt;nums[i])</code> 则<code>dp[i] =max(dp[i], dp[j]+1)</code>,,,</li><li>用一个<code>maxResult</code>记录<code>dp[]</code>数组的最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxResult=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]) dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxResult=Math.max(dp[i],maxResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h3><blockquote><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure></blockquote><p>​        思路：连续三道<strong>找状态<code>dp[i]</code>，需要遍历<code>dp[]</code>数组<code>i</code>之前的所有元素</strong>、来判断<code>dp[i]</code>的取值了！！ 都是复杂度为<code>O(n2)</code>的<code>DP</code></p><ul><li><code>dp[i]</code>表示字符串第<code>i-i</code>个元素，是否可以被拆分为字典中出现的词</li><li><code>dp[0]</code>表示无字符串为true， 终点<code>dp[n]</code></li><li>动态迭代 当<code>dp[j]=true&amp;&amp;[j+1,i]位于字典中</code>，对应s的索引为<code>s[j,i-1]</code></li><li>用set集合判断是否在字段中</li></ul><p>​    代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">//因为求dp[1]要用到dp[0]索引定义dp长度为n+1！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span> &amp;&amp; wordDictSet.contains(s.substring(j,i)) )&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：想复杂了没想到是一个简单的DP</p><ul><li>当<code>text[i]==text[j]</code>时 <code>dp[i][j] = dp[i-1][j-1]+1</code></li><li>否则 <code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code></li><li>初始化<code>dp[0][0] = 0</code>第一行第一列都为0 终点<code>dp[m][n]</code></li><li><strong>定义m+1 n+1维的数组就很完美</strong></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(); <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li><code>dp[i][j]</code>表示word1前<code>i</code>个转换成word2前<code>j</code>个 所需使用的最小操作数</li><li>初始化 第一行<code>dp[0][j]=j </code>第一列<code>dp[i][0]=i</code>    //终点<code>dp[m][n]</code></li><li>动态规划,若<code>word1.charAt(i-1)==word2.charAt(j-1)</code> 则<code>dp[i][j]=dp[i-1][j-1]</code>表示不需要操作</li><li>若不相等 则<code>dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code></li><li><strong>定义m+1 n+1维的数组就很完美</strong><ul><li>因为要用到<code>i-1 j-1</code>,所以需要从<code>1</code>开始循环，<code>dp[0][0]</code>表示都为空时的状态，<code>dp[1][1]</code>代表第一个元素的状态，所以<code>dp[m][n]</code>是终点</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行第一列为i,j</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min( Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>; <span class="comment">//分别对应：增加、增加、替换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-面试高频题"><a href="#4-面试高频题" class="headerlink" title="4 面试高频题"></a>4 面试高频题</h2><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213451.jpg" alt="img" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></blockquote><p>思路：这题的关键是状态的确定 还有迭代方程</p><ul><li><code>dp[i][j]</code>表示以<code>[i][j]</code>为右下角，且只包含 1 的正方形的边长最大值</li><li>初始化：第一行第一列最大为1，并且就等于<code>matrix</code>矩阵的值</li><li>需要用一个<code>maxLength</code>记录最大边长</li><li>迭代方程<code> dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLength) maxLength=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength*maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h3><blockquote><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure></blockquote><p>思路：动态规划，有变化的地方在于p，需要分类考虑</p><ul><li>状态<code>dp[i][j]</code>表示s的前<code>i</code>个字符和p的前<code>j</code>个字符是否匹配成功</li><li>初始化 <code>dp[0][0]=true</code>, <code>dp[i][0]=false</code>; <code>dp[0][j]</code>仅p前j个全为*才为真； 终点<code>dp[m][n]</code></li><li>动态迭代 如果p[j]为小写字母，<code>dp[i][j] = s[i]==p[j] &amp;&amp; dp[i-1][j-1]</code></li><li>如果 p[j]为？, <code>dp[i][j] = dp[i-1][j-1]</code></li><li>如果 p[j]为*， <code>dp[i][j] = dp[i][j-1] || dp[i-1][j]</code>; 分别表示 *使用和不使用的情况 (这里难想一点)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//为小写字母</span></span><br><span class="line">                    dp[i][j] = s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) &amp;&amp; dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><blockquote><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>动态规划 状态<code>dp[i]</code>表示索引<code>i</code>的字符结尾的最长有效子串的长度</li><li>初始化<code>dp[i]=0</code>, 终点：求<code>dp[]数组</code>的最大值</li><li>动态迭代 当<code>s[i]为&#39;(&#39; </code>时<code>dp[i]=0</code>;</li><li>1形如<code>&quot;...()&quot;</code> 当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;(&#39; 时 dp[i]=dp[i-2]+2</code>;</li><li>2形如<code>&quot;...))&quot; </code>当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;)&#39; </code>时 当前一个子串之前的有<code>(</code>能与s[i]的<code>)</code>配对时，需<code> +2+(之前的子串长度</code><ul><li> <code>if(s[i-dp[i-1]-2]==&#39;(&#39;)</code> 则<code>dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]</code></li></ul></li><li>注意每一次赋值判断之前都要判断s和dp是否可能发生越界！！细节太多了！</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;=<span class="number">2</span>) dp[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&lt;<span class="number">0</span>) dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候需要定义<code>dp[]</code>数组长度+1，还真实一个苦恼的问题</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>状态：<code>dp[i][0]</code> 第i天不持有的最大利润;<code>dp[i][1]</code> 第i天持有的最大利润</li><li>初始化:<code>dp[0][0] = 0; dp[0][1] = -prices[0]</code>   ；终点：<code>dp[n-1][0]</code> </li><li>只能买卖一次 说明买入的时候 资产为<code>-prices[i]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只能买卖一次 说明买入的时候 资产为-price[i]</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少空见复杂度,重复利用<code>dp[]数组</code>的空间</p><ul><li><code>% 2</code>还可以写成 <code>&amp; 1</code>，这里为了保证可读性，选用 <code>% 2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(n-<span class="number">1</span>)&amp;<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//与运算博大精深啊</span></span><br><span class="line">        <span class="comment">//return Math.max(dp[1][0],dp[0][0]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><ul><li>状态 <code>dp[i][j]</code>表示索引<code>i</code>天状态<code>j</code>下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</li><li>初始化 第一天：<code>dp[0][0]=dp[0][2]=dp[0][4]=0</code>; <code>dp[0][1]=dp[0][3]=-prices[0] </code> 终点<code>dp[n-1][2or4]</code></li><li>动态迭代 <code>dp[i][0] = 0; dp[i][1] =max(-prices[i],dp[i-1][1]); dp[i][2] = max(dp[i-1][1]+prices[i],dp[i-1][2]);</code></li><li><code>dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3]); dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4]);</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态 dp[i][j]表示索引i天状态j下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>]= dp[<span class="number">0</span>][<span class="number">3</span>] =-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]= dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">2</span>],dp[n-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//状态：0表示未交易 1表示买入一次 2表示卖出一次 3表示买入两次 4表示卖出两次</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">4</span>] = Math.max(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><blockquote><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>状态（0到2k） 0表示未交易 1表示买入一次 2表示卖出一次…2k-1表示买入k次，2k表示卖出k次</li><li>初始化：<code>dp[0]</code>始终为0；<code>dp[1]= - prices[0]</code>；<code>dp[2-end]</code>初始化为一个小值</li><li>动态迭代：<ul><li><strong>外层循环</strong>为考虑的天数，从<code>i=1:n-1</code></li><li><strong>内层循环</strong>为遍历所有状态：从<code>j=1:2k</code></li><li>如果当前状态索引j为奇数，也就是手头有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] - prices[i])</code></li><li>如果当前状态索引j为偶数，也就是手头没有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] + prices[i])</code></li></ul></li><li>终点为数组<code>dp[] </code>的最大值</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[]:2k+1;  dp[2*k-1]买入k次  dp[2*k]表示卖出k次</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        k = Math.min(k,n/<span class="number">2</span>); <span class="comment">//最多进行n/2次交易！！</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp为小值</span></span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i++) dp[i]= Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//按天数动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]+prices[i],dp[j]);</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">1</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]-prices[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><blockquote><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>//<code>dp[i][j]</code> 表示n1以<code>i</code>开头、n2以<code>j</code>开头的子数组的最长公共子数组长度 即<code>nums1[i:end] nums2[j:end]</code></li><li>//初始化<code>dp[m-1][n-1]=0or1</code>;<code> dp[m-1][j]=0or1; dp[i][n-1]=0or1</code>; 终点<code>dp[0][0]</code>，求数组<code>dp[][]</code>的最大值</li><li>//动态迭代 <code>nums1[i]==nums2[j]? dp[i][j] = dp[i+1][j+1]+1:0</code>;</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个反序推导的题</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[m-<span class="number">1</span>]==nums2[j]) dp[m-<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]==nums2[n-<span class="number">1</span>]) dp[i][n-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] =  nums1[i]==nums2[j]? dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;res) res = dp[i][j];          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接定义<code>dp[][]</code>数组的长度为<code>[m+1,n+1]</code>,那样就不用初始化了</p><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li><code>dp[i]</code>表示偷窃前<code>i</code>个房屋所能获得的最大金额</li><li>初始化 <code>dp[0]=nums[0]</code> <code>dp[1]=Max(dp[0],nums[1])</code>; 终点<code>dp[n-1]</code></li><li>动态迭代 <code>dp[i] = Max(dp[i-1],dp[i-1]+nums[i])</code>;</li></ul><p>代码: 如果使用滚动数组可以减少空间复杂度、不列出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示偷窃前i个房屋所能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; dp[<span class="number">1</span>]=Math.max(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p></blockquote><p>思路：</p><ul><li><code>dp[i] </code>表示前<code>i</code>件范围盗窃 最大金额</li><li><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code>;</li><li>如果第一件盗窃 则盗窃范围为[0,n-2]</li><li>如果第一间不盗窃 范围为[1,n-1]</li><li><strong>因为要用到<code>dp[i-2]</code>，所以用<code>dp[0]=0</code>表示不盗窃！！</strong></li></ul><p>代码一：两个<code>dp[]</code>数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相当于两个动态规划的叠加 1盗窃第一间房[0,n-2] 2不盗窃第一间房[1,n-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]; <span class="comment">//盗窃第一间房</span></span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]; <span class="comment">//盗窃了第二间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">            dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1[n-<span class="number">1</span>],dp2[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：滚动数组优化空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一件盗窃 则盗窃范围为[0,n-2]</span></span><br><span class="line">        <span class="comment">//如果第一间不盗窃 范围为[1,n-1]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//前3 后3</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">2</span>],Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//初始化 至少有四个元素</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">3</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = Math.max(nums[<span class="number">2</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//两种情况循环次数是一样的 注意i的大小就好了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+nums[i]);</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//第二种情况</span></span><br><span class="line">            dp[<span class="number">5</span>] = Math.max(dp[<span class="number">4</span>],dp[<span class="number">3</span>]+nums[i+<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">4</span>];</span><br><span class="line">            dp[<span class="number">4</span>] = dp[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//System.out.println(dp[5]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><blockquote><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure></blockquote><p>思路：注意负负得正</p><ul><li>因为 负负得正，一个负数乘一个很小的负数可能得到一个很大的乘积，所以对每个i索引要分别保存最大乘积和最小乘积</li><li><code>dp[i][0]</code>表示<code>i</code>索引元素结尾的连续子数组的最大乘积 <code>dp[i][1]</code>表示最小乘积</li><li>初始化<code>dp[0][0]=dp[0][1]=nums[0]</code>; 终点<code>dp[i][0]</code>数组的最大值</li><li>动态迭代 <code>dp[i][0] = max(dp[i-1][0]*numd[i],dp[i-1][1]*nums[i],nums[i])</code>; <code>dp[i][1] = min(...)</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][0]表示i索引元素结尾的连续子数组的最大乘积 dp[i][1]表示最小乘积</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            max = Math.max(max,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p></blockquote><p>思路：</p><ul><li>动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</li><li><code>dp[i]</code>表示第<code>i</code>个字符前的子串解码方法的总数，<strong>因为要用到<code>i-2</code>所以令<code>dp[0]=1</code>代表空字符串</strong></li><li>初始化 <code>dp[0]=dp[1]=1</code>; 终点<code>dp[n]</code></li><li>动态迭代 单个字符结尾<code>s[i]!=&#39;0&#39; dp[i] += dp[i-1]</code>;</li><li>两个字符结尾 <code>s[i-1]!=&#39;0&#39;&amp;&amp; s[i-1]s[i]&lt;=26 dp[i] += dp[i-2]</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</span></span><br><span class="line">        <span class="comment">//dp[i]表示第i个字符前的子串解码方法的总数</span></span><br><span class="line">        <span class="comment">//因为要用到i-2所以令dp[0]=1代表空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)!=<span class="string">&#x27;0&#x27;</span>) dp[i] +=dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>)!=<span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">2</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h3><blockquote><p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：k &#x3D; 1, n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f &#x3D; 0 。 </span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f &#x3D; 1 。 </span><br><span class="line">如果它没碎，那么肯定能得出 f &#x3D; 2 。 </span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：k &#x3D; 2, n &#x3D; 6</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：k &#x3D; 3, n &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></blockquote><p>思路：动态规划+二分查找</p><ul><li>动态规划 <code>dp[i][j]</code>表示用<code>i</code>个鸡蛋确定<code>j</code>层楼房的f值 的最小操作数</li><li>初始化 <code>dp[i][1]= 1 </code>一层楼房 抛一次就确定了 ；<code>dp[1][j]=j </code>一个鸡蛋确定<code>j</code>层楼房 从下往上试直到摔破共<code>j</code>次</li><li>终点<code> dp[k][n]</code></li><li>动态迭代 外层<code>i从2到k个鸡蛋</code> 内层<code>j从2层到n层楼房</code>； 如果不用二分、第三层 <code>x从1到n</code></li><li><code>dp[k][n] = 1+ min( max( dp[k-1,x-1] , dp[k,n-x]) )</code> 摔破/没摔破 取所有x的小值</li><li><strong><code>dp[k-1][x-1]</code>随x递增 <code>dp[k][x-k]</code>随x递减,，注意画这两个单调数列的图（两条直线），就明白如何用二分了，取两个函数的大值，就是上边的折线，然后找整个折线的最小值</strong></li><li>使用二分找到 <code>dp[k-1][x-1] &lt; dp[k][n-x]</code> 的最后一个x0，，然后比较获得<code>min(T1(x0+1), T2(x0))</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示用i个鸡蛋确定j层楼房的f值 的最小操作数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) dp[i][<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">1</span>][j]= j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果不用二分算法</span></span><br><span class="line">                <span class="comment">// int min = n+1;</span></span><br><span class="line">                <span class="comment">// for(int x=1;x&lt;=j;x++)&#123;</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = 1 + Math.min(min, Math.max(dp[i-1][x-1],dp[i][j-x])) </span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//二分算法</span></span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = j;</span><br><span class="line">                <span class="comment">//要找T1小于T2的最大x0</span></span><br><span class="line">                <span class="keyword">int</span> x0=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">                    x0 = left+(right-left)/<span class="number">2</span>; </span><br><span class="line">                    <span class="keyword">if</span>( dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&lt;dp[i][j-x0])&#123;</span><br><span class="line">                        left = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&gt;dp[i][j-x0])&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断right和left谁才是真正要找的x0的位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][right-<span class="number">1</span>]&lt;=dp[i][j-right]) x0=right;</span><br><span class="line">                <span class="keyword">else</span> x0= left;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//所以最小值 min(T1(x0+1),T2(x0))</span></span><br><span class="line">                dp[i][j] =<span class="number">1</span> + Math.min(dp[i-<span class="number">1</span>][x0+<span class="number">1</span>-<span class="number">1</span>], dp[i][j-x0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h3><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>动态规划 <code>dp[i][j]</code>表示索引<code>i</code>之前的数能够构造出结果<code>j</code>的表达式数目</li><li>因为属于j[-1000,1000], 所以事实上用<code>dp[i][j+1000]</code>，</li><li>动态规划 <code>dp[i][j+1000-nums[i]] += dp[i-1][j+1000];</code> //对应-号</li><li><code>dp[i][j+1000+nums[i]] += dp[i-1][j+1000]</code>; //对应+号</li><li><code>i</code>外层循环<code>[0，n-1]</code>；<code> j</code>内层循环<code>[-1000，1000]</code></li><li>不知道初始化谁，就手动循环一遍发现只用<code>i=0, dp[0][j+1000]+=1</code>就好了,其中<code>j=nums[0]/-nums[0]</code>,一定要+=防止出现多个0的情况！！、其他必然为0</li><li>终点 <code>dp[n-1][target+1000]</code>;</li><li>对于<code>j</code>的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别，就是用<code>[j]</code>更新<code>[j+/-nums[i]]</code><ul><li>如果<code>dp[i - 1][j]==0</code>就没有进入更新的必要</li></ul></li></ul><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示索引i之前的数能够构造出结果j的表达式数目</span></span><br><span class="line">        <span class="comment">// 因为属于j[-1000,1000],所以事实上用dp[i][j+1000]，</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2001</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1000</span>;j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//对于j的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别</span></span><br><span class="line">                <span class="comment">//就是用[j]更新[j+/-nums[i]]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j + <span class="number">1000</span>] &gt; <span class="number">0</span>)&#123; <span class="comment">//如果==0就没有进入更新的必要</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>-nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应-号</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>+nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应+号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleavingz-string/">97. 交错字符串</a></h3><blockquote><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>提示：a + b 意味着字符串 a 和 b 连接。</p></blockquote><p>思路:</p><ul><li><del>开始我想错了 以为i、j之差不能超过1,没必要没必要</del></li><li><code>dp[i][j]</code>表示s1的前<code>i</code>个与s2的前<code>j</code>个能否交错组成s3的前<code>(i+j)</code>个s3，，s1+s2与s3长度若不相等直接返回false</li><li>初始化<code>dp[0][j]=true</code>仅当<code>s2[0:j-1]=s3[0:j]</code>;    <code>dp[i][0]=true仅当s1[0:i-1]=s3[0:i]</code></li><li>动态迭代 <code>dp[i][j] = dp[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示s1的前i个与s2的前j个能否交错组成s3的前(i+j)个s3</span></span><br><span class="line">        <span class="keyword">int</span> m =s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(n+m!=s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = ( dp[i-<span class="number">1</span>][j]&amp;&amp;s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>+j) ) || </span><br><span class="line">                        (dp[i][j-<span class="number">1</span>]&amp;&amp;s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-背包问题-领扣）"><a href="#5-背包问题-领扣）" class="headerlink" title="5 背包问题(领扣）"></a>5 背包问题(领扣）</h2><p>我为什么这么菜？还是直接以题代学。领扣上面有全套的背包题。</p><h3 id="125-·-背包问题（二）"><a href="#125-·-背包问题（二）" class="headerlink" title="125 · 背包问题（二）"></a><a href="https://www.lintcode.com/problem/125/description">125 · 背包问题（二）</a></h3><blockquote><p>描述</p><p>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值.</p><p>问最多能装入背包的总价值是多大?</p><p><code>A[i], V[i], n, m</code> 均为整数你不能将物品进行切分你所挑选的要装入背包的物品的总大小不能超过 <code>m</code>每个物品只能取一次</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D; 10</span><br><span class="line">A &#x3D; [2, 3, 5, 7]</span><br><span class="line">V &#x3D; [1, 5, 2, 4]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p>解释：</p><p>装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9</p></blockquote><p><strong>就是最基础的01背包问题，每一个物品只能用一次。</strong></p><p>思路1：二维数组</p><ul><li><code>dp[i][j]</code>表示前<code>i</code>个物品装入<code>j</code>大小的背包 的最大总价值数</li><li>初始化<code>dp=[i][0]0</code>; 终点<code>dp[n][m]</code></li><li>动态迭代：i的范围<code>[1,n]</code>  j的范围<code>[0,m]</code>  状态分别对应将第i个物品装入背包和不装入背包两种情况</li></ul><p>$$<br>dp[i][j]=max(dp[i-1][j], dp[i-1][j-A[i-1]]+V[i-1])<br>$$</p><p>代码1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品装入j大小的背包 的最大总价值数</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&lt;<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max( dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+ V[i-<span class="number">1</span>] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：空间优化的一维数组</p><p>我们发现，欲求<code> dp[i][j]</code>需要使用<code>dp[i-1][j]</code>和<code>dp[i-1][j-A[i-1]]</code>两种状态，显然就是计算<code>i</code>时需要<code>i-1</code>时候的状态！！ 令状态<code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>能装的最大价值数，每遍历完一次、就更新了该数组一次。状态转移方程：<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$<br>但是这时出现了一个问题：如果<code>j</code>仍然从0遍历到最大容量m，，，<code>dp[j-A[i-1]]</code>总是先于<code>dp[j]</code>更新，所以更新过程，用到了更新的数组的值、当然就有问题了。。</p><p><strong>这个时候就需要反向遍历,<code>j</code>仍然从m遍历到0，，计算索引靠右边的<code>dp[j]</code>时，利用的是上一个数组中的<code>dp[j]</code>和没有更新的索引位置较小的<code>dp[j-x]</code></strong></p><p>动态规划的要素如下：</p><ul><li><code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>的背包能装的最大价值数</li><li>初始化dp[j]=0标识0个物品时的最大价值 , 终点dp[m]标识n个物品时容量m背包的最大价值数</li><li>动态迭代 j从m迭代到0，状态转移方程如上 ，<strong>i还是从1迭代到n，，时间并没有优化！！</strong></li></ul><p>代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>) dp[j] = Math.max(dp[j],dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="92-·-背包问题"><a href="#92-·-背包问题" class="headerlink" title="92 · 背包问题"></a><a href="https://www.lintcode.com/problem/92/description">92 · 背包问题</a></h3><blockquote><p>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为A[i]</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组 &#x3D; [3,4,8,5]</span><br><span class="line">backpack size &#x3D; 10</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></blockquote><p>思路：就是01背包问题，然后体积和价值是同一个数组</p><p>代码：一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实就是01背包问题，然后体积和价值是同一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=A[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+A[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="440-·-背包问题-III"><a href="#440-·-背包问题-III" class="headerlink" title="440 · 背包问题 III"></a><a href="https://www.lintcode.com/problem/440/">440 · 背包问题 III</a></h3><blockquote><p>给定 <code>n</code> 种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p><p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p><p>不能将一个物品分成小块.放入背包的物品的总大小不能超过 <code>m</code>.</p><p><strong>样例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4], m &#x3D; 10</span><br><span class="line">输出: 15</span><br><span class="line">解释: 装入三个物品 1 (A[1] &#x3D; 3, V[1] &#x3D; 5), 总价值 15.</span><br></pre></td></tr></table></figure></blockquote><p><strong>就是最经典的完全背包问题，每一个物品只能无限次。</strong></p><p>思路1：三层循环</p><ul><li><code>dp[i][j]</code>表示前i个物品任意取，背包容量为j时的最大价值</li><li>初始化 <code>dp[i][0]=0</code>; 终点<code>dp[n][m]</code></li><li>动态迭代 第<code>i</code>个物品最多使用的个数是 <code>m/A[i-1]</code>    k取0到<code>m/A[i-1]</code></li><li><code>dp[i][j] = max( dp[i-1][j-k*A[i-1]]+k*V[i-1])</code></li></ul><p>代码1：就嗯循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j];</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;=m/A[i-<span class="number">1</span>];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k*A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]]+k*V[i-<span class="number">1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：O(nm)的算法，翻转01背包的遍历顺序即可！！这里摘用一下《背包九讲》中的解释</p><blockquote><p>首先想想为什么 01 背包中要按照 j 递减的次序来循环。让 j 递减是为了保证第i次循环中的状态 <code>dp[i, j]</code> 是由状态 <code>dp[i − 1, j − Ai]</code> 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 <code>i </code>件物品”这件策略时，依据的是一个绝无已经选入第 <code>i </code>件物品的子结果 <code>dp[i − 1, j − Ai]</code>。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第<code> i</code> 种物品”这种策略时，却正需要一个可能已选入第<code>i</code>种物品的子结果 <code>dp[i, j − Ai]</code>，所以就可以并且必须采用 <code>j</code>递增的顺序循环。这就是这个简单的程序为何成立的道理。</p></blockquote><ul><li><p>//完全背包 时间空间都优化</p></li><li><p>//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</p></li><li><p>//初始化 dp[0]=0; 终点dp[m]</p></li><li><p>//动态迭代 j从0迭代到m，，i还是从1迭代到n，，O(mn)时间复杂度！！<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$</p></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//完全背包 时间空间都优化</span></span><br><span class="line">        <span class="comment">//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i-<span class="number">1</span>];j&lt;=m;j++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/comments/377874&quot;&gt;“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/comments/401721&quot;&gt;“十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wukang555.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="力扣" scheme="https://wukang555.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://wukang555.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Redis面经</title>
    <link href="https://wukang555.github.io/2021/08/03/%E9%9D%A2%E7%BB%8F_09_Redis/"/>
    <id>https://wukang555.github.io/2021/08/03/%E9%9D%A2%E7%BB%8F_09_Redis/</id>
    <published>2021-08-03T14:55:00.000Z</published>
    <updated>2022-05-17T12:19:32.417Z</updated>
    
    <content type="html"><![CDATA[<p>Redis系统的理解和介绍。</p><a id="more"></a><blockquote><p>[1] 主要参考了库森的总结<a href="https://github.com/cosen1024/Java-Interview/blob/main/Redis/Redis.md">十分全面</a></p><p>文章的结构也基本是库森文章的简化。</p><p>先说明redis是什么、有什么优点、使用场景是什么</p><p>然后具体谈谈redis的一些特性 比如数据类型、持久化、事务、单线程</p><p>使用redis可能带来的问题：缓存淘汰策略、缓存一致性、缓存穿透、缓存雪崩</p><p>结构和模式：主从复制、哨兵模式、集群模式；</p><p>最后是Redis实际使用的优化</p></blockquote><h1 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1 Redis概述"></a>1 Redis概述</h1><h2 id="1-1-Redis是什么？它的优缺点？【重要】"><a href="#1-1-Redis是什么？它的优缺点？【重要】" class="headerlink" title="1.1 Redis是什么？它的优缺点？【重要】"></a>1.1 Redis是什么？它的优缺点？【重要】</h2><p>﻿Redis本质上是一个Key-Value键值对的非关系型数据库，整个数据库加载在内存中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。Redis最大的特点就是性能好，每秒可以处理超过 10万次读写操作。</p><p>优点：</p><ul><li>读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s</li><li>数据结构丰富，除了支持string类型外，还支持hash、set、zset、list等数据结构。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务， Redis的所有操作都是原子性的，一般通过MULTI和EXEC将指令打包实现事务。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>缺点：</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。（因为内存根本放不下海量数据嘛）</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换主机后可能导致数据不一致的问题，降低了系统的可用性。（缓存一致性问题）</li></ul><h2 id="1-2-Redis的常用场景有哪些"><a href="#1-2-Redis的常用场景有哪些" class="headerlink" title="1.2 Redis的常用场景有哪些?"></a>1.2 Redis的常用场景有哪些?</h2><p><strong>1、缓存（定期删除、淘汰策略是为缓存准备的）</strong></p><p>缓存现在几乎是所有中大型网站都在用的必杀技<strong>，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力</strong>。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><p><strong>2、分布式会话</strong></p><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建<strong>以Redis等内存数据库为中心的session服务</strong>，session不再由容器管理，而是由session服务及内存数据库管理。（就是说session放在redis中、也就是类似无状态登录嘛）</p><p><strong>3、分布式锁</strong></p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><p><strong>4、 社交网络</strong></p><p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，<strong>Redis提供的哈希、集合等数据结构</strong>能很方便的的实现这些功能。如在微博中的<strong>共同好友</strong>，通过Redis的set能够很方便得出。</p><p><strong>5、排行榜</strong></p><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的<strong>有序集合数据类</strong>构能实现各种复杂的排行榜应用。</p><h2 id="1-3-关系型数据库和非关系型数据库的区别【理解背】"><a href="#1-3-关系型数据库和非关系型数据库的区别【理解背】" class="headerlink" title="1.3 关系型数据库和非关系型数据库的区别【理解背】"></a>1.3 关系型数据库和非关系型数据库的区别【理解背】</h2><ul><li><p>关系型数据库：</p><ul><li>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</li><li>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</li><li>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</li></ul></li><li><p>非关系型数据库 not only SQL</p><ul><li>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</li><li>面向高性能并发读写的key-value数据库</li><li>面向可扩展性的分布式数据库</li></ul></li></ul><p>数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库</p><h1 id="2-Redis的数据结构、持久化、事务-和单线程"><a href="#2-Redis的数据结构、持久化、事务-和单线程" class="headerlink" title="2 Redis的数据结构、持久化、事务 和单线程"></a>2 Redis的数据结构、持久化、事务 和单线程</h1><blockquote><p>redis最基本的一些特性</p></blockquote><h2 id="2-1-Redis的数据结构【重要】"><a href="#2-1-Redis的数据结构【重要】" class="headerlink" title="2.1 Redis的数据结构【重要】"></a>2.1 Redis的数据结构【重要】</h2><p>有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中HyperLogLog、Bitmap的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。</p><p><strong>五种常用的数据类型</strong>【重要】：</p><p>1、String：String是最常用的一种数据类型，普通的key- value 存储都可以归为此类。其中Value既可以是数字也可以是字符串。使用场景：常规key-value缓存应用。常规计数: 微博数， 粉丝数。</p><p>2、Hash：Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值。（类似hashmap）</p><p>3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。(类似hashset)</p><p>4、List：List是一个有序可重复的集合，其遵循FIFO的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于最新回复这类的功能实现。(类似linkedlist)</p><p>5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。</p><p><strong>三种特殊的数据类型</strong>：</p><p>1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p><p>2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。场景：统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><p>3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。</p><h2 id="2-2-Redis-的持久化【重要】"><a href="#2-2-Redis-的持久化【重要】" class="headerlink" title="2.2 Redis 的持久化【重要】"></a>2.2 Redis 的持久化【重要】</h2><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化。</p><p>Redis 支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><ul><li><strong>快照：（数据可能丢失）</strong></li></ul><p>快照就是根据设置的时间间隔和更新次数来判断是否进行数据的备份，设置命令是save 900 1(就是指900秒内如果至少有一个key进行了修改，就进行持久化的操作)。快照的备份通过单独创建子进程来完成，备份过程中主进程不进行任何的IO操作，确保了极高的性能。适合于对大规模数据的恢复</p><p>快照的缺点是：1创建子进程会占用一定的内存空间；2 最后一次持久化之后的数据可能丢失</p><ul><li><strong>AOF:（修复速度慢）</strong></li></ul><p>AOF持久化是记录每一次修改redis数据的命令。AOF默认是关闭的，可以在配置文件中开启，一般有三个选项：每次修改都写入AOF文件、每秒一次写入AOF文件、由操作系统决定何时同步。AOF的实时性更好，但如果选择每次修改都写入时，可能会降低redis的性能；建议选择每秒同步一次，这样Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。</p><p>AOF的缺点是，AOF文件的大小远远大于 数据文件，AOF的修复速度也比数据文件慢！</p><h2 id="2-3-Redis-的事务【重要】"><a href="#2-3-Redis-的事务【重要】" class="headerlink" title="2.3 Redis 的事务【重要】"></a>2.3 Redis 的事务【重要】</h2><p>Redis事务的简单理解就是<strong>将多个命令打包、放入一个队列中、然后一起执行所有命令</strong>。因为某条命令执行失败不会影响其他命令，所以Redis的事务严格来说并不是原子性的。</p><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><ul><li>使用 <a href="https://redis.io/commands/multi"><code>MULTI</code></a>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec"><code>EXEC</code></a>命令将执行所有命令。</li><li>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</li><li><a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话(<strong>在本事务外被修改</strong>)，整个事务都不会执行，直接返回失败。</li></ul><p>Redis事务之所以不支持回滚（以实现原子性）是因为认为错误的指令应该在开发过程就发现，而不应该出现在生产环境中。因为不用支持回滚、Redis的设计可以保持简单和高效。Watch命令的监视功能类似于乐观锁，发现了key被其他事务修改之后，可以是队列中后面的命令失效。</p><h2 id="2-4-Redis单线程【略重要】"><a href="#2-4-Redis单线程【略重要】" class="headerlink" title="2.4 Redis单线程【略重要】"></a>2.4 Redis单线程【略重要】</h2><p><strong>1 Redis为何选择单线程？</strong>【重要】</p><blockquote><p>Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。</p></blockquote><p>在Redis 6.0以前，Redis的核心网络模型选择用单线程来实现。简单的原因就是大多数请求都是 I/O 密集型的，而不会是 CPU 密集型的。Redis的执行速度是非常快的，Redis真正的性能瓶颈常常在于网络 I/O，因此Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。（多路复用思想也存在于http2.0中）</p><p>主要的原因还包括：</p><ul><li><p>单线程避免过多的上下文切换开销</p></li><li><p>避免数据同步机制的开销</p></li><li><p>简单可维护</p></li></ul><p>总而言之，Redis选择单线程可以说是一种权衡的选择：在保证足够的性能的前提下，使用单线程保持代码的简单和可维护性。</p><p><strong>2 Redis6.0又支持多线程主要原因：</strong></p><ul><li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核（单线程浪费了cpu等待网络IO的时间）</li><li>多线程任务可以分摊 Redis 同步 IO 读写负荷</li></ul><p><strong>3  IO 多路复用机制</strong>【了解】</p><p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p><h1 id="3-Redis-缓存可能带来的问题及解决"><a href="#3-Redis-缓存可能带来的问题及解决" class="headerlink" title="3 Redis 缓存可能带来的问题及解决"></a>3 Redis 缓存可能带来的问题及解决</h1><blockquote><p>使用redis可能带来的问题：过期key删除、缓存淘汰策略、缓存一致性、缓存穿透、缓存雪崩。</p><p>1 使用缓存、缓存的容量是有限的，如果使缓存中始终存“热点的数据”，这是首先要考虑的。也就是放什么样的数据到缓存中、以及如何淘汰数据（淘汰策略）</p><p>2 缓存和数据库存在着一个同步的问题，如何保证缓存一致性（读写顺序！！）</p><p>3 某些极端的攻击，引发的缓存穿透、缓存雪崩问题应该如何解决</p></blockquote><h2 id="3-1-Redis过期键的删除策略"><a href="#3-1-Redis过期键的删除策略" class="headerlink" title="3.1 Redis过期键的删除策略"></a>3.1 Redis过期键的删除策略</h2><blockquote><p>通过expire或pexpire命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。</p></blockquote><p><strong>Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。</strong></p><p><strong>1、惰性删除</strong></p><p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><p>优点：对 CPU友好，只会在使用该键时才会进行过期检查</p><p>缺点：对内存不友好，不用的键就会一直存在内存中</p><p><strong>2、定期删除</strong></p><p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p><p>优点：对CPU和内存都友好</p><p>缺点：难以确定删除操作执行的时长和频率。可能出现过期了还没有被删除的问题。</p><h2 id="3-2-Redis缓存淘汰策略【略重要】"><a href="#3-2-Redis缓存淘汰策略【略重要】" class="headerlink" title="3.2 Redis缓存淘汰策略【略重要】"></a>3.2 Redis缓存淘汰策略【略重要】</h2><blockquote><p>设置了过期时间的数据由过期键的删除策略负责删除（也可以通过淘汰策略）</p><p>如果没有设置过期时间的数据（很多），通过淘汰策略来删除。当Redis的内存超过最大允许的内存之后，Redis会触发<strong>内存淘汰策略</strong>，删除一些不常用的数据</p></blockquote><p><strong>Redisv4.0前提供 6种数据淘汰策略</strong>：</p><ul><li>volatile-lru：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（<strong>这个是最常用的</strong>）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！【居然是默认】</li></ul><p><strong>Redisv4.0后增加以下两种</strong>：</p><ul><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ul><h2 id="3-3-缓存不一致问题及解决"><a href="#3-3-缓存不一致问题及解决" class="headerlink" title="3.3 缓存不一致问题及解决"></a>3.3 缓存不一致问题及解决</h2><blockquote><p>缓存不一致问题一般出现于要更新数据库的时候。处理缓存不一致问题主要有两种方案：</p><p>1 先删除缓存，后更新数据库</p><p>2 先更新数据库，后删除缓存</p><p>其他的方案诸如： 先更新数据库在更新缓存，并发会有脏数据进缓存。 先更新缓存在更新数据库，可能更缓存成功、更数据库失败照成不一致问题。</p></blockquote><p><strong>1 先删除缓存，后更新数据库</strong></p><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><blockquote><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ol><p>就是查询操作B可能将数据库中旧值更新到缓存中，照成缓存不一致</p></blockquote><p>解决办法就是<strong>“延时双删”</strong>，步骤如下（就是两次删除一次更新、更新后记得延时一下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）先淘汰缓存 </span><br><span class="line">（<span class="number">2</span>）再写数据库（这两步和原来一样）</span><br><span class="line">（<span class="number">3</span>）休眠<span class="number">1</span>秒，再次淘汰缓存</span><br></pre></td></tr></table></figure><p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求B结束后，写请求A可以删除读请求造成的缓存脏数据。</p><p><strong>2 先更新数据库，后删除缓存</strong></p><blockquote><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p></blockquote><p>解决办法是利用消息队列，确保消息操作能够可靠的被消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 请求 A 先对数据库进行更新操作</span><br><span class="line"><span class="number">2</span> 在对 Redis 进行删除操作的时候发现报错，删除失败</span><br><span class="line"><span class="number">3</span> 此时将Redis 的 key 作为消息体发送到消息队列中</span><br><span class="line"><span class="number">4</span> 系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</span><br></pre></td></tr></table></figure><h2 id="3-4-缓存穿透的问题及解决【重要】"><a href="#3-4-缓存穿透的问题及解决【重要】" class="headerlink" title="3.4 缓存穿透的问题及解决【重要】"></a>3.4 缓存穿透的问题及解决【重要】</h2><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212640.png" alt="image-20210707115232430"></p><blockquote><p>解决缓存穿透问题，最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p></blockquote><p>解决方法：除了基本的参数校验方法外，还有<strong>缓存无效key和布隆过滤器</strong></p><p><strong>1 缓存无效key</strong>（将无效的key缓存到redis中）</p><p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。这种方式可以解决请求的 key 变化不频繁的情况。（当key变化频繁时无法解决问题）</p><p><strong>2 布隆过滤器</strong>（就是多加一层布隆过滤器的判断，不在布隆过滤器中就直接返回null）</p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>布隆过滤器可能出现小概率的误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><blockquote><p>布隆过滤器的原理是根据哈希函数对是元素值进行计算，映射到数组中来判断是否存在。</p></blockquote><h2 id="3-5-缓存雪崩的问题及解决【重要】"><a href="#3-5-缓存雪崩的问题及解决【重要】" class="headerlink" title="3.5 缓存雪崩的问题及解决【重要】"></a>3.5 缓存雪崩的问题及解决【重要】</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong>可能导致宕机。</p><p><strong>缓存雪崩的原因</strong></p><ul><li>系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</li><li>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</li></ul><p><strong>缓存雪崩的解决办法：</strong></p><ul><li><p>针对 Redis 服务不可用的情况：</p><ul><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ul></li><li><p>针对热点缓存失效的情况：</p><ul><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ul></li></ul><h1 id="4-Redis的主从、哨兵、集群"><a href="#4-Redis的主从、哨兵、集群" class="headerlink" title="4 Redis的主从、哨兵、集群"></a>4 Redis的主从、哨兵、集群</h1><blockquote><p>Redis的应用模式比如主从复制、哨兵模式、redis集群。。感觉这部分比较难</p><p>主从复制原理？</p><p>被选举为master的标准？</p><p>集群是如何实现数据分布的?优点</p><p>集群的通信机制</p></blockquote><h2 id="4-1-主从复制架构"><a href="#4-1-主从复制架构" class="headerlink" title="4.1 主从复制架构"></a>4.1 主从复制架构</h2><p>Redis主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）。</p><p><strong>主从机的特点：</strong></p><ul><li><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动在从机中保存！</p></li><li><p>主机断开连接，从机依旧连接到主机的。主机后面如果回来了，从机依旧可以直接获取到该主机写的信息！</p></li><li><p>如果从机重启了（命令行来配置的主从的情况），就会变回主机（默认）！只要（重新设置）变为从机，立马就会从主机中获取值！</p><ul><li>只要是重新连接master，一次完全同步（全量复制）将被自动执行！</li></ul></li></ul><p><strong>复制原理：</strong></p><p>Slave 启动成功连接到 master 后会发送一个sync同步命令。Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li>全量复制：（全部复制）</li><li>增量复制：（复制更新的部分）</li></ul><p><strong>缺点：</strong></p><p><strong>如果主机因为故障断开了连接，我们只能手动配置主机、从机。</strong>升级为哨兵模式就是为了解决这个问题，实现自动配置主从！！</p><h2 id="4-2-哨兵模式架构"><a href="#4-2-哨兵模式架构" class="headerlink" title="4.2 哨兵模式架构"></a>4.2 哨兵模式架构</h2><blockquote><p>主机故障之后，自主配置新主机从机！！</p></blockquote><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵是一个独立的进程，作为进程，它会独立运行。</p><p>==其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。==</p><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ol><p><strong>缺点：</strong></p><ol><li>Redis 不好线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，实现起来相对复杂！</li></ol><h2 id="4-3-Redis集群架构（Redis-Cluster）"><a href="#4-3-Redis集群架构（Redis-Cluster）" class="headerlink" title="4.3 Redis集群架构（Redis Cluster）"></a>4.3 Redis集群架构（Redis Cluster）</h2><blockquote><p>哨兵模式虽然已经高可用了，但是备份太多相同的数据，是浪费内存的操作。</p><p> Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。（也能够缓解内存数据库不能存海量数据的缺点）</p></blockquote><p>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p><strong>优点：</strong></p><ul><li>无中心架构；</li><li>可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ul><p><strong>缺点（缺点也有很多）：</strong></p><ul><li>Client实现复杂</li><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li><li>Slave在集群中充当“冷备”，不能缓解读压力</li><li>Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。</li><li>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。</li><li>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。</li><li>不支持多数据库空间，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</li></ul><h2 id="4-4-几个常问的问题【重要】"><a href="#4-4-几个常问的问题【重要】" class="headerlink" title="4.4 几个常问的问题【重要】"></a>4.4 几个常问的问题【重要】</h2><p>1 Redis哨兵是怎么工作的？主观下线、客观下线 </p><ul><li>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。如果监测到某个Master回复时间超过指定的值，就认为这个Master宕机了，标记为<strong>主观下线</strong>的状态</li><li>其他Sentinel发送命令确认这个Master是否真的进入了宕机状态。如果有足够多的Sentinel认为这个Master确实主观下线了，那么Master会被标记为<strong>客观下线</strong> 。</li><li>足够多的Sentinel同意Master客观下线之后，就会相互沟通，从选举出一个从节点作为新的Master。其他从节点转移到这个新的主节点上来。</li></ul><p>2 新被选举为master的标准是什么？</p><ul><li><p>跟master断开连接的时长。 如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master.</p></li><li><p>slave优先级。 按照slave优先级进行排序，slave priority越低，优先级就越高</p></li><li><p>复制offset。 如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，优先级就越高</p></li><li><p>run id 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</p></li></ul><h1 id="5-Redis的其他问题（优化）"><a href="#5-Redis的其他问题（优化）" class="headerlink" title="5 Redis的其他问题（优化）"></a>5 Redis的其他问题（优化）</h1><p><strong>1 Redis如何做内存优化？</strong></p><ul><li><strong>控制key的数量</strong>。当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。</li><li><strong>缩减键值对象</strong>，降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。<ul><li>key长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li><li>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。</li></ul></li></ul><p><strong>2 如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？</strong></p><p>如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。</p><p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。</p><p>如果需要缓存1T+的数据，选择Redis cluster模式，每个主节点存一部分数据，假设一个master存32G，那只需要n*32G&gt;=1T，n个这样的master节点就可以支持1T+的海量数据的存储了。</p><blockquote><p>Redis单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个slave的数据和master的完全一样。假如master是10G那slave也只能存10G数据。所以数据量受单主的影响。 而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis官方给出的 Redis cluster 模式完美的解决了这个问题。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis系统的理解和介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Redis" scheme="https://wukang555.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://wukang555.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>vhr人力资源管理系统面经</title>
    <link href="https://wukang555.github.io/2021/08/02/%E9%9D%A2%E7%BB%8F_08_vhr%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94/"/>
    <id>https://wukang555.github.io/2021/08/02/%E9%9D%A2%E7%BB%8F_08_vhr%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94/</id>
    <published>2021-08-02T14:55:00.000Z</published>
    <updated>2022-05-17T12:19:13.256Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。</p><a id="more"></a><h2 id="1-介绍一下vhr人力资源管理系统"><a href="#1-介绍一下vhr人力资源管理系统" class="headerlink" title="1 介绍一下vhr人力资源管理系统"></a>1 介绍一下vhr人力资源管理系统</h2><p>vhr 是一个前后端分离的人力资源管理系统，包括人事管理、系统管理等模块，基于 Restful 风格开发后端接口、使用 Swagger 进行接口测试；</p><p>技术栈：Spring Boot、Spring Security、MyBatis、MySQL、Redis、RabbitMQ</p><ul><li>1、使用 Spring Security 基于角色的动态访问控制，实现用户认证和用户授权；即根据用户的角色赋予不同的操作权限和显示菜单。</li><li>2、将邮件服务划分为单独的模块、引入消息中间件 RabbitMQ，实现异步发送欢迎新员工的入职邮件；</li><li>3、实现前后端分离，后端不再处理页面跳转仅传递 JSON 字符串，实现了基于 JWT 的无状态登录；</li></ul><h2 id="2-vhr的数据库是怎么设计的？"><a href="#2-vhr的数据库是怎么设计的？" class="headerlink" title="2 vhr的数据库是怎么设计的？"></a>2 vhr的数据库是怎么设计的？</h2><p>面向的用户是公司的管理人员，然后实现了基于角色的动态动态访问控制，基本的就有管理人员的hr表（用户表）、role表（角色表）、menu表（菜单表），然后就是实现用户、角色和菜单之间连接关系的hr_role表（一对多的关系）、menu_role表（多对多的关系）。然后就是其他一些公司的employee表（员工表）、departmen表（部门表）、joblevel表（职称表）等。</p><ul><li>hr用户表，公司的管理人员也就是该系统的使用用户。。一个用户一般拥有一种或者多种角色</li><li>role角色表，不同的角色对用有不同的权限，比如人事专员只管人事、部门经理管理该部门的员工等</li><li>hr表和role表通过 一个hr_role表相联系，即指定一个用户具有哪几种角色</li><li>还有一个menu表，相当于是一个资源表，menu中的数据会以json返回给前端，然后vue动态更新。其中里面最重要的字段就是url、路径匹配规则，所有的请求会被拦截然后根据这个url去查询访问这个url需要什么角色的权限，然后看当前用户是否具备相应的角色。</li><li>menu_role表将menu和role表相联系，即指定某个url会对哪些角色可见（menu和role是多对多的关系）</li></ul><h2 id="3-RESTful风格，介绍一下"><a href="#3-RESTful风格，介绍一下" class="headerlink" title="3 RESTful风格，介绍一下"></a>3 RESTful风格，介绍一下</h2><h3 id="3-1-RESTful风格是什么？"><a href="#3-1-RESTful风格是什么？" class="headerlink" title="3.1 RESTful风格是什么？"></a>3.1 RESTful风格是什么？</h3><blockquote><p>URI统一资源标识符</p><p>URL是统一资源定位符</p></blockquote><p>REST(Representational State Transfer) 指 表现层状态转化。</p><ul><li><p>在web应用中，我们一般用<strong>URI统一资源标识符</strong>来表示一种资源</p></li><li><p>表现层指的是一个”资源“的具体表现形式，比如一个html文本、一个xml或者一个图片都是表现层</p></li><li><p>状态转换就是客户端通过http的几种请求方式（get\post\put\delete）对服务器进行访问，完成资源的状态转换</p><ul><li>GET 用来获取资源、POST 用来新建资源（也可以用于更新资源）、PUT 用来更新资源、DELETE 用来删除资源</li></ul></li></ul><p>REST的核心在于，当你设计一个系统的时候，资源是第一位的考虑，你首先从资源的角度进行系统的拆分、设计，而不是像以往一样以操作为角度来进行设计。</p><p>总的来说就是，RESTful定义了一种客户端和服务器交互的风格，使URL更简洁、更有层次感。</p><h3 id="3-2-RESTful的使用示例"><a href="#3-2-RESTful的使用示例" class="headerlink" title="3.2 RESTful的使用示例"></a>3.2 RESTful的使用示例</h3><p>SpringMVC 对 RESTful 提供了非常全面的支持，主要有如下几个注解：</p><ul><li>@PathVariable注解：提取请求地址中的参数</li><li>@PostMapping注解：映射一个POST请求</li><li>@GetMapping注解：映射一个GET请求</li><li>@PutMapping注解：映射一个PUT请求</li><li>@DeleteMapping注解：映射一个DELETE请求</li></ul><p>1 使用@PathVariable 注解可以将Controller下方法的参数<strong>绑定到URL的模板变量上</strong>，使url的访问更灵活。反之如果不使用的话，就需要在URL手动用=赋值参数</p><p>2 使用不同的注解组合（不同的请求方式）可以实现 相同的URL实现不同的效果！！使显示的url更简洁和有层次感</p><h3 id="3-3-RESTful风格的设计原则"><a href="#3-3-RESTful风格的设计原则" class="headerlink" title="3.3 RESTful风格的设计原则"></a>3.3 RESTful风格的设计原则</h3><ul><li><p>URL尽量使用名词复数, 不使用动词</p></li><li><p>访问同一个URL地址, 采用不同的请求方式, 代表执行不同的操作(get获取, post新增等)</p></li><li><p>服务器返回的响应格式数据，尽量通过XML JSON进行数据传递；</p></li><li><p>无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的；</p></li></ul><h2 id="4-前后端分离时，前后端是如何交互的"><a href="#4-前后端分离时，前后端是如何交互的" class="headerlink" title="4 前后端分离时，前后端是如何交互的"></a>4 前后端分离时，前后端是如何交互的</h2><h3 id="4-1-后台如何处理前端传递过来信息，并返回数据的过程"><a href="#4-1-后台如何处理前端传递过来信息，并返回数据的过程" class="headerlink" title="4.1 后台如何处理前端传递过来信息，并返回数据的过程"></a>4.1 后台如何处理前端传递过来信息，并返回数据的过程</h3><blockquote><p>其实就是问springMVC的原理和执行流程</p></blockquote><p>用户发出请求后，前端传过来的实际上是一个url，后台接受请求，返回数据给前端。接受请求并返回数据其实就是springMVC的整个处理流程。</p><p>SpringMVC的执行过程是围绕着前置（调度）控制器<strong>DispatcherServlet</strong>的调度来设计的。</p><ul><li>第一步，DispatcherServlet拦截请求，并调用 处理器映射HandlerMapping 和 解析控制器映射HandlerExecution。<ul><li>目的是根据url查找对应控制器，找到是哪个Controller应该处理这个请求，找到之后返回给DispatcherServlet</li></ul></li><li>第二步，DispatcherServlet调用HandlerAdapter处理器适配器，并让他调用那个Controller。<ul><li>接下来就是我们编写的代码逻辑，后端Controller调Service、Service调Mapper接口，mapper.xml做持久层的增删改查，得到一个JSON对象传递给前端</li><li>前端解析JSON对自己的js对象，然后得到视图和模型，通过HandlerAdapter处理器适配器传递给DispatcherServlet</li></ul></li><li>第三步，DispatcherServlet调用视图解析器(ViewResolver)来解析逻辑视图，最后得到视图，再呈现给用户！！</li></ul><p>总结：简单来讲的话就是三步：1通过url找到对应的Controller、然后2调用执行持久化层的查询获得逻辑视图或者model，最后3解析视图、并呈现给用户。</p><h3 id="4-2-后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？"><a href="#4-2-后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？" class="headerlink" title="4.2 后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？"></a>4.2 后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？</h3><blockquote><p>做一个删除操作——返回的是RespBean对象</p><p>查询所有员工 返回的是一个RespPageBean对象</p><p>查询部门的时候返回的是一个list集合 List<Department></Department></p><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中</p></blockquote><p>其实就是SpringBoot框架的功能，使用了@ResponseBody注解，所有的java对象都转换为了JSON格式写入Http response body中。</p><p>所以我后端不用管其他，你要集合我返回集合、要msg我返回msg、要page返回page，反正最后都变成JSON给前端了。</p><h2 id="5-RBAC基于角色的权限访问控制"><a href="#5-RBAC基于角色的权限访问控制" class="headerlink" title="5 RBAC基于角色的权限访问控制"></a>5 RBAC基于角色的权限访问控制</h2><h3 id="5-1-基于角色的动态访问控制逻辑"><a href="#5-1-基于角色的动态访问控制逻辑" class="headerlink" title="5.1 基于角色的动态访问控制逻辑"></a>5.1 基于角色的动态访问控制逻辑</h3><p>使用springScurity完成用户认证和用户授权。@EnableWebSecurity //开启WebSecurity模式，然后编写一个SecurityConfig类继承WebSecurityConfigurerAdapter，重写里面的configure方法给用户设置角色和权限。</p><p>因为是前后端分离的项目，基本的登录逻辑就是：用户(hr表)登录成功之后，可以通过hr_role表查询到用户的角色，再根据用户角色去（meau_role中）查出来用户可以操作的菜单（资源），然后把这些可以操作的资源，组织成一个 JSON 数据，返回给前端，前端再根据这个 JSON 渲染出相应的菜单。</p><p>这样就可以根据数据库中的表信息，动态的配置资源-角色以及用户-角色之间的关系，进而调整用户可以操作的资源(菜单)。</p><h3 id="5-2-有状态登录和无状态登录"><a href="#5-2-有状态登录和无状态登录" class="headerlink" title="5.2 有状态登录和无状态登录"></a>5.2 有状态登录和无状态登录</h3><p><strong>传统的有状态登录Session</strong></p><ul><li><p>服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理。典型的就是Session。</p></li><li><p>例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li><p>服务端保存大量数据，增加服务端压力</p></li><li><p>服务端保存用户状态，不支持集群化部署</p></li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212621.png" alt="img" style="zoom:80%;"><p><strong>RESTful 风格的无状态服务</strong></p><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：<strong>服务的无状态性</strong>，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>好处：</p><ul><li><p>多次请求不需要必须访问到同一台服务器，</p></li><li><p>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</p></li><li><p>减小服务端存储压力</p></li></ul><p><strong>使用JWT实现无状态服务</strong> </p><ul><li>首先客户端发送账户名/密码到服务端进行认证登录 </li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token   Json web token (JWT)</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212624.png" alt="jwt" style="zoom:80%;"><h3 id="5-3-Token如何保存状态"><a href="#5-3-Token如何保存状态" class="headerlink" title="5.3 Token如何保存状态"></a>5.3 Token如何保存状态</h3><p><strong>如何处理注销账户之后token还有效的问题？</strong></p><blockquote><p>相关的有：退出登录、修改密码、修改权限、注销账户之后，token还有效</p><p>Redis用来储存token,账户注销或者退出登录之后就删除Redis中的token</p></blockquote><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。</p><p>token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p><ul><li>解决方案一：<strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li></ul><p><strong>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</strong></p><blockquote><p>设置token的有效期为30分钟，服务器每次校验时，检查token的有效期，如果快过期了，就重新生成一个token给客户端。客户端请求之前先检查更新自己的token</p></blockquote><p>先来看看在 Session 认证中一般的做法：假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期被延长30分钟。</p><ol><li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li><li><strong>每次请求都返回新 token</strong> :这种方案的的思路很简单，但是，很明显，开销会比较大。</li><li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li><strong>用户登录返回两个 token</strong> ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1⃣️需要客户端来配合；2⃣️用户注销的时候需要同时保证两个 token 都无效；3⃣️重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li></ol><h3 id="5-4-JWT的格式？？"><a href="#5-4-JWT的格式？？" class="headerlink" title="==5.4 JWT的格式？？=="></a>==5.4 JWT的格式？？==</h3><h2 id="6-邮件服务原理"><a href="#6-邮件服务原理" class="headerlink" title="6 邮件服务原理"></a>6 邮件服务原理</h2><blockquote><p>vhrserver相当于只是发送了一个消息给中间件</p><p>然后真正发送邮件的功能都在mailserver中，JavaMailSender接口</p></blockquote><p>将邮件服务划分为单独的模块、引入消息中间件 RabbitMQ，实现异步发送欢迎新员工的入职邮件；即当管理人员比如hr在界面上操作新增了一名员工到数据库中，就会自动的向中间件RabbitMQ发送一条消息，然后mailServer会自动异步的订阅消息，向新入职的员工发送一封入职邮件，里面包含姓名、职位、职称和部门等信息。</p><p>vhrServer中的业务逻辑：</p><ul><li>新增员工的命令返回值为1时，进入邮件发送的代码中</li><li>指定消息的唯一UUID,获取一个新的employee对象用于传递</li><li>一个MailSendLog类用来记录消息的发送日志，里面实例变量有消息的id、员工id、投递状态、投递规则key exchage等</li><li>配置RabbitMQ的配置文件，声明队列、交换机、绑定交换机等</li></ul><p>mailServer中的业务逻辑：</p><ul><li>配置RabbitMQ的配置文件，然后消费消息就ok了</li><li>消息确认机制改为手动，只要消费成功一条消息，就将消息id记录在Redis上，避免消息的重复消费</li></ul><h2 id="7-RabbitMQ如何保证消息的可靠性"><a href="#7-RabbitMQ如何保证消息的可靠性" class="headerlink" title="7 RabbitMQ如何保证消息的可靠性"></a>7 RabbitMQ如何保证消息的可靠性</h2><h3 id="1-保证我们的消息能够成功到达队列"><a href="#1-保证我们的消息能够成功到达队列" class="headerlink" title="1 保证我们的消息能够成功到达队列"></a>1 保证我们的消息能够成功到达队列</h3><ul><li><p>消息传递、要经过三个流程：</p><ul><li><p>1 消息到达交换机 </p><ul><li>第一个流程可能由于网络的波动、延迟等原因，消息没有准确达到交换机</li></ul></li><li><p>2 交换机把消息路由到队列中</p><ul><li>第二个流程可能routing key错误等原因，消息没有准确到达队列</li></ul></li><li><p>3 消息持久化写入日志</p><ul><li>第三个流程可能在消息写入日志的过程中，broker crash掉了，重启后消息丢失</li></ul></li></ul></li><li><p>解决方案一：事务控制，但大幅度降低了效率不推荐使用</p></li><li><p>解决方案二：发送者确认模式：即消息发送失败回调、路由失败回调</p><ul><li><p>1 通过实现ConfirmCallBack接口，消息发送到交换器Exchange后触发回调</p></li><li><p>2 通过实现ReturnCallback接口，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）</p></li><li><p>总结：</p><ul><li><p>如果成功入列，单纯给客户端发送”ack”信号</p></li><li><p>如果消息无法路由到队列则是发送 “消息” + “ack”,且”消息”比ack信号先到</p></li></ul></li></ul></li></ul><h3 id="2-rabbitmq的持久化（解决消息到达队列之后的可靠性）"><a href="#2-rabbitmq的持久化（解决消息到达队列之后的可靠性）" class="headerlink" title="2 rabbitmq的持久化（解决消息到达队列之后的可靠性）"></a>2 rabbitmq的持久化（解决消息到达队列之后的可靠性）</h3><ul><li><p>三个持久化：交换机持久化、队列持久化、消息持久化</p></li><li><p>持久化的消息在进入持久化队列之后会写入到rabbitmq的持久性日志文件中，消息被消费掉后，会把持久性日志文件中该消息标记为等待垃圾收集</p></li><li><p>三个持久化很大程度上已经解决了rabbitmq这一端因为宕机而导致消息丢失的问题。。。如果在broker在把消息写入日志文件的时候崩掉了（极端情况），这时可以借助mirror queue来处理</p></li></ul><h3 id="3-确保一条消息只消费一次"><a href="#3-确保一条消息只消费一次" class="headerlink" title="3 确保一条消息只消费一次"></a>3 确保一条消息只消费一次</h3><ul><li><p>首先将 RabbitMQ 的消息自动确认机制改为手动确认，然后每当有一条消息消费成功了，就把该消息的唯一 ID 记录在 Redis 上，然后每次收到消息时，都先去 Redis 上查看是否有该消息的 ID，如果有，表示该消息已经消费过了，不再处理，否则再去处理。</p></li><li><p>这里使用的是Token的思想，核心就是每个操作都有一个唯一凭证 token，一旦执行成功，对于重复的请求，总是返回同一个结果。</p></li><li><p>每一个邮件消息都有唯一的uuid，作为唯一的凭证</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="后端开发" scheme="https://wukang555.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="项目" scheme="https://wukang555.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架面经</title>
    <link href="https://wukang555.github.io/2021/08/01/%E9%9D%A2%E7%BB%8F_07_Spring%E6%A1%86%E6%9E%B6%20/"/>
    <id>https://wukang555.github.io/2021/08/01/%E9%9D%A2%E7%BB%8F_07_Spring%E6%A1%86%E6%9E%B6%20/</id>
    <published>2021-08-01T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。</p><a id="more"></a><h1 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h1><h2 id="1-1-Mybatis的介绍和运行原理"><a href="#1-1-Mybatis的介绍和运行原理" class="headerlink" title="1.1 Mybatis的介绍和运行原理"></a>1.1 Mybatis的介绍和运行原理</h2><blockquote><p>Mybatis介绍，Mybatis的映射原理、Mybatis的工作流程、Mybatis里类的生命周期</p></blockquote><h3 id="1-1-1-什么是Mybatis、Mybatis的好处？"><a href="#1-1-1-什么是Mybatis、Mybatis的好处？" class="headerlink" title="1.1.1 什么是Mybatis、Mybatis的好处？"></a>1.1.1 什么是Mybatis、Mybatis的好处？</h3><p><strong>Mybatis的定义：</strong></p><ul><li>MyBatis 是一款持久层框架。一般就是写一个抽象的mapper接口，然后用xml（或者注解的方式）去实现该接口写SQL语句，实现了SQL与业务代码的分离。但一般注解方式只支持一些简单的SQL语句。</li></ul><p><strong>Mybatis的好处：</strong></p><ul><li>1 最重要的就是用xml实现接口来写SQL语句，实现了SQL与业务代码的分离</li><li>2 mybatis配置了数据库的连接，无需程序员配置JDBC加载驱动、创建连接等繁杂的过程</li><li>3 还有比较重要的就是：自动映射功能，Mybatis自动将Java对象映射至sql语句、也能将sql的执行结果映射至java对象</li></ul><h3 id="1-1-2-XML映射文件实现mapper接口的工作原理"><a href="#1-1-2-XML映射文件实现mapper接口的工作原理" class="headerlink" title="1.1.2 XML映射文件实现mapper接口的工作原理"></a>1.1.2 XML映射文件实现mapper接口的工作原理</h3><blockquote><p>接口如何找到xml文件、如何定位到SQL语句</p><p>比如我写一个mapper.java的接口（里面有一个findById(int id)的方法），在mapper.xml里面写了对应的SQL语句</p></blockquote><p><strong>mapper接口的工作原理? 动态代理：</strong></p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行该接口方法对应的 sql语句，然后将 sql 执行结果返回。</p><p>需要设置：</p><ul><li>1 mappr.xml映射文件中的 namespace 的值 需要与mapper接口的全限名一致</li><li>2 mappr.xml映射文件中的SQL语句的id值，需要与 接口的方法名一致。接口方法内的参数，就是传递给sql的参数</li></ul><p>所以，虽然<code>Mapper.java</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>也即是SQL语句。实现接口的方式是动态代理。</p><p>还有两个小问题：id值必须唯一么？ mapper接口中的方法可不可以重载？</p><p><strong>id值必须唯一么？</strong></p><ul><li>同一个XML映射文件，的id必须唯一</li><li>不同XML映射文件，如果配置了namespace ，则id值可以重复，因为namespace+id是作为寻找SQL语句的key使用的</li></ul><p><strong>mapper接口中的方法可不可以重载？</strong></p><ul><li>mapper.java 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。</li><li>因为只有一个ID，所以可以用动态SQL分别处理两个重载的方法！！</li></ul><h3 id="1-1-3-Mybatis内部的工作流程"><a href="#1-1-3-Mybatis内部的工作流程" class="headerlink" title="1.1.3 Mybatis内部的工作流程"></a>1.1.3 Mybatis内部的工作流程</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212551.jpg" alt="20200225164530119"></p><p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）加载映射文件（就是我们写的SQL语句）。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句。一个mybatis-config.xml 配置文件可以加载多个映射文件。</p><p>3）构造会话工厂SqlSessionFactory</p><p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）MappedStatement 对象（处理对象的映射关系，参数映射和结果映射）：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p><p>7）执行数据库的命令。</p><h3 id="1-1-4-Mybatis内部对象的生命周期和作用域"><a href="#1-1-4-Mybatis内部对象的生命周期和作用域" class="headerlink" title="1.1.4 Mybatis内部对象的生命周期和作用域"></a>1.1.4 Mybatis内部对象的生命周期和作用域</h3><blockquote><p>这里指的是SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession、mapper接口的作用域</p></blockquote><p><strong>SqlSessionFactoryBuilder：</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory：</strong></p><ul><li><p>类似数据库连接池</p></li><li><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong> </p></li><li><p>因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的仅创建一个SqlSessionFactory 的单例对象</p></li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求！SqlSession就相当于一个数据库连接，你可以在一个事务里面执行多条SQL,然后通过它的commit、rollback等方法，提交或者回滚事务。所以它应该存活在一个业务请求中</li><li>SqlSession 的实例的最佳的作用域是请求或方法作用域。</li><li>处理完整个请求之后需要赶紧关闭，否则资源被占用！</li></ul><h2 id="1-2-Mybatis的特色功能"><a href="#1-2-Mybatis的特色功能" class="headerlink" title="1.2 Mybatis的特色功能"></a>1.2 Mybatis的特色功能</h2><blockquote><p>最重要的是参数映射和结果集映射、这里还介绍一些不同的执行器和批量update的操作</p></blockquote><h3 id="1-2-1-Mybatis的执行器Executor"><a href="#1-2-1-Mybatis的执行器Executor" class="headerlink" title="1.2.1 Mybatis的执行器Executor"></a>1.2.1 Mybatis的执行器Executor</h3><blockquote><p>Executor的作用范围：Executor 严格限制在 SqlSession 生命周期范围内。</p><p>指定Executor的方式：</p><p>1 在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，</p><p>2 手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p></blockquote><p>答：MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p><p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><h3 id="1-2-2-扩展Mybatis的批量update操作"><a href="#1-2-2-扩展Mybatis的批量update操作" class="headerlink" title="1.2.2 扩展Mybatis的批量update操作"></a>1.2.2 扩展Mybatis的批量update操作</h3><blockquote><p>有人做过了两种实现对比<a href="https://blog.csdn.net/lixiaolian123/article/details/110112030">批量插入对比</a></p></blockquote><p>1 foreach方式插入：sql语句里面写循环代码</p><ul><li>mysql默认接受sql的大小是 1M，当使用foreach同时插入1w行左右时会因为sql长度超过mysql的限制而无法执行</li></ul><p>2  BATCH模式插入：直接在java代码中写循环调用插入的接口</p><ul><li>参考文章显示使用BatchExecutor执行器的batch模式没有foreach快（作者很不解）</li></ul><h3 id="1-2-3-Mybatis自动映射功能：参数映射和结果集映射"><a href="#1-2-3-Mybatis自动映射功能：参数映射和结果集映射" class="headerlink" title="1.2.3 Mybatis自动映射功能：参数映射和结果集映射"></a>1.2.3 Mybatis自动映射功能：参数映射和结果集映射</h3><p>参数映射（万能的map）</p><ul><li><p>Map传递参数，直接在sql中取出key即可！    【parameterType=”map”】#{userid},#{passWord}</p></li><li><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】#{name}</p></li></ul><p>结果集映射resultMap</p><ul><li>可以在UserMapper.xml中单独写一个结果集的映射，其他sql语句的返回值的类型可以指定为该结果集</li></ul><h2 id="1-3-Mybatis中的SQL语句和缓存"><a href="#1-3-Mybatis中的SQL语句和缓存" class="headerlink" title="1.3 Mybatis中的SQL语句和缓存"></a>1.3 Mybatis中的SQL语句和缓存</h2><h3 id="1-Mybatis-的-XML-文件有哪些标签属性？"><a href="#1-Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="1 Mybatis 的 XML 文件有哪些标签属性？"></a>1 Mybatis 的 XML 文件有哪些标签属性？</h3><ul><li><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p></li><li><p><code>parameterType</code> 属性表示参数的数据类型，<code>resultType</code> 表示返回的结果类型</p></li><li><p>还有动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等</p></li></ul><h3 id="2-SQL分页的三种实现方式"><a href="#2-SQL分页的三种实现方式" class="headerlink" title="2 SQL分页的三种实现方式"></a>2 SQL分页的三种实现方式</h3><ul><li><p>1  在sql语句层实现，使用Limit分页</p></li><li><p>2 使用分页插件 PageHelper</p></li><li><p>3 在java代码层实现，使用RowBounds类分页</p><ul><li>使用RowBounds类分页是一种逻辑分页查询，一次性查出很多的数据，然后在查询结果中进行分页，明显的缺点就是消耗内存，存在内存溢出的风险</li></ul></li></ul><h3 id="3-和-区别"><a href="#3-和-区别" class="headerlink" title="3 #{} 和 ${} 区别"></a>3 #{} 和 ${} 区别</h3><ul><li><p>MyBatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ?，预编译 SQL，通过set()方法进行参数赋值。使用 #{} 可以有效地防止 SQL 注入。（能用尽用）</p></li><li><p>在处理 ${} 时，会直接把${} 替换为参数值，存在 SQL 注入的风险</p></li><li><p>${}一般用入传入数据库对象，比如数据库表名；还有使用动态参数的时候，不支持使用#{}，所以只能用${}</p></li></ul><h3 id="4-mybatis的两级缓存的机制"><a href="#4-mybatis的两级缓存的机制" class="headerlink" title="4 mybatis的两级缓存的机制"></a>4 mybatis的两级缓存的机制</h3><p>MyBatis默认定义了两级缓存：<strong>一级缓存</strong>、<strong>二级缓存</strong>和<strong>可自定义的二级缓存</strong></p><p><strong>一级缓存：</strong></p><ul><li><p><strong>默认开启一级缓存。SqlSession级别的缓存,存在于一次会话之间</strong></p></li><li><p>所有 select 语句的结果将会被缓存</p></li><li><p>执行insert、update 和 delete 语句会刷新缓存</p></li><li><p>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存（默认）。</p></li></ul><p><strong>二级缓存:</strong></p><ul><li>基于namespace级别的缓存，一个命名空间Mapper，对应一个二级缓存；（需要手动打开）</li><li>如果当前会话关闭了，这个会话对应的一级缓存就失效了；但是如果我们仍需要这个缓存数据，会话关闭时，我们将一级缓存中的数据被保存到二级缓存中；</li></ul><p><strong>缓存查找原理：</strong></p><p>查数据时，先看二级缓存中有没有，再看一级缓存中有没有，都没有再查询数据库。</p><h1 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2 Spring"></a>2 Spring</h1><blockquote><p>什么是Spring? Spring的组成\不要</p><p>IOC 控制翻转、AOP 依赖注入   代理模式</p><p>Bean  Bean 的作用域  自动装配 </p><p>spring事务</p></blockquote><h2 id="2-1-什么是Spring"><a href="#2-1-什么是Spring" class="headerlink" title="2.1 什么是Spring?"></a>2.1 什么是Spring?</h2><p>Spring是一个具有控制反转(IoC)和面向切面(AOP)特点的容器（框架），旨在提高开发人员的开发效率以及系统的可维护性。</p><p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。Spring 最核心的思想就是不重新造轮子，开箱即用！</p><p>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态得以流行的一个杀手级的应用框架。</p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器(Spring Core)之上，其他分别有Spring 上下文(Spring Context)、Spring AOP、Spring DAO、Spring ORM、Spring Web 模块、Spring MVC 框架</p><h2 id="2-2-IOC-和-AOP"><a href="#2-2-IOC-和-AOP" class="headerlink" title="2.2 IOC  和 AOP"></a>2.2 IOC  和 AOP</h2><h3 id="1-IOC是什么"><a href="#1-IOC是什么" class="headerlink" title="1 IOC是什么"></a>1 IOC是什么</h3><p>控制反转(IoC)：一个对象的创建和管理不再由对象本身控制，而是将这个对象注入Ioc容器中，由spring 来管理对象的创建和初始化。</p><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法</strong>。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系 全在编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方也就是Spring容器。</p><p>将对象注入spring容器中的方式也很简单，在xml配置文件中写一个<bean>标签就好了。取用的时候用getBean()方法可以直接获得该注入的对象。除了使用XML配置，springboot中支持基于注解的配置更为方便和流行。</bean></p><p>DI(依赖注入)有三种实现方式：1构造方法、2set方式、3注解方式</p><h3 id="2-AOP是什么"><a href="#2-AOP是什么" class="headerlink" title="2 AOP是什么"></a>2 AOP是什么</h3><p>AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间<strong>动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>比如将共同调用的业务逻辑（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低耦合性。</p><h3 id="3-静态代理和动态代理"><a href="#3-静态代理和动态代理" class="headerlink" title="3 静态代理和动态代理"></a>3 静态代理和动态代理</h3><p><strong>代理模式几个组成部分</strong></p><ul><li>抽象角色： 一般会使用一个接口或者抽象类来实现（比如出<strong>租房子这件事</strong>）</li><li>真实角色：被代理的角色（这里指<strong>房东</strong>实现出租房子的接口）</li><li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作（这里指<strong>中介</strong>、帮房东出租房子，也要实现出租房子的接口、但有自己的一些其他方法）</li><li>客户：访问代理对象的人 （这里表示<strong>要租房子的人</strong>）</li></ul><p><strong>代理模式的好处：</strong></p><ul><li><p>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</p></li><li><p>公共业务交给代理角色去实现，实现业务的分工</p></li><li><p>公共业务发生扩展时，方便集中管理</p></li></ul><p><strong>静态代理：</strong></p><p>有一个真实角色就要对应写一个代理角色，代码量翻倍、效率较低</p><p><strong>动态代理：</strong></p><p>和静态代理最大的区别：动态代理的代理类是动态生成的，不是我们直接写好的</p><h2 id="2-3-Spring-bean"><a href="#2-3-Spring-bean" class="headerlink" title="2.3 Spring bean"></a>2.3 Spring bean</h2><p>bean 就是指的就是那些被 IoC 容器所管理的对象，被Ioc托管的对象都叫bean。</p><h3 id="1-bean的作用域"><a href="#1-bean的作用域" class="headerlink" title="1 bean的作用域"></a>1 bean的作用域</h3><ul><li><p>单例模式singleton </p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li></ul></li><li><p>原型模式prototype </p><ul><li> 每次请求都会创建一个新的 bean 实例。</li></ul></li><li><p><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p></li><li><p><strong>session</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p></li><li><p><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p></li></ul><h3 id="2-单例的线程安全"><a href="#2-单例的线程安全" class="headerlink" title="2 单例的线程安全"></a>2 单例的线程安全</h3><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><ul><li><p>常见的有两种解决办法：</p><ul><li><p>在 bean 中尽量避免定义可变的成员变量。</p></li><li><p>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p></li></ul></li></ul><h3 id="3-spring的自动装配原理"><a href="#3-spring的自动装配原理" class="headerlink" title="3 spring的自动装配原理"></a>3 spring的自动装配原理</h3><p>Bean 的自动装配指Spring会在上下文中自动寻找，并自动给bean装备属性。简单来讲，给一个复杂对象赋值属性的时候，如果要调用容器中已经存在的对象的话、spring会帮我们自动装配调用。一般来说有两种自动装配的方式ByName 和 ByType</p><ul><li><p>byNmae 会自动在容器上下文中查找和自己对象set方法后面的值对应的id</p></li><li><p>byType 会自动在容器上下文中查找和自己对象属性类型相同的bean</p></li></ul><p>@Autowired注解：自动装配，默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</p><p>@Resource 注解：自动装配，默认通过byname的方式实现，如果找不到名字，则通过byType实现</p><h2 id="2-4-Spring-事务（bd）"><a href="#2-4-Spring-事务（bd）" class="headerlink" title="2.4 Spring 事务（bd）"></a>2.4 Spring 事务（bd）</h2><h3 id="1-Spring-事务实现方式有哪些？"><a href="#1-Spring-事务实现方式有哪些？" class="headerlink" title="1 Spring 事务实现方式有哪些？"></a>1 Spring 事务实现方式有哪些？</h3><p>Spring支持编程式事务管理和声明式的事务管理。</p><p><strong>编程式事务管理：</strong></p><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><p><strong>声明式事务管理（更好用）：</strong></p><ul><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务 管理。</li></ul><h3 id="2-spring事务传播特性"><a href="#2-spring事务传播特性" class="headerlink" title="2 spring事务传播特性"></a>2 spring事务传播特性</h3><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这 个事务中，这是最常见的选择。 <strong>（默认）</strong></li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 </li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 </li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 </li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 </li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与</li></ul><p>需要手动实现：在配置文件中声明事务的传播特性（比如REQUIRED），然后以AOP的方式实现事务的织入</p><blockquote><p>编写Spring的辅助配置文件spring-dao.xml；在配置声明式事务，并结合AOP实现事务的织入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务通知；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给那些方法配置事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的传播特性：new  propagation= --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-SpringMVC"><a href="#3-SpringMVC" class="headerlink" title="3 SpringMVC"></a>3 SpringMVC</h1><blockquote><ul><li>springMVC</li></ul><p>MVC三层架构</p><p>SprincgMVC执行原理</p><p>拦截器、文件上传下载？</p></blockquote><p>3.1 什么是SpringMVC？</p><p>Spring MVC是一个基于Java的实现了MVC模式的一个的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><p>3.2 SprincgMVC执行原理</p><ul><li><p>SpringMVC的执行过程是围绕着前置（调度）控制器DispatcherServlet的调度来设计的。</p><ul><li><p>第一步，DispatcherServlet拦截请求，并调用 处理器映射HandlerMapping 和 解析控制器映射HandlerExecution。</p><ul><li>目的是根据url查找对应控制器，找到是哪个Controller应该处理这个请求，找到之后返回给DispatcherServlet</li></ul></li><li><p>第二步，DispatcherServlet调用HandlerAdapter处理器适配器，并让他调用那个Controller。</p><ul><li><p>接下来就是我们编写的代码逻辑，后端Controller调Service、Service调Mapper接口，mapper.xml做持久层的增删改查，得到一个JSON对象传递给前端</p></li><li><p>前端解析JSON为自己的js对象，然后得到视图和模型，通过HandlerAdapter处理器适配器传递给DispatcherServlet</p></li></ul></li><li><p>第三步，DispatcherServlet调用视图解析器(ViewResolver)来解析逻辑视图，最后得到视图，再呈现给用户！！</p></li></ul></li><li><p>总结：简单来讲的话就是三步：1通过url找到对应的Controller、然后2调用执行持久化层的查询获得逻辑视图或者model，最后3解析视图、并呈现给用户。</p></li></ul><p>3.3 SpringMVC常用的注解有哪些</p><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。(一般与@Controller标识控制器组合，成为@RestController使用，)</p><h1 id="4-Springboot"><a href="#4-Springboot" class="headerlink" title="4 Springboot"></a>4 Springboot</h1><h2 id="4-1-什么是Springboot"><a href="#4-1-什么是Springboot" class="headerlink" title="4.1 什么是Springboot?"></a>4.1 什么是Springboot?</h2><p>Spring Boot 主要是简化了使用 Spring 的开发难度，简省了繁重的配置，提供了各种启动器，是开发者能快速上手。约定大于配置。</p><h2 id="4-2-springboot常用注解"><a href="#4-2-springboot常用注解" class="headerlink" title="4.2 springboot常用注解"></a>4.2 springboot常用注解</h2><p><strong>1 @SpringBootApplication：</strong></p><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><p><strong>2 Spring Bean 相关</strong></p><ul><li><p>@Autowired 自动装配</p><ul><li>自动导入对象到Bean中，被注入进的类同样要被 Spring 容器管理</li><li>默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</li></ul></li><li><p>几种声明实体类被Spring管理成为bean对象的注解</p><ul><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。一般pojo层</li></ul></li><li><p>@RestController</p><ul><li><code>@RestController</code>注解是<code>@Controller和</code>@<code>ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值以JSON的格式直接填入 HTTP 响应体中,是 REST 风格的控制器。</li></ul></li><li><p>@Scope()设置作用域的注解</p><ul><li>@Scope(“singleton”) //表示单例模式的注解</li><li>@Scope(“prototype”) //表示原型模式的注解</li></ul></li><li><p>@Configuration 声明配置类</p></li></ul><p><strong>3 http请求和前后端传值</strong></p><ul><li>四种http请求<ul><li>@GetMapping(“users”)</li><li>@PostMapping(“users”)</li><li>@PutMapping(“users”)</li><li>@DeleteMapping(“users”)</li><li>@PatchMapping(“/profile”) 更新数据</li></ul></li><li>`获取路径参数、获取查询参数<ul><li><code>@PathVariable</code>用于获取路径参数</li><li><code>@RequestParam</code>用于获取查询参数。</li></ul></li></ul><p><strong>4 读取配置信息</strong></p><p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</p><ul><li><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p></li><li><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p></li></ul><h1 id="5-RabbitMQ"><a href="#5-RabbitMQ" class="headerlink" title="5 RabbitMQ"></a>5 RabbitMQ</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Spring" scheme="https://wukang555.github.io/tags/Spring/"/>
    
    <category term="后端开发" scheme="https://wukang555.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://wukang555.github.io/2021/07/30/%E9%9D%A2%E7%BB%8F_06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20/"/>
    <id>https://wukang555.github.io/2021/07/30/%E9%9D%A2%E7%BB%8F_06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20/</id>
    <published>2021-07-30T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:36.412Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式。设计模式的原则和集中基本的设计模式。</p><a id="more"></a><h1 id="1-设计模式及原则"><a href="#1-设计模式及原则" class="headerlink" title="1 设计模式及原则"></a>1 设计模式及原则</h1><h2 id="1-1-设计模式是什么，有什么用？"><a href="#1-1-设计模式是什么，有什么用？" class="headerlink" title="1.1 设计模式是什么，有什么用？"></a>1.1 设计模式是什么，有什么用？</h2><p>设计模式就是构造弹性、可维护的面向对象系统的一些经验（用的多了就被整理命名为模式）</p><p>面向对象的基础是封装、继承和多态，设计模式就是以一定的策略去运用封装、继承和多态。</p><p><strong>设计模式的优点：</strong></p><ul><li>模式能让开发人员用更少的词汇做更充分的沟通；并且使交流保持在模式层次上、可以免去考虑具体对象的琐屑。</li><li>模式化开发给程序带来的是极高的可扩展性和可维护性。</li></ul><h2 id="1-2-Java设计模式的几大原则"><a href="#1-2-Java设计模式的几大原则" class="headerlink" title="1.2 Java设计模式的几大原则"></a>1.2 Java设计模式的几大原则</h2><blockquote><p>关于类和模块的三个原则：单一职责、迪米特、开放封闭</p><p>关于接口的三个原则：依赖倒置、接口隔离、合成复用</p><p>关于继承的一个原则：里氏替换原则</p></blockquote><p><strong>1 单一职责原则</strong></p><ul><li>一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。</li></ul><p><strong>2 迪米特原则</strong></p><ul><li>最少知道原则，每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。更有利于复用。</li></ul><p><strong>3 开放-封闭原则</strong></p><ul><li>代码对扩展是开放的，对更改是封闭的。在程序需要进行拓展的时候，不能去修改原有的代码。</li></ul><p><strong>4 依赖倒置原则</strong></p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 也就是要面向接口编程，不要面向实现编程。</li></ul><p><strong>5 接口隔离原则</strong></p><ul><li>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li></ul><p><strong>6 合成复用原则</strong></p><ul><li>尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</li></ul><p><strong>7 里氏替换原则</strong></p><ul><li><p>所有引用基类(父类)的地方必需能够透明地使用子类对象。也就是说，在程序里面，把父类都替换成它的子类，程序的行为没有变化.</p></li><li><p>里氏代换原则要求不能破坏继承体系，具体表现在：</p><ul><li><p>1 子类应该实现父类的所有抽象方法，不要覆盖父类的非抽象方法。</p></li><li><p>2 子类可以增加自己特有的方法。</p></li><li><p>3 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p></li><li><p>4 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p></li></ul></li></ul><h2 id="1-3-设计模式的分类"><a href="#1-3-设计模式的分类" class="headerlink" title="1.3 设计模式的分类"></a>1.3 设计模式的分类</h2><p>1 创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有<strong>工厂方法模式、抽象工厂模式、单例模式</strong>、建造者模式、原型模式。（用来创建系统中的对象）</p><p>2 结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有<strong>适配器模式、装饰器模式、代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。（用来表示系统间类和对象的结构）</p><p>3 行为型模式：通过类之间不同通信方式实现不同行为。有<strong>策略模式、模板方法模式、观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、<strong>状态模式</strong>、访问者模式、中介者模式、解释器模式。（用来表示系统间类和对象之间的行为）</p><h1 id="2-理解几种重要的设计模式"><a href="#2-理解几种重要的设计模式" class="headerlink" title="2 理解几种重要的设计模式"></a>2 理解几种重要的设计模式</h1><blockquote><p>工厂模式、单例模式、代理模式</p><p>策略模式、观察者模式、模板方法模式</p></blockquote><h2 id="2-1-三种工厂模式"><a href="#2-1-三种工厂模式" class="headerlink" title="2.1 三种工厂模式"></a>2.1 三种工厂模式</h2><blockquote><p>所有的工厂都是用来封装对象的创建</p><p>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</p><p>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象（抽象工厂模式）</p></blockquote><p>1 静态工厂模式</p><ul><li><p><strong>专门写一个静态的工厂类来实例化对象</strong>，因为我们要创建的对象经常是可能发生改变的（比如披萨的种类不一样），我们把这些变化封装到静态的工厂类里面了。</p></li><li><p>创建新对象时直接用<strong>工厂类.方法</strong>，来创建对象，适用于工厂类负责创建对象较少的情况。</p></li></ul><p>2 工厂方法模式</p><ul><li><p>工厂方法模式<strong>指定义一个创建对象的接口（其中有一个工厂方法），让接口的实现类（重写工厂方法）来决定创建哪种对象</strong>，让类的实例化推迟到子类中进行。</p></li><li><p>静态工厂模式只做到了将对象的创建过程封装起来，而不具有弹性（要增加类就要改工厂类、增加if-else判断）。工厂方法模式具有弹性、要新增一个新的具体的对象、直接扩展再写一个类就好，无需改变超类中的“工厂方法”。其实这就是开放封闭原则的体现（对扩展开放、对修改封闭）</p></li></ul><p>3 抽象工厂模式</p><ul><li><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。说人话就是<strong>有一个抽象工厂类接口，实现这个接口的多个类都是具有不同功能的工厂类</strong></p></li><li><p>（让客户从具体产品中解耦了、决定创建何种产品的是实现了抽象工厂类的各种特别的工厂类）<strong>抽象工厂–地区工厂类</strong></p></li></ul><h2 id="2-2-单例模式"><a href="#2-2-单例模式" class="headerlink" title="2.2 单例模式"></a>2.2 单例模式</h2><blockquote><p>如果使用多个类加载器，可能导致单例失效而产生多是实例，一般建议指定类加载器</p></blockquote><p>==确保一个类只有一个实例，并提供一个全局访问点。==</p><p>一个类，没有公共的构造方法，只有<strong>一个私有的静态变量</strong>；<strong>一个私有的构造方法</strong>；外加<strong>一个公共的静态的getInstrance()方法</strong>，用来调用私有的构造方法、创建一个实例对象。</p><p><strong>1 线程不安全的懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//一个私有的静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123; uniqueInstance = <span class="keyword">new</span> Singleton();  &#125;         </span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：当多个线程同时调用getInstrnce()方法时，可能出现new出两个对象的情况，即是线程不安全的、不能确保一个类只有一个实例</p><p><strong>2 synchronized加锁的懒汉式</strong></p><p>对 getUniqueInstance() 方法加锁，只有该实例为null的时候才创建实例对象，保证了实例的唯一性。</p><p>问题：事实上只有第一次实例化该对象的时候才需要同步，创建之后用null判断即可，过多的同步（每次访问都要带锁）带来效率较低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//一个私有的静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的加锁的获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3 双重校验的懒汉式</strong></p><p>原理：</p><ul><li>uniqueInstance 采用 volatile 关键字修饰保证可见性、避免指令重排带来的并发问题</li><li>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</li><li>不再对获取实例的方法加锁了、只在创建对象的时候加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;             </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4 饿汉式</strong></p><p>直接实例化静态变量保证线程安全</p><p>问题：直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个私有的静态变量 直接实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance= <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的获取实例的方法 直接返回实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-代理模式"><a href="#2-3-代理模式" class="headerlink" title="2.3 代理模式"></a>2.3 代理模式</h2><blockquote><p>这里可以直接联系框架的AOP部分，学到的代理模式。举房东、中介、房客的例子</p></blockquote><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。</p><p>静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p>动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p><h2 id="2-4-策略模式"><a href="#2-4-策略模式" class="headerlink" title="2.4 策略模式"></a>2.4 策略模式</h2><p>定义一系列算法，分别封装起来，并使它们可以互换，成为一个算法族。策略模式让算法的变化独立于使用算法的客户。</p><p>每种行为（就是每个算法族）都是以实现接口的方式定义的类。也就是<strong>多用实现接口，少用继承</strong>的原则（合成复用原则）</p><p>使用场景： 现有 加/减/乘 几种算法，输入参数返回值都一样（可以理解成一类算法族）。现在需要在调用时动态配置算法策略，实现对不同算法的调用。就可以使用策略模式</p><h2 id="2-5-观察者模式（订阅、通知）"><a href="#2-5-观察者模式（订阅、通知）" class="headerlink" title="2.5 观察者模式（订阅、通知）"></a>2.5 观察者模式（订阅、通知）</h2><p>观察者模式表示的是一种对象与对象之间具有依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>使用场景：</p><ul><li>1比如 声音报警器和闪光灯报警器分别订阅热水器温度，热水器温度过高时，发出通知，两个报警器分别发声、闪光以实现报警。</li><li>2又比如很多人订阅微信公众号，该公众号有更新文章时，自动通知每个订阅的用户。</li></ul><p>实现条件：1,多个观察者要订阅这个对象 2，这个对象要发出通知</p><h2 id="2-6-模板方法模式"><a href="#2-6-模板方法模式" class="headerlink" title="2.6 模板方法模式"></a>2.6 模板方法模式</h2><p>模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。</p><p>（待完善和理解…）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式。设计模式的原则和集中基本的设计模式。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://wukang555.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发浅析</title>
    <link href="https://wukang555.github.io/2021/07/29/%E9%9D%A2%E7%BB%8F_05_JAVA%E5%B9%B6%E5%8F%91/"/>
    <id>https://wukang555.github.io/2021/07/29/%E9%9D%A2%E7%BB%8F_05_JAVA%E5%B9%B6%E5%8F%91/</id>
    <published>2021-07-29T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:14.522Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发浅析面经。线程、线程池、悲观锁、乐观锁。</p><a id="more"></a><h1 id="Java并发浅析"><a href="#Java并发浅析" class="headerlink" title="Java并发浅析"></a>Java并发浅析</h1><blockquote><p>[1] 参考了《Java高并发程序设计》，但我觉得这本书写的很乱、章节间的逻辑不清晰（仅个人观点）</p><p>[2] 参考了JavaGuide的文章：<a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E4%BA%8C-executor-%E6%A1%86%E6%9E%B6">java线程池学习总结</a></p></blockquote><h1 id="1-并发编程和JMM"><a href="#1-并发编程和JMM" class="headerlink" title="1 并发编程和JMM"></a>1 并发编程和JMM</h1><blockquote><p>了解并发的前因后果（为什么？提高性能；怎么做？多线程）</p><p>了解JMM的作用和原理</p></blockquote><h2 id="1-1-并行和并发是什么？"><a href="#1-1-并行和并发是什么？" class="headerlink" title="1.1 并行和并发是什么？"></a>1.1 并行和并发是什么？</h2><p>并行则指同一时刻能运行多个指令。并发是指宏观上在一段时间内能同时运行多个程序，单个时间片仍然只运行一个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h2 id="1-2-为什么要使用并发（多线程）？"><a href="#1-2-为什么要使用并发（多线程）？" class="headerlink" title="1.2 为什么要使用并发（多线程）？"></a>1.2 为什么要使用并发（多线程）？</h2><blockquote><p>其实多线程就是并发编程的实现方式，无论在单核还是多核cpu上</p><p>之所以需要并发还在于cpu的速度、寄存器、缓存、内存、硬盘IO的速度存在较大差别</p><p>为了更好的利用CPU的性能，就需要并发调度来实现</p></blockquote><p>并发和并行它们最重要的两个目都是：1为了获得更好的性能；2业务模型确实需要多个执行的实体。</p><p>首先聊一聊：关于并行的两个定律：<strong>Amdahl （安达尔）定律</strong> 和 <strong>Gustafson（古斯塔夫森） 定律</strong></p><ul><li>Amdahl强调：当串行比例一定时，加速比是有上限的，不管你堆叠多少个CPU 参与计算，都不能突破这个上限！</li><li>Gustafson定律关心的是：如果可被并行化的代码所占比重足够多，那么加速比就能 随着CPU的数量线性增长。</li></ul><p>虽然一个说加速比存在上限、一个说加速比可以随CPU数量线性增长，但是说的都有道理。安达尔认为串行并行比例一定，仅增加CPU资源，性能并不会得到巨大提升。古斯塔夫森认为当并行代码足够多时，性能随CPU数量正比增长。所以这其实就说明了<strong>多核CPU的并行是一种提升效率的手段、但提高代码的并发量同样是十分重要的。这也是为什么要并发编程、尽可能的提高单核CPU的利用效率的原因</strong></p><p><strong>而并发编程的实现手段其实就是进程和线程，多线程进行切换轮流获取CPU的资源，以实现CPU利用率的最大化！！</strong>并发编程极大的提高了代码运行的效率、但也会带来线程安全的问题，所以学习并发编程也要懂如何避免和处理线程安全的问题。</p><h2 id="1-3-如何避免线程安全的问题"><a href="#1-3-如何避免线程安全的问题" class="headerlink" title="1.3 如何避免线程安全的问题"></a>1.3 如何避免线程安全的问题</h2><p>为了更高效的运行代码，所以需要并发编程技术，并发技术的实现就是利用多线程、轮流调度和执行cpu的资源。而并发编程时，极有可能照成线程安全的问题，（即多个线程同时对一个内存区域操作，例如堆区，造成读取数据不一致的问题），所以我们需要解决并发编程时造成的线程安全问题！！简略的讲一下下面5种方式：</p><ul><li><p>1 方式一：每一个线程，在堆区分配一份区域，每个线程自己认领一份，只能修改自己对应区域的数据。（数据还是在堆区，被线程认领了）<strong>这就是ThreadLocal的基本原理</strong></p></li><li><p>2 方式二：线程私有的栈区域，存取自己的数据（<strong>虚拟机栈</strong>）</p></li><li><p>3 方式三：比如final设置为常量，只能读取不能操作。</p></li><li><p>4 方式四：加锁，想要超过公共的数据、需要先获得锁（锁的类型有多种）<strong>悲观锁</strong></p></li><li><p>5 方式五：CAS(其中可能出现ABA问题)，适合于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。<strong>这就是乐观锁的原理</strong></p></li></ul><h2 id="1-4-Java内存模型"><a href="#1-4-Java内存模型" class="headerlink" title="1.4 Java内存模型"></a>1.4 Java内存模型</h2><h3 id="1-4-1-JMM介绍"><a href="#1-4-1-JMM介绍" class="headerlink" title="1.4.1 JMM介绍"></a>1.4.1 JMM介绍</h3><p>JMM（Java Memory Model）是为了保证多个线程可以有效正确地协同地工作，实现在各种平台上都可以达到一致地内存访问的效果。</p><p>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程有自己的工作内存（Working Memory）,线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p><p>（这里的主内存工作内存是一种逻辑的抽象，不对应具体的内存区域）JMM通过这种主内存和工作内存的机制来解决多线程对共享数据读写一致性的问题。</p><p>Java Memory Model(Java内存模型)， 围绕着在并发过程中如何处理<strong>可见性、原子性、有序性</strong>这三个特性而建立的模型。</p><ul><li><p>原子性：原子性是指一个操作是不可中断的。即使是在多线程的环境下，一个操作一旦开 始，就不会被其他线程干扰。</p></li><li><p>可见性：可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</p></li><li><p>有序性：程序执行时基于性能的考虑，对指令进行重排。多线程并发执行时可能出现有序性的问题</p></li></ul><h3 id="1-4-2-volatile关键字保证可见性【重点】"><a href="#1-4-2-volatile关键字保证可见性【重点】" class="headerlink" title="1.4.2 volatile关键字保证可见性【重点】"></a>1.4.2 volatile关键字保证可见性【重点】</h3><p>Java提供了volatile关键字来保证可见性。　当一个共享变量被volatile修饰时，能保证修改的值会立即更新到主存，当有其他线程需要读取时，它会去主内中读取新的值。</p><p>volatile在汇编代码层面的实现原理：“加入volatile关键字时，汇编代码会多出一个lock前缀指令”，</p><ul><li><p>1）lock前缀指令实际上相当于一个内存屏障，，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p></li><li><p>2）它会强制将对缓存的修改操作立即写入主存；</p></li><li><p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p></li></ul><h3 id="1-4-3-as-if-serial-和-happens-before原则【重点】"><a href="#1-4-3-as-if-serial-和-happens-before原则【重点】" class="headerlink" title="1.4.3 as-if-serial 和 happens-before原则【重点】"></a>1.4.3 as-if-serial 和 happens-before原则【重点】</h3><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。</p><ul><li><p>as-if-serial原则</p><ul><li>不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。</li></ul></li><li><p>Happen-Before原则——先行发生原则</p><ul><li><p>程序顺序原则：一个线程内保证语义的串行性</p></li><li><p> volatile规则：volatile变量的写，先发生于读，这保证了 volatile变量的可见性</p></li><li><p>锁规则：解锁 （unlock) 必然发生在随后的加锁（lock) 前</p></li><li><p>传递性：A 先于B, B 先于C，那么A 必然先于C</p></li><li><p> 线程 的 start()方法先于它的每一个动作</p></li><li><p>线程的所有操作先于线程的终结（Threadjoin())</p></li><li><p>线程的中断（interrupt()) 先于被中断线程的代码</p></li><li><p>对象的构造函数执行、结束先于finalize()方法</p></li></ul></li></ul><h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h1><blockquote><p>1 线程：线程创建、多线程、线程调度、线程协作</p></blockquote><h2 id="2-1-线程的生命周期和状态（6种）"><a href="#2-1-线程的生命周期和状态（6种）" class="headerlink" title="2.1 线程的生命周期和状态（6种）"></a>2.1 线程的生命周期和状态（6种）</h2><ul><li>新建状态NEW：创建后尚未启动。</li><li>可运行状态RUNABLE：该线程可以被运行，其实包括了Ready和Running两种状态<ul><li>线程调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（准备）</strong>状态</li><li>READY准备状态的线程获得了 CPU 时间片后就处于 <strong>RUNNING（运行）</strong> 状态。</li></ul></li><li>阻塞状态（Blocked）：请求锁而未得，进入阻塞状态，需要等待其他线程释放锁才能重新进入runnable状态</li><li>等待状态（WAITING）：当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态</li><li>限期等待状态（TIMED_WAITING）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</li><li>终止状态（TERMINATED）：可以是线程结束任务之后自己结束，或者产生了异常而结束。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212509.png" alt="image-20210819170721435" style="zoom:80%;"><h2 id="2-2-线程的创建和启动"><a href="#2-2-线程的创建和启动" class="headerlink" title="2.2 线程的创建和启动"></a>2.2 线程的创建和启动</h2><p><strong>1 有三种创建线程的方法【重要】：</strong></p><ul><li><p>① 继承 Thread 类并重写 run 方法。实现简单，但不符合里氏替换原则，不可以继承其他类。</p></li><li><p>② 实现 Runnable 接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。</p></li><li><p>③实现 Callable 接口并重写 call 方法。可以获取线程执行结果的返回值，并且可以抛出异常。</p></li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过new Thread(XX) 来调用。可以理解为任务是通过线程驱动从而执行的。</p><p><strong>2 启动线程的start()和run()方法的区别【重要】</strong></p><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 </p><p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。（执行run()并没有开启一个新的线程）</p><p>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p><h2 id="2-3-线程之间的协作"><a href="#2-3-线程之间的协作" class="headerlink" title="2.3 线程之间的协作"></a>2.3 线程之间的协作</h2><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>调用 wait() 使线程挂起，当其他线程的运行时调用 notify() 或者 notifyAll() 来唤醒该挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p><p>wait() notify() 都只能用在同步方法或者同步控制块中使用，使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。一般使用 Lock 来获取一个 Condition 对象。</p><h3 id="join-和yield"><a href="#join-和yield" class="headerlink" title="join()和yield()"></a>join()和yield()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>Thread.yield() 是一个静态方法，一旦执行，它会使当前线程让出CPU。声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。让出CPU并不表 示当前线程不执行了。当前线程在让出CPU后，CPU根据优先级调度给优先级高的线程。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地调用时自行进行处理。</p><h3 id="wait-和sleep-的区别【重要】"><a href="#wait-和sleep-的区别【重要】" class="headerlink" title="wait()和sleep()的区别【重要】"></a>wait()和sleep()的区别【重要】</h3><ul><li><code>wait()</code> 是 Object 的方法，而 <code>sleep()</code> 是 Thread 的静态方法；</li><li><code>wait()</code> 会释放锁，<code>sleep()</code> 不会释放锁。</li><li><code>Wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。</li></ul><h2 id="2-4-ThreadLocal是什么？有什么用？"><a href="#2-4-ThreadLocal是什么？有什么用？" class="headerlink" title="2.4 ThreadLocal是什么？有什么用？"></a>2.4 ThreadLocal是什么？有什么用？</h2><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p><p>（数据在堆上面，然后每个线程分一小块自己特定的区域？）</p><h1 id="3-线程池【重要】"><a href="#3-线程池【重要】" class="headerlink" title="3 线程池【重要】"></a>3 线程池【重要】</h1><h2 id="3-1-为什么要使用线程池"><a href="#3-1-为什么要使用线程池" class="headerlink" title="3.1 为什么要使用线程池"></a>3.1 为什么要使用线程池</h2><blockquote><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。将活跃的线程放入线程池中，方便取用。<strong>创建线程和关闭线程的流程变为了：从线程池中获得空闲线程和向池子归还线程</strong></p><p>好处：</p><ul><li><p>提高响应速度、减少了创建新线程的时间</p></li><li><p>降低资源消耗、重复利用线程池中的线程，不需要每次都创建</p></li><li><p>便于线程的管理，<code>ThreadPoolExecutor</code>类方法中的参数</p><ul><li><code>corePoolSize</code> 核心池的大小</li><li><code>maximumPoolSize</code> 最大线程数</li><li><code>keepAliveTime</code>  当线程池线程数量超过<code>corePoolSize</code>时，多余的空闲线程的存活时间。 即，超过<code>corePoolSize</code>的空闲线程，在多长时间内，会被销毁。</li><li><strong><code>workQueue</code>: 任务队列，被提交但尚未被执行的任务。</strong></li><li><strong><code>handler</code>: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</strong></li></ul></li></ul><h2 id="3-2-建议使用ThreadPoolExecutor类"><a href="#3-2-建议使用ThreadPoolExecutor类" class="headerlink" title="3.2 建议使用ThreadPoolExecutor类"></a>3.2 建议使用<code>ThreadPoolExecutor</code>类</h2><blockquote><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><p> <code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code> </p></blockquote><h3 id="3-2-1-ThreadPoolExecutor类介绍"><a href="#3-2-1-ThreadPoolExecutor类介绍" class="headerlink" title="3.2.1 ThreadPoolExecutor类介绍"></a>3.2.1 <code>ThreadPoolExecutor</code>类介绍</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。（这个参数在等待队列满了之后发挥作用，判断是否使用拒绝策略）</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212516.png" alt="线程池各个参数的关系" style="zoom:67%;"><h3 id="3-2-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#3-2-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="3.2.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>3.2.2 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3><blockquote><p>1《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供！</p><p>2《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable.java</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutorDemo.java</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="3-2-3-线程池执行原理分析"><a href="#3-2-3-线程池执行原理分析" class="headerlink" title="3.2.3 线程池执行原理分析"></a>3.2.3 线程池执行原理分析</h3><blockquote><p>分析上小节的执行结果</p></blockquote><p>核心线程是是5，当循环创建5个线程并执行之后，新创建的线程将进入等待队列。使用的拒绝策略是CallerRimsPolicy策略，类似于一直等核心核心线程空出来，出来了等待的线程就上去。</p><p>即每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p><p><strong>执行过程分析：</strong></p><ul><li>线程池会判断当前已创建的线程**是否小于 corePoolSize  (核心线程数)**，如果小于，就会选择创建一个新的线程来执行该任务。</li><li>当线程池中已创建的线程数等于核心核心线程数时，此时<strong>判断任务队列是否已满</strong>，如果未满，就加入等待队列</li><li>如果等待队列已满，<strong>再判断最大线程数</strong>，如果小于直接新建线程执行任务。大于就执行拒绝策略</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212523.png" alt="图解线程池实现原理"></p><h2 id="3-3-拒绝策略handler【重要】"><a href="#3-3-拒绝策略handler【重要】" class="headerlink" title="3.3 拒绝策略handler【重要】"></a>3.3 拒绝策略handler【重要】</h2><p>线程池中的线程数已经用完了，无法继续为新任务 服务，同时，等待队列中也己经排满了，再也塞不下新任务了。拒绝策略即系统超负荷运行时的补 救措施</p><p>四种拒绝策略如下：</p><ul><li><p> AbortPolicy策略：该策略会直接抛出异常，阻止该任务正常执行。【默认】</p></li><li><p>CallerRimsPolicy策略：调用线程直接运行新任务的run方法。这样做虽然不会丢弃新任务，但是，任务提交线程的性能极有可能会急剧下降。</p></li><li><p>DiscardOledestPolicy策略：丢弃任务队列中最先进入的任务。通常用于类似记录轨迹、偶尔丢失一些数据没有关系，烦希望最新的数据可以的得到保存。</p></li><li><p>DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。通用用于期望保存旧数据的场景</p></li></ul><h2 id="3-4-线程池的几个方法对比"><a href="#3-4-线程池的几个方法对比" class="headerlink" title="3.4 线程池的几个方法对比"></a>3.4 线程池的几个方法对比</h2><p><strong>execute() VS submit()</strong></p><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功（可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。）</li></ul><p><strong>shutdown() VS shutdownNow()</strong></p><ul><li>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。<br>shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终</li></ul><p><strong>isTerminated() VS isShutdown()</strong></p><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><h2 id="3-5-几个常见的线程池"><a href="#3-5-几个常见的线程池" class="headerlink" title="3.5 几个常见的线程池"></a>3.5 几个常见的线程池</h2><blockquote><p>这几个类其实都是对ThreadPoolExecutor类的封装，不推荐使用哦</p></blockquote><p>newFixedThreadPool(int nThreads)</p><ul><li>返回一个固定线程数量的线程池。该线程池中的线 程数量始终不变。</li><li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列</li><li>使用无界队列，不会拒绝任务，会导致内存溢出OOM</li></ul><p>newSingleThreadExecutor() </p><ul><li>返回一个只有一个线程的线程池</li><li>同样使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列，会导致OOM</li></ul><p>newCachedThreadPool() </p><ul><li>该方法返回一个可根据实际情况调整线程数量的线程池。 线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。</li><li><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><p>newScheduledThreadPool(int corePoolSize)</p><ul><li> 主要用来在给定的延迟后运行任务，或者定期执行任务。可以指定线程数量</li><li>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><h2 id="3-6-线程池大小的确定"><a href="#3-6-线程池大小的确定" class="headerlink" title="3.6 线程池大小的确定"></a>3.6 线程池大小的确定</h2><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N+1)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。<strong>我们大多数的业务，因为要操作数据库、一般都是IO密集的任务</strong>，只有大量排序、计算圆周率小数点后位数这种任务可以认为是CPU密集的。</p><p>其实对于IO密集型类型的应用，网上还有一个公式：<strong>线程数 = CPU核心数/(1-阻塞系数)</strong></p><p>引入了阻塞系数的概念，一般为0.8~0.9之间，如果取0.8就是5倍的核心数，如果取0.9就是10倍的核心数</p><h1 id="4-悲观锁：synchronized关键字和ReentrantLock可重入锁"><a href="#4-悲观锁：synchronized关键字和ReentrantLock可重入锁" class="headerlink" title="4 悲观锁：synchronized关键字和ReentrantLock可重入锁"></a>4 悲观锁：synchronized关键字和ReentrantLock可重入锁</h1><h2 id="4-1-synchronized关键字介绍"><a href="#4-1-synchronized关键字介绍" class="headerlink" title="4.1 synchronized关键字介绍"></a>4.1 synchronized关键字介绍</h2><p>功能：实现线程之间的同步，对同步的代码加锁，使得每一次、只有一个线程能进入同步块</p><p>三种使用方法（范围越来越大）</p><ul><li><p>指定加锁的对象：给指定的对象加锁</p></li><li><p>直接作用于实例方法：对当前实例加锁</p></li><li><p>直接所用于静态方法：对当前的类加锁</p></li></ul><h2 id="4-2-谈谈synchronized与ReentrantLock的区别？"><a href="#4-2-谈谈synchronized与ReentrantLock的区别？" class="headerlink" title="4.2 谈谈synchronized与ReentrantLock的区别？"></a>4.2 谈谈synchronized与ReentrantLock的区别？</h2><ul><li><p>底层实现上来说</p><ul><li><p>synchronized 是JVM层面的锁，是Java关键字，synchronized 的实现涉及到锁的升级和优化，具体为无锁、偏向锁、轻量级锁、自旋锁等。</p></li><li><p>ReentrantLock 是从jdk1.5以来提供的API层面的锁。</p></li></ul></li><li><p>从锁的对象来说</p><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li></ul></li><li><p>从操作步骤来说</p><ul><li><p>synchronized 不需要手动获取锁和释放锁，使用简单；</p></li><li><p>lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p></li></ul></li><li><p>ReentrantLock具有更多得功能</p><ul><li><p>ReentrantLock则可以设置中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法；</p></li><li><p>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p></li><li><p>ReentrantLock通过绑定Conditiont条件结合await()/singal()方法实现线程的精确唤醒</p></li></ul></li></ul><h2 id="4-3-Java虚拟机对锁优化（synchronized）"><a href="#4-3-Java虚拟机对锁优化（synchronized）" class="headerlink" title="4.3 Java虚拟机对锁优化（synchronized）"></a>4.3 Java虚拟机对锁优化（synchronized）</h2><p>方案一：锁的升级，无锁——&gt;锁偏向——&gt;轻量级锁——&gt;自旋锁</p><p>方案二： 锁消除</p><p><strong>1 锁偏向</strong></p><ul><li><p>如果一个线程获得了锁，那么 锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。</p></li><li><p>对于几乎没有锁竞争的场合，偏向锁有比较好 的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。</p></li><li><p>而对于锁竞争比较激烈的场合，其效果不佳</p></li></ul><p><strong>2 轻量级锁</strong></p><ul><li><p>如果偏向锁失败，虚拟机并不会立即挂起线程。而是使用轻量级锁。</p></li><li><p>轻量级锁简单地将对象头部作为指针，指向持有锁的线程堆栈的内部， 来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。</p></li><li><p>如果 轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p></li></ul><p><strong>3 自旋锁</strong></p><ul><li><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力 — 自旋锁</p></li><li><p>系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。</p></li><li><p>因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。</p></li><li><p>如果还不能获得锁，才会真实地将线程在操作系统层面挂起。</p></li></ul><p><strong>4 锁消除</strong></p><ul><li><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p></li><li><p>比如， 你很有可能在一个不可能存在并发竞争的场合使用Vector。</p><ul><li>如果Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到 这种情况，就会将这些无用的锁操作去除。</li></ul></li></ul><h1 id="5-乐观锁和CAS"><a href="#5-乐观锁和CAS" class="headerlink" title="5 乐观锁和CAS"></a>5 乐观锁和CAS</h1><h2 id="5-1-乐观锁与CAS算法"><a href="#5-1-乐观锁与CAS算法" class="headerlink" title="5.1 乐观锁与CAS算法"></a>5.1 乐观锁与CAS算法</h2><p>对于乐观锁，开发者认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。</p><p>到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。</p><p>乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。</p><p>CAS 算法的思路如下：</p><ul><li><p>包含三个参数C A S (V ，E ，N )。V 表示要更新的变量，E 表示预期值，N 表示新值。</p></li><li><p>仅当V 值等于E 值时，才会将V 的值设为N 。</p></li><li><p> 如果V 值和E 值不同，则说明己经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</p></li></ul><h2 id="5-2-ABA问题及解决方法简述"><a href="#5-2-ABA问题及解决方法简述" class="headerlink" title="5.2 ABA问题及解决方法简述"></a>5.2 ABA问题及解决方法简述</h2><p>CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。</p><p>juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。</p><h2 id="5-3-常见的Atomic类"><a href="#5-3-常见的Atomic类" class="headerlink" title="5.3 常见的Atomic类"></a>5.3 常见的Atomic类</h2><p>简述常见的Atomic类</p><p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。 基本数据类型的原子类有：</p><p>Atomic整形类型有：</p><ul><li>AtomicInteger 原子更新整形</li><li>AtomicLong 原子更新长整型</li><li>AtomicBoolean 原子更新布尔类型</li></ul><p>Atomic数组类型有：</p><ul><li>AtomicIntegerArray 原子更新整形数组里的元素</li><li>AtomicLongArray 原子更新长整型数组里的元素</li><li>AtomicReferenceArray 原子更新引用类型数组里的元素。</li></ul><p>Atomic引用类型有</p><ul><li>AtomicReference 原子更新引用类型</li><li>AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li><li>AtomicStampedReference 原子更新带有版本号的引用类型</li></ul><p>FieldUpdater类型：</p><ul><li>AtomicIntegerFieldUpdater 原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater 原子更新长整形字段的更新器</li><li>AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li></ul><h2 id="5-4-简述Atomic类基本实现原理"><a href="#5-4-简述Atomic类基本实现原理" class="headerlink" title="5.4 简述Atomic类基本实现原理"></a>5.4 简述Atomic类基本实现原理</h2><p>以AtomicIntger 为例： 方法getAndIncrement：以原子方式将当前的值加1，具体实现为：</p><ol><li>在 for 死循环中取得 AtomicInteger 里存储的数值</li><li>对 AtomicInteger 当前的值加 1</li><li>调用 compareAndSet 方法进行原子更新</li><li>先检查当前数值是否等于 expect</li><li>如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li><li>如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li></ol><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212530" alt="图片"></p><h2 id="5-5-悲观锁和乐观锁的区别【重要】"><a href="#5-5-悲观锁和乐观锁的区别【重要】" class="headerlink" title="5.5 悲观锁和乐观锁的区别【重要】"></a>5.5 悲观锁和乐观锁的区别【重要】</h2><p>悲观锁：总是假设最坏情况，每次取数据时都认为其他线程会修改数据，所以都会加锁，当其他线程想要访问数据时，都要挂起等待。</p><p>乐观锁：总是认为不会产生并发的问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般使用CAS机制来实现！</p><p>悲观锁和乐观锁分别有不同的使用场景，显然在高并发的场合或者重试代价特别大的场合，线程竞争激烈，适合用悲观锁、避免出现线程安全问题。在很少发生线程安全问题的场合，适合用乐观锁的思想，能提高程序运行的效率。</p><h1 id="6-AQS、并发容器"><a href="#6-AQS、并发容器" class="headerlink" title="6 AQS、并发容器"></a>6 AQS、并发容器</h1><blockquote><p>这部分不看了、直接说不知道吧</p></blockquote><p>AQS 队列同步器是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>AQS是实现锁的关键。AQS有两种模式：</p><ul><li><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p></li><li><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功，ReadLock 就采用共享模式。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java并发浅析面经。线程、线程池、悲观锁、乐观锁。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="并发" scheme="https://wukang555.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JVM思路大赏</title>
    <link href="https://wukang555.github.io/2021/07/28/%E9%9D%A2%E7%BB%8F_04_JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://wukang555.github.io/2021/07/28/%E9%9D%A2%E7%BB%8F_04_JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2021-07-28T14:55:00.000Z</published>
    <updated>2022-05-17T12:17:40.393Z</updated>
    
    <content type="html"><![CDATA[<p>JVM思路大赏。通俗易懂！极简。</p><a id="more"></a><h1 id="JVM思路大赏"><a href="#JVM思路大赏" class="headerlink" title="JVM思路大赏"></a>JVM思路大赏</h1><blockquote><p>[1] 主要参了Guide得 JVM文章，原文作者：<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a>原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p><p>[2] 参考了cys2018的文章 <a href="http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java虚拟机</a></p></blockquote><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><blockquote><p>我首先要理解JAVA虚拟机是什么、有什么用，然后才能去讨论JVM一些功能的具体实现。</p></blockquote><h2 id="0-1-JAVA虚拟机是什么？"><a href="#0-1-JAVA虚拟机是什么？" class="headerlink" title="0.1 JAVA虚拟机是什么？"></a><strong>0.1 JAVA虚拟机是什么？</strong></h2><p>我们知道JDK由编译器、JRE和常用类库组成，而JRE运行时环境是由JVM和核心类库组成的。java文件经由编译器编译成字节码，字节码在虚拟机上运行，所以：JVM其实就是为编译后的class字节码代码提供一种运行的环境（加上核心库）。</p><p>说白了，JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下。它直接和操作系统进行交互，与硬件不直接交互，操作系统完成和硬件的交互部分。然后我们写的java代码都运行再JVM提供的环境上，JVM通过在实际的计算机上仿真模拟了一种虚拟的计算机运行环境。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212353.png" alt="img"></p><h2 id="0-2-JAVA虚拟机有什么用？"><a href="#0-2-JAVA虚拟机有什么用？" class="headerlink" title="0.2 JAVA虚拟机有什么用？"></a><strong>0.2 JAVA虚拟机有什么用？</strong></h2><p>首先我们知道Java语言有以下的几个有优点</p><ul><li>它摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想；</li><li>提供了一个相对安全的内存管理和访问 机制，避免了绝大部分的内存泄露和指针越界问题</li><li>它实现了热点代码检测和运行时编译及优化，这使得Java应用 能随着运行时间的增加而获得更高的性能</li><li>它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第 三方类库</li></ul><p>那么Java为什么具有以上几个优点呢？答案就再JVM之中！！</p><p><strong>1 平台无关性</strong></p><blockquote><p>字节码文件可以在不同机器上的JVM上运行，因此java才具有平台无关性</p></blockquote><ul><li>java编译的字节码文件 class文件是平台无关的，class文件再由JVM动态转换就可以变为本地的机器代码。。也就是说虽然JVM是平台有关的（不同操作系统、机器上的jvm版本是不同的），但对开发人员来说是平台无关的。编译生成的字节码文件是可以到处运行的</li><li>java数据结构的统一性，基本数据类型的大小有明确的规定，比如int永远是32位。。。但c/c++里面可以是16也可以是32</li></ul><p><strong>2 内存管理和访问机制</strong></p><blockquote><p>JVM的内存管理、类加载机制和GC也是重点中的重点！！</p><p>Java 虚拟机有自动内存管理机制，如果出现内存泄漏和溢出方面的问题，想要排查错误就必须要了解虚拟机是怎样使用内存的。</p></blockquote><ul><li>这里就包括jvm运行时的数据区域、类加载器、垃圾回收等相关内容</li><li>内存泄漏的原因和解决</li></ul><p><strong>3 热点代码检测和运行时编译及优化</strong></p><blockquote><p>热点代码的解释执行是《深入理解JVM》的第四部分内容，我是菜鸡我还不懂。</p></blockquote><ul><li>JIT（Just In Time）。在运行时按需编译的方式就是Just In Time。运行时编译分为两种方式：<strong>解释执行和热点方法</strong></li><li>解释执行指的是逐条执行。javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是<strong>解释执行。</strong></li><li><strong>热点方法</strong>就是把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。让CPU直接执行。这样编出来的代码效率会更高。</li><li>JIT线程与垃圾回收线程都是守护线程中的一种，守护线程提供一些系统性的功能服务，与普通线程不同，当一个java应用内只有守护线程时，java虚拟机会自然退出。</li></ul><h2 id="0-3-java文件是如何在JVM上运行的"><a href="#0-3-java文件是如何在JVM上运行的" class="headerlink" title="0.3 java文件是如何在JVM上运行的"></a>0.3 java文件是如何在JVM上运行的</h2><p>比如我们现在写了一个 HelloWorld.java，其实就类似于一个文本文件，只是有一定的缩进而已。</p><p>而我们知道java代码需要先经过编译器编译，然后才能在JVM上运行。而运行步骤的第一步就是：通过类加载器将所有的 <strong>.class</strong> 文件全部搬进JVM里面来</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212357.png" alt="img" style="zoom:80%;"><p><strong>接下来就要考虑.class文件放进jvm之后是如何存放的？也就是要了解JVM的内存区域</strong>（第一节会详细介绍！！）</p><p>首先是各线程所共享的：方法区、堆，然后是各线程私有的：程序计数器、栈。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212400.png" alt="img" style="zoom:67%;"><p>将class文件通过类加载器再在到JVM中，在事实上是将HelloWord.java这个类的纤细加载到了方法区中（这个过程就叫类的加载），然后JVM会找到程序的主入口，执行mian方法。后面需要什么类就加载什么类、进行对象的实例化等等，最后在栈中运行方法！！</p><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找（某个类方法表位于方法区该类的类信息中）。</p><h1 id="1-内存分配和回收策略"><a href="#1-内存分配和回收策略" class="headerlink" title="1 内存分配和回收策略"></a>1 内存分配和回收策略</h1><blockquote><p>内存区域、内存分配（堆）、回收策略（堆），每一个都是重点</p></blockquote><h2 id="1-1-运行时数据区域【重点】"><a href="#1-1-运行时数据区域【重点】" class="headerlink" title="1.1 运行时数据区域【重点】"></a>1.1 运行时数据区域【重点】</h2><p>由各个线程共享的方法区和堆，还有各线程私有的程序计数器和栈。四个区域的功能如下：</p><ul><li>方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（运行时常量池就在方法区里面，String对象都在里面哦）</li><li>Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。堆用于存放对象实例，如数组、复杂对象等。</li><li>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li><li>虚拟机栈 这是我们的代码运行空间。我们编写的每一个方法都会放到栈里面运行。<strong>局部变量、基本类型的变量、和对象的引用也存放在栈中。</strong></li></ul><p>简单来说就是：方法区放类信息、常量和静态变量；然后栈管方法的运行、堆管对象的储存；最后程序计数器，指向下一行需要执行的命令；</p><h2 id="1-2-栈和堆的生命周期"><a href="#1-2-栈和堆的生命周期" class="headerlink" title="1.2 栈和堆的生命周期"></a>1.2 栈和堆的生命周期</h2><h3 id="虚拟机栈的执行"><a href="#虚拟机栈的执行" class="headerlink" title="虚拟机栈的执行"></a>虚拟机栈的执行</h3><p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212404.png" alt="img" style="zoom:67%;"><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；<ul><li>线程的栈空间被耗尽，无法创建新的栈帧。（无限的递归调用会产生这个问题）</li></ul></li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。？<ul><li>请求创建一个超大对象，通常是一个大数组。</li><li>超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动</li><li>过度使用终结器（Finalizer），该对象没有立即被 GC</li><li>内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。</li></ul></li></ul><h3 id="栈和堆的生命周期"><a href="#栈和堆的生命周期" class="headerlink" title="栈和堆的生命周期"></a>栈和堆的生命周期</h3><p>栈的生命周期和所处的线程是一致的。所以对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。</p><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。堆内存中存放的是对象，这些对象也就是垃圾回收器主要的回收对象，故堆也称为GC堆。下节将讲如何堆中的对象是如何分配内存的，然后讲如何对其进行回收。</p><h2 id="1-3-堆内存的分配【重点】"><a href="#1-3-堆内存的分配【重点】" class="headerlink" title="1.3 堆内存的分配【重点】"></a>1.3 堆内存的分配【重点】</h2><blockquote><p>方法区在JDK7及之前是属于永久代；但JDK8之后，HotSpot 的永久代被彻底移除了，取而代之是元空间，元空间使用的是直接内存。</p></blockquote><h3 id="1-堆内存的分代分配"><a href="#1-堆内存的分代分配" class="headerlink" title="1 堆内存的分代分配"></a>1 堆内存的分代分配</h3><p>Java堆内存中划分为<strong>年轻代</strong>和<strong>老年代</strong>，年轻代又会分为<strong>Eden</strong>（英[ˈiːdn] 伊甸园）和<strong>Survivor</strong>区。（Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。）</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212407.png" alt="img" style="zoom:67%;"><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212410.png" alt="JVM堆内存结构-JDK8"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图示：Eden 区、Survivor 区都属于新生代（这两个 Survivor 区域按照顺序被命名为from和to）</center> <h3 id="2-Minor-GC-和-Full-GC"><a href="#2-Minor-GC-和-Full-GC" class="headerlink" title="2 Minor GC 和 Full GC"></a>2 Minor GC 和 Full GC</h3><p><strong>Minor GC 和 Full GC的触发条件</strong></p><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p><p><strong>当Eden空间满了之后，会触发一个叫做Minor GC（英[ˈmaɪnə(r)] 次要的）（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，</strong>此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。<strong>经过多次的 Minor GC后仍然存活的对象会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，</strong>期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212414.png" alt="img" style="zoom:80%;"><p><strong>Minor GC 和 Full GC的定义</strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="1-4-垃圾回收算法【重点】"><a href="#1-4-垃圾回收算法【重点】" class="headerlink" title="1.4 垃圾回收算法【重点】"></a>1.4 垃圾回收算法【重点】</h2><h3 id="1-对象是生存还是死亡"><a href="#1-对象是生存还是死亡" class="headerlink" title="1 对象是生存还是死亡"></a>1 对象是生存还是死亡</h3><p><strong>判断一个对象是否需要回收</strong></p><ul><li>引用计数法：添加引用计数器：当引用他时，计数器值加一，当失效时，减一，计数器为0的对象不可再被使用<ul><li>（很难解决对象之间循环引用的问题）</li></ul></li><li>可达性分析：通过一系列的称为“GC Roots”的 对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots没有任何引用链相连（<strong>用图论的话来说，就是从GC Roots到这个对象不可达</strong>）时，则证明此对象是不可用的。<ul><li>能够解决循环引用的问题，可它的实现需要耗费大量资源和时间（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</li></ul></li></ul><p><strong>宣告一个对象的死亡：至少需要两次标记</strong></p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。<ul><li>finalize()就是一个对象最后的自救过程</li><li>finalize()已经不被推荐使用了，对象的四种引用在逐渐代替它的功能</li></ul></li></ol><h3 id="2-再谈引用"><a href="#2-再谈引用" class="headerlink" title="2 再谈引用"></a>2 再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型。</p><ul><li>强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</li><li>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。</li><li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</li><li>虚引用：又称为幽灵引用，有没有都一样，唯一作用是回收时可以收到一条系统通知。</li></ul><h3 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3 垃圾回收算法"></a>3 垃圾回收算法</h3><p><strong>标记-清除算法</strong></p><ul><li><p>是最基础的收集算法。算法分为“标记”和“清 除”两个阶段：</p></li><li><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p></li><li><p>缺点</p><ul><li>一个是效率问题，标记和清除两个过程的效率都不高</li><li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212420.png" alt="img" style="zoom: 67%;"><p><strong>复制算法</strong></p><ul><li>为了解决效率问题的改进，将可用内存按容量划分为两块，每次只使用其中的一块。</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>缺点<ul><li>这种算法的代价是将内存缩小为原来的一半（也不一定是一半，可指定），堆内存的利用率不高。</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212422.png" alt="img" style="zoom:67%;"><p><strong>标记-整理算法</strong></p><ul><li>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212425.png" alt="img" style="zoom:67%;"><p><strong>分代收集算法</strong></p><ul><li>一般是把Java堆分为新生代和老年代，这样就可以根据 各个年代的特点采用最适当的收集算法。</li><li>新生代一般使用复制算法，（新生代清理频率高）</li><li>老年代使用“标记—清理”或者“标记—整理”算法 （老年代清理频率低）</li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212428.png" alt="img"></p><h4 id="Serial-（Old）收集器"><a href="#Serial-（Old）收集器" class="headerlink" title="Serial （Old）收集器"></a>Serial （Old）收集器</h4><p>Serial 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进<strong>行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</strong></p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><p>Serial Old是 Serial 收集器的老年代版本，它同样是一个单线程收集器。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212431.jpg" alt="img" style="zoom: 80%;"><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集。新生代采用标记-复制算法，老年代采用标记-整理算法。同样垃圾回收会停止其他线程。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212434.jpg" alt="img" style="zoom:80%;"><h4 id="Parallel-Scavenge-Old-收集器"><a href="#Parallel-Scavenge-Old-收集器" class="headerlink" title="Parallel Scavenge/Old 收集器"></a>Parallel Scavenge/Old 收集器</h4><p>Parallel Scavenge 看上去和ParNew 很像，但是其关注点是吞吐量（高效率的利用 CPU）。新生代采用标记-复制算法，老年代采用标记-整理算法。JDK8的默认收集器</p><p>Parallel Old是 Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h4 id="CMS收集器【重点】"><a href="#CMS收集器【重点】" class="headerlink" title="CMS收集器【重点】"></a>CMS收集器【重点】</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS收集器是基于“标记—清除”算法实现的。</p><p>实现的四个步骤：</p><ul><li>初始标记（CMS initial mark）<ul><li>初始标记仅仅只是标记一下GC Roots能 直接关联到的对象，速度很快</li></ul></li><li><strong>并发标记（CMS concurrent mark）</strong><ul><li>并发标记阶段就是进行GC RootsTracing的过程，在整个回收过程中耗时最长、不需要停顿 （耗时较长）</li></ul></li><li>重新标记（CMS remark）<ul><li>重新标记阶段则是为了修正并 发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li></ul></li><li><strong>并发清除（CMS concurrent sweep）</strong><ul><li>需要停顿</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212437.jpg" alt="img" style="zoom:80%;"><p>CMS是一款优秀的收集器，并发收集、低停顿但是CMS还远达不到完美的程度，它有以 下3个明显的缺点：</p><ul><li>1、CMS收集器对CPU资源非常敏感。吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>2、无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</li><li>3、标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="G1收集器【重点】"><a href="#G1收集器【重点】" class="headerlink" title="G1收集器【重点】"></a>G1收集器【重点】</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212441.png" alt="img" style="zoom:67%;"><h3 id="5-方法区和常量池的回收（了解）"><a href="#5-方法区和常量池的回收（了解）" class="headerlink" title="5 方法区和常量池的回收（了解）"></a>5 方法区和常量池的回收（了解）</h3><ul><li><p>字符串常量池主要回收的是废弃的常量。</p><ul><li>如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</li></ul></li><li><p>方法区：回收无用的类，类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h1 id="2-类的加载机制"><a href="#2-类的加载机制" class="headerlink" title="2 类的加载机制"></a>2 类的加载机制</h1><blockquote><p>类加载过程、类加载器、双亲委派模型，东西挺多的</p><p>[1] 参考了 zenjian_的文章:<a href="https://blog.csdn.net/javazejian/article/details/73413292">深入理解java类加载器ClassLoader</a></p><p>[2] 参考了 程序员刘先森的文章:<a href="https://zhuanlan.zhihu.com/p/33509426">面试官：请你谈谈java的类加载过程</a></p></blockquote><p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。一个类只在首次使用时加载并且仅加载一次。</p><p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p><h2 id="2-1-类加载的过程【重点】"><a href="#2-1-类加载的过程【重点】" class="headerlink" title="2.1 类加载的过程【重点】"></a>2.1 类加载的过程【重点】</h2><p>类加载的过程主要分为三个部分：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212445.jpg" alt="img"></p><p><strong>1 加载：</strong></p><p>将class文件加载到内存（类加载器），生成一个代表该类的class对象，然后将静态的数据结构转化为方法区中运行时的数据结构（我们知道方法区中保存着类的信息嘛）</p><p><strong>2 验证：</strong></p><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><ul><li>文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</li><li>元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</li><li>字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</li><li>符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</li></ul><p><strong>3 准备：</strong></p><p>为类变量(即static修饰的字段变量，静态变量)（在方法区中）分配内存，并且设置该类变量的初始默认值即0或null，如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值</p><ul><li>如果类变量是常量（static final修饰），那么它将初始化为表达式所定义的值。比如public static final int j = 123; 初始化为123。</li><li>这里也不会为实例变量分配初始化，实例变量是会随着对象一起分配到Java堆中，在创建实例的时候才会初始化</li></ul><p><strong>4 解析：</strong></p><p>将常量池内的符号引用替换为直接引用的过程。</p><ul><li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。（比如 import java.util.ArrayList就是一个全类名的符号引用）</li><li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li></ul><p><strong>5 初始化：</strong></p><p>执行类构造器的过程，目的是将类变量（static静态变量）显式的初始化，比如在准备阶段赋值默认0的变量，此时可以赋值指定的初始值。但要注意：</p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li></ul><h2 id="2-2-类加载器的分类"><a href="#2-2-类加载器的分类" class="headerlink" title="2.2 类加载器的分类"></a>2.2 类加载器的分类</h2><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。其实类加载器就是在第一个加载阶段工作的。</p><p>JVM虚拟机提供了4种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器、自定义类（custom）加载器。</p><p><strong>启动（Bootstrap）类加载器</strong></p><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分。它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中。</p><p><strong>扩展（Extension）类加载器</strong></p><p>用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 </p><p><strong>系统（System）类加载器</strong></p><p>它根据 Java 应用的类路径（classpath）来加载 Java 类。一般情况下系统类加载是程序中默认的类加载器。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212449" alt="img" style="zoom:80%;"><blockquote><p>双亲委派模式要求除了BootStrap ClassLoader启动类加载器没有父类加载器之外，其余的类加载其都应当有“父类加载器”，双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，</p></blockquote><p><strong>类加载器之间的关系（了解）：</strong></p><p>启动类加载器，由C++实现，没有父类。</p><p>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</p><p>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</p><p>自定义类加载器，父类加载器肯定为AppClassLoader。</p><h2 id="2-3-双亲委派机制【重点】"><a href="#2-3-双亲委派机制【重点】" class="headerlink" title="2.3 双亲委派机制【重点】"></a>2.3 双亲委派机制【重点】</h2><p><strong>定义：</strong></p><p><strong>类加载器的双亲委派机制：当要加载一个类时，总是先请求父类加载器去处理，也就是说不管哪个类，最后都会委托到BootStrap ClassLoader（启动类加载器）进行加载。</strong></p><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。（通俗来讲就是，每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子才会自己想办法去完成，）</p><p><strong>优点：</strong></p><ul><li>1 Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，即当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li><li>2 考虑到安全因素，使java核心api中定义类型不会被随意替换。比如自己写的Object类并不会替代核心类库中的Object类<ul><li>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</li></ul></li></ul><h2 id="2-4-类加载的时机【了解】"><a href="#2-4-类加载的时机【了解】" class="headerlink" title="2.4 类加载的时机【了解】"></a>2.4 类加载的时机【了解】</h2><blockquote><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p></blockquote><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li>遇到 <strong>new</strong>、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类<strong>进行反射调用</strong>的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要<strong>先触发其父类的初始化</strong>。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <strong>main() 方法的那个类</strong>），虚拟机会先初始化这个主类；</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li></ul><h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h1 id="3-对象创建和内存溢出异常"><a href="#3-对象创建和内存溢出异常" class="headerlink" title="3 对象创建和内存溢出异常"></a>3 对象创建和内存溢出异常</h1><blockquote><p>参考《深入理解Java虚拟机》</p></blockquote><h2 id="3-1-new一个对象"><a href="#3-1-new一个对象" class="headerlink" title="3.1 new一个对象"></a>3.1 new一个对象</h2><h3 id="3-1-1-new一个对象的过程【背诵】"><a href="#3-1-1-new一个对象的过程【背诵】" class="headerlink" title="3.1.1 new一个对象的过程【背诵】"></a>3.1.1 new一个对象的过程【背诵】</h3><p>1 类加载检查</p><p> 当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能在常量池中能否定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、连接和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>2 在堆区分配对象需要的内存</p><ul><li>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</li><li>分配堆内存有两种方式：分别是 指针碰撞和空闲列表（根据使用何种垃圾回收器而定）</li><li>解决分配堆内存时可能出现的并发问题，两种方式解决：CAS+失败重试保证原子性 和 TLAB本地线程分配缓冲</li></ul><p>3 将分配到的内存空间初始化为零值（不包括对象头），然后将对象类的元信息、哈希码、GC分代年龄等信息放入对象头中（即JVM设置对象头）</p><p>4 最后才将对象初始化，将对象按程序员的意愿赋值，完成对象的创建</p><p>5 最后，如果还用对象的引用的话，就在栈区定义引用变量，将堆区对象的地址赋值给它</p><h3 id="3-1-2-分配堆内存的方式和并发问题"><a href="#3-1-2-分配堆内存的方式和并发问题" class="headerlink" title="3.1.2 分配堆内存的方式和并发问题"></a>3.1.2 分配堆内存的方式和并发问题</h3><p><strong>1 分配堆内存的方式</strong></p><p>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式：</p><ul><li><p>1.指针碰撞（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p></li><li><p>2.空闲列表（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。</p></li></ul><p>Java堆是否规整由采用何种垃圾回收器决定：</p><ul><li>使用Serial、ParNew垃圾回收器时，使用复制算法时一般是指针碰撞</li><li>使用CMS基于标记-清除的算法时，一般时空闲列表</li></ul><p><strong>2 解决分配堆内存时可能出现的并发问题</strong></p><p>除了如何划分可用空间外，在并发情况下划分不一定是线程安全的，有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，解决这个问题两种方案：</p><ul><li><p>1.分配内存空间的动作进行同步处理：实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。</p></li><li><p>2.内存分配的动作按照线程划分在不同的空间中进行：为每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。</p></li></ul><h3 id="3-1-3-对象的内存布局"><a href="#3-1-3-对象的内存布局" class="headerlink" title="3.1.3 对象的内存布局"></a>3.1.3 对象的内存布局</h3><p>  在HotSpot虚拟机中，对象在内存中的存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）.</p><p><strong>对象头</strong></p><ul><li><p>1 第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。</p></li><li><p>2 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象的哪个实例。</p></li></ul><p><strong>实例数据</strong></p><p>对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p><strong>对齐填充</strong></p><p>对齐填充不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</p><h2 id="3-2-内存溢出-out-of-menmery【重点】"><a href="#3-2-内存溢出-out-of-menmery【重点】" class="headerlink" title="3.2 内存溢出 out of menmery【重点】"></a>3.2 内存溢出 out of menmery【重点】</h2><blockquote><p>内存溢出（OutOfMemory）：没有足够的空间来供jvm分配新的内存块<br>内存泄露（Memory Leak）：已经分配好的内存或对象，当不再需要，没有得到释放</p></blockquote><p>在java虚拟机规范的描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有可能发生内存溢出异常的可能。分别有：Java堆的溢出、虚拟机栈和本地方法栈的溢出、方法区和运行时常量池的溢出、本机直接内存的溢出。</p><h3 id="1-Java堆的溢出"><a href="#1-Java堆的溢出" class="headerlink" title="1 Java堆的溢出"></a>1 Java堆的溢出</h3><p><strong>定义：</strong></p><ul><li>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机 制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</li></ul><p><strong>解决：</strong></p><p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，一般先用工具判断到底是出现了内存泄漏还是内存溢出问题</p><ul><li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。判断哪些对象无法自动回收，定位出泄漏代码的位置</li><li>如果不存在泄露，那就应当检查虚拟机的<strong>堆参数（-Xmx 与-Xms）</strong>，与机器物理内存对比看是否还可以调大</li></ul><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h3><p><strong>原因：</strong></p><ul><li><p>1 栈溢出的原因一般是循环调用方法导致栈帧不断增多，栈深度不断增加，最终没有内存可以分配，出现StackOverflowError。</p></li><li><p>2 也有可能是建立了过多的线程导致的内存溢出</p></li></ul><p><strong>解决：</strong></p><ul><li>如果是单线程递归照成的栈溢出，需要检查代码的循环调用是否有问题</li><li>如果是多线程导致的溢出，在不能减少线程数或者更换64位 虚拟机的情况下，就只能通过<strong>减少最大堆和减少栈容量</strong>来换取更多的线程（即增多栈内存的个数）。</li></ul><h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h3><p><strong>原因：</strong></p><ul><li>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。分配内存不够时会溢出</li></ul><p><strong>解决：</strong></p><ul><li>手动设置最大永久代（MaxPermSize）大小</li></ul><h1 id="4-JVM调优"><a href="#4-JVM调优" class="headerlink" title="4 JVM调优"></a>4 JVM调优</h1><blockquote><p>调优这里暂时就先不看了，先了解一些常用的参数</p><p>详细请参考<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a>的第四部分</p></blockquote><h2 id="4-1-JVM常用参数"><a href="#4-1-JVM常用参数" class="headerlink" title="4.1 JVM常用参数"></a>4.1 JVM常用参数</h2><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><strong>-Xms</strong></td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置永久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td><strong>-XX:MaxPermSize</strong></td><td>设置永久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td><strong>-Xss</strong></td><td>每个线程的（堆）栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr></tbody></table><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值 和 初始java堆最小值</p><p>（Xmx默认值是物理内存的1/4(&lt;1GB)）（Xms默认值是物理内存的1/64(&lt;1GB))</p><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，默认空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。（40% 70%的比例也是可以指定的）</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整Survivor区和Eden区的比值"><a href="#4-3-调整Survivor区和Eden区的比值" class="headerlink" title="4.3 调整Survivor区和Eden区的比值"></a>4.3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值 （一般8：1：1）</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><h3 id="4-7-JVM的栈参数调优"><a href="#4-7-JVM的栈参数调优" class="headerlink" title="4.7 JVM的栈参数调优"></a>4.7 JVM的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JVM思路大赏。通俗易懂！极简。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="JVM" scheme="https://wukang555.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java集合初探</title>
    <link href="https://wukang555.github.io/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://wukang555.github.io/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/</id>
    <published>2021-07-27T14:55:00.000Z</published>
    <updated>2022-05-17T12:17:19.282Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合初探面经。</p><a id="more"></a><h1 id="Java集合初探"><a href="#Java集合初探" class="headerlink" title="Java集合初探"></a>Java集合初探</h1><blockquote><p>集合值得花单独的一篇来讲</p><p>先要了解整个集合的而体系，由什么接口或者父类实现继承而来</p><p>几个常用集合如何分类、底层原理、扩容原理、线程安全</p></blockquote><h1 id="1-java中的集合体系"><a href="#1-java中的集合体系" class="headerlink" title="1 java中的集合体系"></a>1 java中的集合体系</h1><blockquote><p>[1] 此小节参考了库森的<a href="https://github.com/cosen1024/Java-Interview">面试小抄</a></p><p>简单的来讲分为Collection和Map两个体系，list、set、queue都是实现Collection接口的集合类。</p><p><strong>注意：Collection是一个接口，Map不是Collection的子接口</strong>。Collections是一个静态工具类，里面包含对集合的各种操作方法。</p></blockquote><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。</p><p><strong>List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</strong></p><p><strong>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</strong></p><p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212339.png" alt="img"></p><p><img src="/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/image-20210403163751501.png" alt="image-20210403163751501"></p><h1 id="2-讲讲ArrayList和LinkedList"><a href="#2-讲讲ArrayList和LinkedList" class="headerlink" title="2 讲讲ArrayList和LinkedList"></a>2 讲讲ArrayList和LinkedList</h1><p>ArrayList和LinkedList都是实现了List接口的类，他们都是元素的容器，用于存放对象的引用，并可以对存放的元素进行增删改查的操作，还可以进行排序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,(o1,o2)-&gt;(o2-o1)); <span class="comment">//list数组，递减排序</span></span><br></pre></td></tr></table></figure><h2 id="2-1-ArrayList介绍"><a href="#2-1-ArrayList介绍" class="headerlink" title="2.1 ArrayList介绍"></a>2.1 ArrayList介绍</h2><p>1 实现机制</p><ul><li>内部使用数组的形式实现存储，实现了RandomAccess接口，利用数组的下标进行元素的访问，因此对元素的随机访问速度特别快。</li><li>但是进行元素插入的时候，需要移动插入位置之后的所有元素，位置越靠前，需要位移的元素越多，开销越大；</li></ul><p>2 适用场景</p><ul><li>ArrayList适用在查找多,增删少的场景。如果元素的增删总是发生在数组的尾部，那么也可以选择ArrayList</li></ul><p>3 扩容机制</p><ul><li>ArrayList在初始化的时候，有初始大小10，插入新元素的时候，会判断是否需要扩容，扩容的步长是0.5倍原容量，扩容方式是利用数组的复制，因此有一定的开销；</li></ul><h2 id="2-2-LinkedList介绍"><a href="#2-2-LinkedList介绍" class="headerlink" title="2.2 LinkedList介绍"></a>2.2 LinkedList介绍</h2><p>1 实现机制</p><ul><li>内部使用双向链表的结构实现存储。因此对元素增删改速度更快，直接操作链表指针即可。</li><li>LinkedList的随机访问速度惨不忍睹，因为无论你要访问哪一个元素，都需要从head起步正向或反向的进行元素遍历；</li><li>之所以采用双向链表而非单链表实现，也是采用了空间换性能的方式，来降低查询操作的时间复杂度。如果采用单链表实现只能从头至尾遍历查找，时间复杂度是O(n)；但采用双链表实现，根据当前链表中实际结点个数size和要查找的索引进行比较，选择正向或者反向遍历。这种查找算法会比单链表从头至尾遍历减少一半的查找时间，提高了查找性能</li></ul><p>2 适用场景</p><ul><li>LinkedList适用在增删多,查找少的场景。（长链表情景下查询尤其缓慢）</li></ul><p>3 扩容机制</p><ul><li>LinkedList的元素并不需要连续存放，但是每个存放元素的单元比元素本身需要更大的空间，因此LinkedList对空间的要求比较大，但是扩容的时候不需要进行数组复制，因此没有这一环节的开销。</li></ul><h2 id="2-3-ArrayList-与-Vector-区别？"><a href="#2-3-ArrayList-与-Vector-区别？" class="headerlink" title="2.3 ArrayList 与 Vector 区别？"></a>2.3 ArrayList 与 Vector 区别？</h2><ul><li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li></ul><h1 id="3-讲讲HashMap和ConcurrentHashMap"><a href="#3-讲讲HashMap和ConcurrentHashMap" class="headerlink" title="3 讲讲HashMap和ConcurrentHashMap"></a>3 讲讲HashMap和ConcurrentHashMap</h1><blockquote><p>JDK8在JDK7的基础上做了较大的调整，以JDK7为基础讲解，然后提及JDK8的改进</p></blockquote><h2 id="3-1-JDK7中的Map集合"><a href="#3-1-JDK7中的Map集合" class="headerlink" title="3.1 JDK7中的Map集合"></a>3.1 JDK7中的Map集合</h2><p><strong>1 HashMap</strong></p><ul><li>在JDK8以前的HashMap是通过数组 + 链表的数据结构实现的。数组中的每一个元素都是一个包含键值对以及一个next指针的Entry对象，通过int index =key.hashCode()&amp;(length-1) （与运算）得到数组的下标索引，从而将键值对映射到数组的不同槽位。当发生哈希碰撞时（就是键的hash值相等），新节点经过头插法插入链表中。</li><li>但是当具体相同Hash值的Key较多的时候，链表的长度将会很长，导致查询效率极其低下</li><li>扩容机制：hashmap的初始容量16，当需要执行Resize()扩容时，会执行一个ReHash操作，ReHash在并发的情况下有可能使链表成环，因此是线程不安全的。</li></ul><p><strong>2 ConcurrentHashMap</strong></p><ul><li><p>ConcurrentHashMap就是为了解决hashmap线程不安全的问题，JDK8之前的ConcurrentHashMap是采用锁分段技术实现了线程安全。相当于将HashMap中的table数组拆分成若干个分段数组，每一个Segment管理table数组的一个区间。Segment继承了ReentrantLock可重入锁，一个Segment就是一把锁。当对table数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p></li><li><p>这种方式是一种粗粒度的并发控制方案，当两个操作位于不同的两个段时可以不受线程安全的影响，但是位于同一个数组段的不同槽位的更新操作依然会受到并发控制的互斥限制</p></li></ul><h2 id="3-2-JDK8中的Map集合"><a href="#3-2-JDK8中的Map集合" class="headerlink" title="3.2 JDK8中的Map集合"></a>3.2 JDK8中的Map集合</h2><blockquote><p>HashMap和ConcurrentHashMap的实现都做了大的调整</p></blockquote><p><strong>1 HashMap</strong></p><ul><li>HashMap主要对长链表时查询缓慢的问题进行了改进，主要就是将长链表换成了红黑树。因此JDK8的HashMap采用了数组+短链表+红黑树的数据结构实现，在链表的长度超过8个节点的时候，将会将链表通过旋转的方式直接转换成红黑树（称之为树化），红黑树的引入在查询效率上至少提升了2倍以上。</li><li>JDK8的HashMap的table数组元素是由一个个Node或TreeNode节点组成，红黑树对应的数组槽位中始终存储其根节点，对于链表结构，每一次新元素采用“尾插法”插入链表</li><li>JDK8的HashMap对以前版本扩容可能造成环形链的问题进行了修复。但依然可能存在数据覆盖的问题出现，因此依然不是线程安全的。多线程环境下依然需要使用ConcurrentHashMap</li></ul><p><strong>2 ConcurrentHashMap</strong></p><ul><li>JDK8的ConcurrentHashMap则将分段锁的概念细划到单个的数组槽位上，即一个table数组槽位一个锁，因此只有更新操作具有相同hash值的线程之间才会存在竞争。JDK8抛弃分段锁不但节省了不必要的空间消耗，而且用回了传统的synchronized关键字的重量级锁。</li><li>ConcurrentHashMap内部维护了一个0.75的加载因子，也就是每当内部的数组占用率达到75%的时候就会将数组扩容至原来的2倍大小，并将原来的所有元素拷贝到新数组中，拷贝的时候为了充分利用里面多出来的空间，和提高查询搜索速度，会将一些长链表或红黑树拆分成两个体积更小的链表或红黑树分别存放于新数组的原位置和原位置+原数组长度的位置</li><li>ConcurrentHashMap的优化使扩容可以由多个参与线程一起辅助完成，从而减小时间消耗，但扩容本身还是是开销比较大操作，尽量在使用之前就确定大概需要的容量</li></ul><h2 id="3-3-ConcurrentHashMap的并发"><a href="#3-3-ConcurrentHashMap的并发" class="headerlink" title="3.3 ConcurrentHashMap的并发"></a>3.3 ConcurrentHashMap的并发</h2><p><strong>1 ConcurrentHashMap 的 get 方法是否要加锁，为什么？</strong></p><ul><li>get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</li></ul><p><strong>2 哈希桶<code>table</code>用volatile修饰的原因？</strong></p><ul><li>哈希桶<code>table</code>用volatile修饰主要是保证在数组扩容的时候保证可见性。</li></ul><p><strong>3 ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？</strong></p><ul><li>我们先来说value 为什么不能为 null ，因为<code>ConcurrentHashMap </code>是用于多线程的 ，如果<code>map.get(key)</code>得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。而用于单线程状态的<code>HashMap</code>却可以用<code>containsKey(key)</code> 去判断到底是否包含了这个 null 。</li><li>（不支持key为null，是规定，就这么设计的）</li></ul><h2 id="3-4-其他map集合和Set集合"><a href="#3-4-其他map集合和Set集合" class="headerlink" title="3.4 其他map集合和Set集合"></a>3.4 其他map集合和Set集合</h2><p><strong>1 TreeMap和LinkedHashMap区别</strong></p><ul><li>LinkedHashMap 拥有 HashMap 的所有特性，它比 HashMap 多维护了一个双向链表，保证了元素是按照插入的顺序排列。是有序的，</li><li> TreeMap 的底层就是一颗红黑树，它的 containsKey , get , put and remove 方法的时间复杂度是 log(n) ，并且它是按照 key 的自然顺序（或者指定排序）排列</li></ul><p><strong>2 ConcurrentHashMap与HashTable的区别</strong></p><ul><li>都是线程安全的Map集合类，都用synchronized关键字来实现同步</li><li>ConcurrentHashMap锁的方式是稍微细粒度的，锁一个数组元素；</li><li>HashTable直接锁整个数组，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</li></ul><p><strong>3 HashSet的实现</strong></p><ul><li>HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。</li><li>HashMap的K值本身就不允许重复，就可以实现set集合的不重复的性质</li></ul><h1 id="4-集合的遍历"><a href="#4-集合的遍历" class="headerlink" title="4 集合的遍历"></a>4 集合的遍历</h1><blockquote><p>[1] 参考了这篇<a href="https://blog.csdn.net/scgyus/article/details/79105211?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-11.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-11.searchformbaiduhighlight">HashMap遍历的四种方式</a></p></blockquote><p>这里主要介绍map集合的4种遍历方式。list集合的遍历大概三种：1用索引get(i)方法遍历、2用增强for遍历、3用迭代器遍历。后两种map中都有体现、而第一种比较简单，不需要讲。</p><p><strong>1 map集合的三种遍历方式</strong></p><p>map集合的三种遍历方式分别是：1 keySet()搜索value、 2 entrySet()遍历键和值 3迭代器Iterator。三种方法各有优缺点（建议第二种）</p><ul><li>1 keySet()搜索value，在使用上更简单，但是通过key来查找value是耗时的操作。所以是一个低效的遍历（不推荐）</li><li>2 entrySet()遍历键和值，一般情况下推荐使用这种。</li><li>3迭代器Iterator，迭代器使用上虽然复杂，但是是老版本遍历map的唯一选择。并且<strong>只有使用迭代器才可以在迭代的时候从map中删除entry</strong>（通过调用iterator.remover()方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;bb&quot;</span>,<span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 keySet()增强for遍历、实际上keySet()出来就是一个set集合</span></span><br><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只遍历value,可以用values()获得值得集合</span></span><br><span class="line"><span class="keyword">for</span> (Integer i:map.values())&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 entrySet()遍历键和值、实际上map.entrySet()出来就是一个Entry对象得set集合</span></span><br><span class="line"><span class="comment">//Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 迭代器遍历 实际上是迭代器遍历set集合（迭代器可以遍历所有的集合）</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 foreach和Iterator的关系</strong></p><p>foreach是jdk5新增加的一个循环结构，其本身就是由iterator实现的。相当于是做了一层简单的封装，使遍历的语法更简洁了，但是并不是继承了iterator的所有方法。</p><p>foreach和iterator最大的不同之处就在于remove()方法上</p><ul><li>iterator的remove()方法，不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态。比如不能连续两次调用remove()，至少间隔一次next()方法</li><li>foreach中删除元素、直接报错。即<strong>快速失败（fail—fast）</strong> 机制</li></ul><p><strong>3 使用for循环与使用迭代器iterator的对比</strong></p><ul><li>for循环适合于支持随机访问的集合，比如ArrayList。效率更高</li><li>iterator迭代适合于链式的顺序结构，比如LinkedList。效率更高</li></ul><h1 id="5-其他数据结构"><a href="#5-其他数据结构" class="headerlink" title="5 其他数据结构"></a>5 其他数据结构</h1><h2 id="5-1-各种树形结构及其特点"><a href="#5-1-各种树形结构及其特点" class="headerlink" title="5.1 各种树形结构及其特点"></a>5.1 各种树形结构及其特点</h2><ul><li><p>二叉查找树</p></li><li><p>左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大</p></li><li><p>缺点：正常的情况下，查找的时间复杂度为 O（logn）。但极端情况退化为链表，时间复杂度为O(n)</p></li><li><p>平衡二叉树</p><ul><li><p>是二叉查找树，并且要求左右子树树高差严格不超过1。</p></li><li><p>缺点：查询效率很高，但插入和删除的效率低，因为需要通过旋转来保证严格的平衡，过多的旋转是耗时的</p></li></ul></li><li><p>红黑树</p><ul><li>红黑树是一种弱平衡二叉树，通过对各个结点着色，仅保证没有一条路径会比其它路径长出两倍。相对于要求严格的AVL树来说，它的旋转次数少，适合增删多的场景。红黑树高度是O(log(n)).</li></ul></li><li><p>B树</p><ul><li><p>平衡多路查找树：有j个孩子的非叶结点恰好有j-1个关键码，关键码按递增次序排列</p></li><li><p>适用场景</p><ul><li>B树多用于做文件系统的索引。文件太大的话无法一次加载到内存，使用B树可以多路储存，每次只加载一个结点来查找。</li></ul></li><li><p>B+树，类似于B树的升级版本，数据都存放在叶子节点上。适合做索引、特别是顺序查找和范围查找</p></li></ul></li></ul><h2 id="5-2-位图"><a href="#5-2-位图" class="headerlink" title="5.2 位图"></a>5.2 位图</h2><blockquote><p>其实就是桶数组的思想，每一个bit位作为一个桶。01表示存在或者不存在。</p><p> int的范围是-21亿到21亿之间，用位图的话 其实就是桶数组，存int相当于至少要42亿的坑位，42亿/32  相当于 1.2亿个byte。大约600Mb左右的内存。（10亿 1e9个byte约10G）</p><p>long范围-9200亿亿到9200亿亿，位图不可能放的下。所以数据的状态不能过多！！</p></blockquote><p><strong>位图，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</strong></p><p>，数组的每一个元素的每一个二进制位都可以表示一个数据在或者不在，0表示数据存在，1表示数据不存在。因为比特位只有两种状态，要不是0，要不就是1，所以位图其实就是一种直接定址法的哈希，只不过位图只能表示这个值在或者不在。</p><p>赋值操作：（和该位为1的数）按位或将对应比特位置为1</p><p>删除操作：先取反，然后（和0）按位与，将对应比特位置0</p><p>判断是否存在：（和该位为1的数）按位与，结果不为0，说明对应位置存在！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java集合初探面经。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="集合" scheme="https://wukang555.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java基础小解</title>
    <link href="https://wukang555.github.io/2021/07/26/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://wukang555.github.io/2021/07/26/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-26T14:55:00.000Z</published>
    <updated>2022-05-17T12:16:56.043Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础小解面经。</p><a id="more"></a><h1 id="Java基础小解"><a href="#Java基础小解" class="headerlink" title="Java基础小解"></a>Java基础小解</h1><blockquote><p>面完网易，发现自己整个知识体系还没没完全搭建起来，java基础这块差的太多了。赶紧补回来！！</p><p>主要参考库森的面经（真的非常全面且细致）、再看了一下Guide和Cyc2018的笔记，其实java基础也是分模块并且可以成为体系来记忆的。所以先整理：</p><p>Cyc2018的分类：数据类型（基本、包装）、String、关键字、Object方法、继承、反射、异常、泛型、注解、新版本特性</p><p>简单的对库森面经的分类做了一点调整：java语言特点（字节码编译）、面向对象（特性、重载重写、抽象类、接口）、Object类的方法（equals hashcode）、基本语法（修饰符、关键字final/static、数据类型）、String相关、反射、泛型、序列化、异常、IO、新版本特性</p></blockquote><p>总体可以分为几部分：</p><p>1 java语言的特点 特别是面向对象的思想</p><p>2 java语言的一些基本类和基本语法，如Object类、关键字、修饰符、String类、基本数据类型</p><p>3 还要java的泛型、序列化、IO的定义和原理</p><p>4 最后是java的异常体系、反射功能还有新版本特性的简单介绍</p><h1 id="1-java语言概述"><a href="#1-java语言概述" class="headerlink" title="1 java语言概述"></a>1 java语言概述</h1><blockquote><p>这里直接摘一个百度百科的介绍解释什么是java</p></blockquote><p><strong>Java是一门面向对象编程语言</strong>，Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p><p>显而易见关键字就是“面向对象”、“静态语言”。面向对象的在本节中介绍、提高静态语言灵活性的反射机制将在本文最后介绍。</p><h2 id="1-1-面向对象的语言"><a href="#1-1-面向对象的语言" class="headerlink" title="1.1 面向对象的语言"></a>1.1 面向对象的语言</h2><p><strong>1 面向对象和面向过程的区别？</strong></p><p>面向对象指考虑问题时，以对象为单位。 将一般的客观事物和它们之间的关系抽象为具体的类，考虑他们的属性和方法。目的主要是模块化开发和拥抱程序可能发生的变化，更适合大型复杂的系统。但因为类的调用需要实例化，性能较面向过程低。</p><p>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 。面向过程一般适用于系统简单对性能要求高的场景。（单片机、嵌入式开发等）</p><p><strong>2 面向对象的三大特性？</strong></p><p>面向对象的三大特性指：封装、继承和多态</p><p>1 封装：用大白话来讲就是，封装就是将自己类内部的变量、方法设为私有、不允许外部类直接访问。要想访问、就必须通过我指定的get() set()方法来访问。封装和private直接相关。 </p><p>封装好处：</p><ul><li><p>通过方法来控制成员变量的操作，提高了代码的安全性</p></li><li><p>把代码用方法进行封装，提高了代码的复用性</p></li></ul><p>2 继承：用大白话来讲就是，将多个对象共同的部分抽象为一个父类，这些共同的属性直接在父类中定义就可以了，子类继承父类，代码更简洁。比如猫、老虎、豹子都是属于猫科动物，我就直接定义一个猫科动物的父类，这三个家伙直接继承之。</p><ul><li><p>继承好处</p><ul><li><p>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</p></li><li><p>提高了代码的可维护性(如果方法的代码需要修改，只需修改一处即可)</p></li></ul></li></ul><p>3 多态：指同一个对象，在不同时刻表现出来的不同状态。</p><ul><li><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定（set方法可以改变行为）</p></li></ul></li><li><p>运行时多态有三个条件</p><ul><li><p>继承</p><ul><li>狗和猫都继承动物类</li></ul></li><li><p>覆盖（重写）</p><ul><li>狗和猫都重写动物类的eat方法</li></ul></li><li><p>向上转型</p><ul><li><p>在main方法中使用动物对象的引用来调用狗和猫对象</p></li><li><p>调用动物的eat()方法时，实际会执行狗和猫的eat()方法</p></li><li><p>例子：花木兰替父从军</p></li></ul></li></ul></li></ul><p><strong>3 重载和重写的区别</strong></p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：指在一个类里面，方法名字相同，而参数不同。每个重载的方法都必须有一个独一无二的参数类型列表。（最常用的就是构造器的重载）</p><p>重写：指子类重写父类的方法（形参和返回值都不能变），一般子类需要重写父类的抽象方法。</p><blockquote><p>构造器只能重载而不能重写（覆盖），子类不能覆盖父类的构造函数、因为在类加载是子类需要先加载调用父类的构造方法</p></blockquote><p><strong>4 抽象类和接口的区别</strong></p><ul><li>从设计上来说，抽象类是为了继承而存在的，继承是一个 “是不是”的is关系。而 接口的实现则是 “有没有”的has关系。一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>从语法层面上讲：<ul><li>抽象类可以有普通成员变量、构造方法、非抽象的方法、静态方法；而接口只能有抽象方法</li><li>抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型的静态变量，方法只能是public abstract类型的</li></ul></li></ul><p><strong>5 java创建对象的四种方式</strong></p><p>java中提供了以下四种创建对象的方式: <strong>1 new创建新对象；2 通过反射机制；3 采用clone机制；4 通过序列化机制。</strong></p><p>前两者都需要显式地调用构造方法。对于clone机制，需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><p><strong>6 深拷贝和浅拷贝、深复制和浅复制？？</strong></p><p>浅拷贝是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝，没有对引用指向的对象进行拷贝。</p><p>深拷贝是指在拷贝对象时，同时会对引用指向的对象进行拷贝。</p><p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有对其他对象的引用仍然指向原来的对象，及浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p>深复制：把复制对象所引用的对象都复制了一遍</p><h2 id="1-2-java语言的优点及其实现"><a href="#1-2-java语言的优点及其实现" class="headerlink" title="1.2 java语言的优点及其实现"></a>1.2 java语言的优点及其实现</h2><blockquote><p>java文件编译成字节码，字节码加载到JVM上生成机器代码，然后执行</p><p>java语言的优点其实大多是都是基于JVM的特性。JVM那篇文章将的更底层一些</p><p>三个特点：平台无关性、内存管理垃圾处理、热点代码监测和编译</p></blockquote><p><strong>1 java语言的优点</strong></p><ul><li><p>“一次编译，到处执行” 平台无关性。</p></li><li><p>相对安全的内存管理和访问机制、避免大部分内存泄露和指针越界</p></li><li><p>Java具有热点代码检测和运行时编译优化的功能、能够使程序运行时获得更高的性能</p></li><li><p>完善的API接口、支持第三方类库</p></li></ul><p><strong>2 java如何实现平台无关</strong></p><ul><li>1 java编译的字节码文件 class文件是平台无关的，class文件再由JVM动态转换就可以变为本地的机器代码。。也就是说虽然JVM是平台有关的（不同操作系统、机器上的jvm版本是不同的），但对开发人员来说是平台无关的。编译生成的字节码文件是可以到处运行的</li><li>2 java数据结构的统一性，基本数据类型的大小有明确的规定，比如int永远是32位。但c/c++里面可以是16也可以是32</li></ul><p><strong>3 java如何实现运行时按需编译</strong></p><p>在运行时按需编译的方式就是Just In Time，通过JIT线程实现。运行时编译分为两种方式：解释执行和热点方法</p><ul><li><p>解释执行指的是逐条执行。JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p></li><li><p>热点方法就是把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。让CPU直接执行。这样编出来的代码效率会更高。</p></li><li><p>JIT线程与垃圾回收线程都是守护线程中的一种，守护线程提供一些系统性的功能服务，与普通线程不同，当一个java应用内只有守护线程时，java虚拟机会自然退出。</p></li></ul><h1 id="2-java用语言的基本语法"><a href="#2-java用语言的基本语法" class="headerlink" title="2 java用语言的基本语法"></a>2 java用语言的基本语法</h1><blockquote><p> java语言的一些基本类和基本语法，如Object类、关键字、修饰符、String类、基本数据类型</p></blockquote><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><blockquote><p>Java 语言的数据类型分为两种：基本数据类型和引用数据类型。</p></blockquote><p><strong>1 八大基本数据类型</strong></p><p>1 整型：byte 1、short 2、int 4、long 8</p><p>2 浮点型：float 4、double 8</p><p>3 字符型：char 2</p><p>4 非数值型（布尔型）：boolean 1</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212315.png" alt="image-20210907131202579" style="zoom: 67%;"><p><strong>2 数据类型的转换</strong></p><ul><li>自动类型转换：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</li><li>强制类型转换：强制显示的把一个数据类型转换为另外一种数据类型。（超过范围会无意义）</li></ul><h2 id="2-2-包装类型"><a href="#2-2-包装类型" class="headerlink" title="2.2 包装类型"></a>2.2 包装类型</h2><p><strong>1 包装类型是什么？基本类型和包装类型有什么区别？</strong></p><p>包装类型实质上是一个对象的引用，Java 为每一个基本数据类型都引入了对应的包装类型。</p><ul><li><p>原始类型: boolean，char，byte，short，int，long，float，double</p></li><li><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></li></ul><p>基本类型和包装类型的区别：</p><ul><li>包装类型可以为 null，而基本类型不可以。容器中一般只能放包装类型</li><li>包装类型可用于泛型，而基本类型不可以。泛型在编译时会进行类型擦除</li><li>基本类型比包装类型更高效，<strong>基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用</strong>。</li></ul><p><strong>2 两个Integer对象的对比（==）</strong></p><ul><li><p>两个new生成的Integer变量的对比：不等</p><ul><li>都指向堆中的对象，比较的是地址，所以一定不等</li><li>非要比较，引用类型推荐用 equals()</li></ul></li><li><p>非new生成的Integer变量和 new Integer()生成变量的对比：不相等</p><ul><li>非new得Integer指向常量池；而new出来得Integer指向堆中那个新建的Integer对象</li></ul></li><li><p>两个非new生成的Integer对象的对比：在-128-127范围内相等、范围外不等</p><ul><li>因为会缓存-128-127范围内Integer对象的值</li><li>超过范围将重新new一个Integer给新建的对象</li></ul></li><li><p>Integer对象和int比较：相等</p><ul><li>因为会自动拆箱之后在比较大小</li></ul></li></ul><h2 id="2-3-String类【重要】"><a href="#2-3-String类【重要】" class="headerlink" title="2.3 String类【重要】"></a>2.3 String类【重要】</h2><p>String 被声明为 final，是一个不可变的字符串类型。在 Java 8 中，String 内部使用 char 数组存储数据。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串。</p><p><strong>1 不可变的好处（4 个好处）</strong></p><p>可以缓存 hash 值</p><ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得hash 值也不可变，因此只需要进行一次计算。</li></ul><p>String Pool 的需要</p><ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul><p>安全性</p><ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，收到改变后 String 对象的那一方会以为现在连接的是其它主机，而实际情况却不一定是。</li></ul><p>线程安全</p><ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul><p><strong>2 String Pool</strong></p><p>jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护一个字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中（防止永久代溢出）。JDK8之后，永久代被元空间取代了。</p><p><strong>3 new String（“aaa”）</strong></p><ul><li>使用<code>String a = “aaa” ;</code>，程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。</li><li>使用<code>String b = new String(&quot;aaa&quot;);</code>，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。</li><li>intern()函数的作用是将对应的符号常量进入特殊处理。在JDK1.6以前是将字符串放入常量池 ；JDK1.7以后如果存在引用就将改字符串的引用放入常量池，下次取得时候其实取得是引用地址。</li></ul><p><strong>4 String，StringBuffer 和 StringBuilder</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuffer 字符串变量，线程安全，内部使用synchronized关键字进行同步</li><li>StringBuilder 字符串变量 线程不安全 效率比StringBuffer高</li></ul><h2 id="2-4-Object类【重要】"><a href="#2-4-Object类【重要】" class="headerlink" title="2.4 Object类【重要】"></a>2.4 Object类【重要】</h2><blockquote><p>所有类的老老老老祖宗，一些通用方法十分重要</p><p>**hashCode()、equals(Object obj)、clone()、toString()**、getClass()、finalize()</p><p><strong>notify()、notifyAll()、wait()</strong></p></blockquote><p><strong>1 hashCode()方法</strong></p><p>hashCode() 的作用是获取对象的哈希码，也称为散列码；它实际上是返回一个int整数。</p><p>一般要求等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p><strong>2 equals(Object obj)方法</strong></p><p>equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象。一般有两种使用情况：</p><ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象（比较引用对象的地址值，基本类型的大小值）。</li><li>情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来判断两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li></ul><p>java语言规范要求equals方法具有以下特性：</p><ul><li>自反性 x.equals(x); // true</li><li>对称性。当且仅当x.equals(y)是true时，y.equals(x)也是true。</li><li>传递性。如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。</li><li>一致性。如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)返回值一致</li><li>与 null 比较为false ，x.equals(null); // false;</li><li>一般重写equals()方法是，要求也重写hashcode()方法</li></ul><p><strong>3 何时需要重写hashcode和equls方法?【重要】</strong></p><p>a 使用自定义的对象作为key时，重写了hashcode后要重写equls</p><ul><li><p>当用自己定义的对象作为key时，通常需要属性相同就认为这两个键相等</p></li><li><p>如果不重写hashcode，两个属性相同的key，永远不可能映射要一个数组槽位上面(map集合中)</p></li><li><p>如果只重写了hashcode不重写equals，那么映射到正确数组槽位中之后无法找到链表中相等的那个元素</p></li></ul><p>b 重写了equls也要重写hashcode</p><ul><li><p>因为规定equals相等的两个对象要hashcode也要一定相同</p></li><li><p>所以我们一般会先用hashcode计算hash值，来实现快速判重！！</p></li><li><p>如果hashcode相同了我们再判断equals的逻辑</p></li></ul><p><strong>4 toString()方法</strong></p><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列值的无符号十六进制<br>表示。</p><h2 id="2-5-访问修饰符"><a href="#2-5-访问修饰符" class="headerlink" title="2.5 访问修饰符"></a>2.5 访问修饰符</h2><blockquote><p>访问修饰符: public、private、protected、默认</p></blockquote><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212319.png" alt="image-20210907161619357" style="zoom:80%;"><h2 id="2-6-Java关键字"><a href="#2-6-Java关键字" class="headerlink" title="2.6 Java关键字"></a>2.6 Java关键字</h2><blockquote><p>static、abstract、final、</p></blockquote><h3 id="2-6-1-static关键字【重点】"><a href="#2-6-1-static关键字【重点】" class="headerlink" title="2.6.1 static关键字【重点】"></a>2.6.1 static关键字【重点】</h3><p><strong>“static”关键字表明一个成员变量或者是成员方法可以在没有创建该实例对象的情况下被访问。</strong></p><p>因为静态对象在虚拟机加载所属类的对象时，就已经分配了储存空间并且初始化。（联系类的加载过程）</p><p><strong>问题一：static方法是否可以被重写</strong></p><ul><li>static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。</li></ul><p><strong>问题二：static环境为什么不能访问非static变量</strong></p><ul><li>当类被Java虚拟机载入的时候，会对static变量进行初始化。而此时非静态变量的实例还没有被创建出来（new了之后才有啊），如果不用实例访问非静态变量，编译器就会报错</li></ul><p><strong>问题三：类中代码块执行顺序是什么？【重要】</strong></p><ul><li>基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块</li><li>代码块执行顺序<strong>静态代码块——&gt; 构造代码块（除了{}什么都没加的代码块） ——&gt; 构造函数——&gt; 普通代码块</strong> </li><li>继承中代码块执行顺序：<strong>父类静态块——&gt;子类静态块——&gt;父类代码块——&gt;父类构造器——&gt;子类代码块——&gt;子类构造器</strong></li></ul><h3 id="2-6-2-final关键字"><a href="#2-6-2-final关键字" class="headerlink" title="2.6.2 final关键字"></a>2.6.2 final关键字</h3><p><strong>final关键字：</strong></p><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写、但子类可以直接使用该方法。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><p><strong>随便了解一下：finally、finalize</strong></p><ul><li>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行，经常用于释放资源。（<code>System.exit (0)</code> 可以阻断其执行）</li><li>finalize 是在 <code>java.lang.Object</code> 里定义的方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</li></ul><h1 id="3-泛型、序列化和IO"><a href="#3-泛型、序列化和IO" class="headerlink" title="3 泛型、序列化和IO"></a>3 泛型、序列化和IO</h1><blockquote><p>还要了解java的泛型、序列化、IO的定义和原理</p><p>java IO好像时挺重要的一块内容，要单独开篇文章来讲….但现在我还一点都不了解、先简单看看</p></blockquote><h2 id="3-1-泛型"><a href="#3-1-泛型" class="headerlink" title="3.1 泛型"></a>3.1 泛型</h2><p>泛型是 JDK1.5 的一个新特性，<strong>泛型就是将类型参数化，其在编译时才确定具体的参数。</strong></p><p>根据《Java 编程思想》中的描述，泛型出现的动机在于：有许多原因促成了泛型的出现，而最引人注意的一个原因，就是<strong>为了创建容器类</strong>。</p><p><strong>1 使用泛型的好处</strong></p><p>先来看看不使用泛型，利用Object来实现不同类型的处理，存在两个缺点：</p><ul><li>每次使用时都需要强制转换成想要的类型</li><li>在编译时编译器并不知道类型转换是否正常，运行时才知道，不够安全。</li></ul><p>所以泛型的好处如下：</p><ol><li><p>类型安全 </p><ul><li>泛型的主要目标是提高 Java 程序的类型安全</li><li>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常，符合越早出错代价越小原则</li></ul></li><li><p>消除强制类型转换 </p><ul><li>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换</li><li>所得即所需，这使得代码更加可读，并且减少了出错机会</li></ul></li><li><p>潜在的性能收益 </p><ul><li>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改</li><li>所有工作都在编译器中完成（编译期间就确定了真正的类型）</li><li>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已</li></ul></li></ol><p><strong>2 泛型的原理是什么 ? 什么是类型擦除 ?</strong></p><p>泛型的基本原理就是类型擦除。类型擦除指：使用泛型的时候加上的不确定的类型参数(比如<code>&lt;T&gt;</code>这种不确定的类型），编译器在编译的时候去掉类型参数。一般情况下类型擦除时，会用Object类进行替换。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&lt;T&gt; &#123;</span><br><span class="line">    private T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型<code>&lt;T&gt;</code>，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。反编译一下这个 Caculate 类：<strong>发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。</strong>即将类型T差出，并变为了Object类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&#123;</span><br><span class="line">    public Caculate()&#123;&#125;</span><br><span class="line">    private Object num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3 泛型中的限定通配符和非限定通配符</strong></p><ul><li>限定通配符<ul><li><? extends T>它通过确保类型必须是T的子类来设定类型的上界</li><li><? super T>它通过确保类型必须是T的父类来设定类型的下界</li></ul></li><li>非限定通配符<code>&lt;?&gt;</code><ul><li>可以用任意类型来替代。如<code>List&lt;?&gt;</code> 的意思是这个集合是一个可以持有任意类型的集合</li></ul></li></ul><p><strong>4 判断<code>ArrayList&lt;String&gt;</code>与<code>ArrayList&lt;Integer&gt;</code>是否相等？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c1 = a.getClass();</span><br><span class="line">Class c2 = b.getClass();</span><br><span class="line">System.out.println(c1 == c2); </span><br></pre></td></tr></table></figure><p>输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是 ArrayList.class。</p><p>那它们声明时指定的 String 和 Integer 到底体现在哪里呢？</p><p><strong>答案是体现在类编译的时候。</strong>当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。</p><h2 id="3-2-序列化"><a href="#3-2-序列化" class="headerlink" title="3.2 序列化"></a>3.2 序列化</h2><blockquote><p>序列化和反序列化</p></blockquote><h3 id="1-什么是序列化和反序列化"><a href="#1-什么是序列化和反序列化" class="headerlink" title="1 什么是序列化和反序列化"></a>1 什么是序列化和反序列化</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="2-为什么需要序列化与反序列化？"><a href="#2-为什么需要序列化与反序列化？" class="headerlink" title="2 为什么需要序列化与反序列化？"></a>2 为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ul><li><strong>1 对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ul><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><ul><li><strong>2 java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong></li></ul><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行<strong>对象的”深复制”**，即复制对象本身及引用的对象本身。</strong>序列化一个对象可能得到整个对象序列。**</p><ul><li><strong>3 对象序列化可以实现分布式对象。</strong></li></ul><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><h3 id="3-序列化实现的方式有哪些？"><a href="#3-序列化实现的方式有哪些？" class="headerlink" title="3 序列化实现的方式有哪些？"></a>3 序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p><strong>1 Serializable</strong>接口</p><p>类通过实现 <code>java.io.Serializable</code> 接口以启用其序列化功能。可序列化类的所有子类型本身都是可序列化的。<strong>序列化接口没有方法或字段，仅用于标识可序列化的语义。</strong></p><p><strong>2 Externalizable</strong>接口</p><p><code>Externalizable</code>继承自<code>Serializable</code>，该接口中定义了两个抽象方法：<code>writeExternal()</code>与<code>readExternal()</code>。</p><p>当使用<code>Externalizable</code>接口来进行序列化与反序列化的时候需要开发人员重写<code>writeExternal()</code>与<code>readExternal()</code>方法。否则所有变量的值都会变成默认值。</p><p><strong>3 两种序列化的对比</strong></p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="4serialVersionUID是什么？为什么要显示指定它的值"><a href="#4serialVersionUID是什么？为什么要显示指定它的值" class="headerlink" title="4serialVersionUID是什么？为什么要显示指定它的值?"></a>4serialVersionUID是什么？为什么要显示指定它的值?</h3><p>在实际开发中, 我们的类会不断迭代, 一旦类被修改了，那么旧对象的反序列化就会出现问题。serialVersionUID 就是用来表明类的不同版本间的兼容性！！</p><ul><li><p>如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID；在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID。如果此时两个类因版本和属性的不同，那么新旧serialVersionUID不相等，那么将无法完成反序列化。</p></li><li><p>如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.</p></li></ul><p>至于应当什么时候显示的指定其值，阿里巴巴Java开发手册》中有以下规定：</p><ul><li>序列化类新增属性时，请不要修改serialVersionUID，避免反序列化失败</li><li>如果是完全不兼容的升级、请修改serialVersionUID，避免反序列化混乱</li></ul><h3 id="5-不想序列化的字段和静态变量"><a href="#5-不想序列化的字段和静态变量" class="headerlink" title="5 不想序列化的字段和静态变量"></a>5 不想序列化的字段和静态变量</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。在被反序列化后，<code>transient</code> 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。</p><p>静态变量不会被序列化。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.</p><h2 id="3-3-java-IO体系"><a href="#3-3-java-IO体系" class="headerlink" title="3.3 java IO体系"></a>3.3 java IO体系</h2><h3 id="1-Java-中-IO-流分为几种？"><a href="#1-Java-中-IO-流分为几种？" class="headerlink" title="1. Java 中 IO 流分为几种？"></a>1. Java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。（实际应用分别还有字节缓冲流、字符缓冲流）</p><ul><li>字节流按 8 位传输以字节为单位输入输出数据。非纯文本文件，比如图片、视频等应该优先使用字节流。</li><li>字符流按 16 位传输以字符为单位输入输出数据。存文本文件优先使用字符流。</li></ul><h3 id="2-同步-异步-阻塞-非阻塞-IO-的区别？"><a href="#2-同步-异步-阻塞-非阻塞-IO-的区别？" class="headerlink" title="2 同步/异步/阻塞/非阻塞 IO 的区别？"></a>2 同步/异步/阻塞/非阻塞 IO 的区别？</h3><blockquote><p>同步和异步是通信机制（服务端线程本身不处理IO，交由操作系统底层处理IO），阻塞和非阻塞是调用状态（某个连接请求无事干的时候是否可以切除到其他连接请求）。</p></blockquote><ul><li><p>同步 IO 是用户线程发起 IO 请求后需要等待或轮询内核 IO 操作完成后才能继续执行。</p></li><li><p>异步 IO 是用户线程发起 IO 请求后可以继续执行，当内核 IO 操作完成后会通知用户线程，或调用用户线程注册的回调函数。</p></li><li><p>阻塞 IO 是 IO 操作需要彻底完成后才能返回用户空间 。</p></li><li><p>非阻塞 IO 是 IO 操作调用后立即返回一个状态值，无需等 IO 操作彻底完成。</p></li></ul><p>BIO：Block IO 同步阻塞式 IO，传统的IO模型。</p><p>NIO：Non IO 同步非阻塞 IO，实现了多路复用。</p><p>AIO：Asynchronous IO异步非堵塞 IO，基于事件和回调机制。</p><h3 id="3-什么是-BIO？"><a href="#3-什么是-BIO？" class="headerlink" title="3 什么是 BIO？"></a>3 什么是 BIO？</h3><p><strong>BIO</strong> 是同步阻塞式 IO，JDK1.4 之前的 IO 模型。<strong>服务器实现模式为一个连接请求对应一个线程</strong>，服务器需要为每一个客户端请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。适用连接数目少且服务器资源多的场景。</p><h3 id="4-什么是-NIO？"><a href="#4-什么是-NIO？" class="headerlink" title="4 什么是 NIO？"></a>4 什么是 NIO？</h3><p><strong>NIO</strong> 是 JDK1.4 引入的同步非阻塞 IO。<strong>服务器实现模式为多个连接请求对应一个线程</strong>，客户端连接请求会注册到多路复用器 Selector中 ，Selector 轮询到某个连接有 IO 请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p><p>同步是指线程还是要不断接收客户端连接并处理数据，非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道（一个管道对应一个请求）。</p><p>核心组件：</p><ul><li><strong>Buffer：</strong> 缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer 三个重要属性：position 下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。</li><li><strong>Channel：</strong> 双向通道，替换了 BIO 中的 Stream 流，用来存放IO连接请求，要通过 Buffer 来读写数据，也可以和其他 Channel 交互。</li><li><strong>Selector：</strong> 多路复用器，轮询检查多个 Channel 的状态，判断注册事件是否发生，即判断 Channel 是否处于可读或可写状态。使用前需要将 Channel 注册到 Selector，注册后会得到一个 SelectionKey，通过 SelectionKey 获取 Channel 和 Selector 相关信息。</li></ul><h3 id="5-什么是-AIO？-没看太懂"><a href="#5-什么是-AIO？-没看太懂" class="headerlink" title="5 什么是 AIO？(没看太懂)"></a>5 什么是 AIO？(没看太懂)</h3><p>AIO 是 JDK7 引入的异步非阻塞 IO。服务器实现模式为<strong>一个有效请求对应一个线程</strong>，客户端的 IO 请求都是由操作系统先完成 IO 操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p><p><strong>异步是指服务端线程接收到[客户端]管道后就交给底层处理IO通信</strong>，自己可以做其他事情，非阻塞是指[客户端]有数据才会处理，处理好再通知服务器。</p><p>实现方式包括通过 Future 的 <code>get</code> 方法进行阻塞式调用以及实现 CompletionHandler 接口，重写请求成功的回调方法 <code>completed</code> 和请求失败回调方法 <code>failed</code>。</p><h1 id="4-异常体系和反射"><a href="#4-异常体系和反射" class="headerlink" title="4 异常体系和反射"></a>4 异常体系和反射</h1><h2 id="4-1-异常体系"><a href="#4-1-异常体系" class="headerlink" title="4.1 异常体系"></a>4.1 异常体系</h2><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p>1 <strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException)和非运行时异常。</p><ul><li>RuntimeException：<ul><li>ArithmeticException 算术条件异常。譬如：整数除零等</li><li>NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时</li><li>IndexOutOfBoundsException 索引越界异常。</li></ul></li><li>非运行时异常<ul><li>IOException IO异常</li><li>ClassNotFoundEcxeption 类未找到异常</li></ul></li></ul><p>2 <strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</p><ul><li>StackOverflowError 栈溢出错误。</li><li>OutOfMemoryError 内存不足错误。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212326.png" alt="img"></p><h2 id="4-2-捕获异常"><a href="#4-2-捕获异常" class="headerlink" title="4.2 捕获异常"></a>4.2 捕获异常</h2><p>1）对代码块用try..catch..finally进行异常捕获处理；</p><ul><li>当然如果没有发生异常，则catch块不会执行。但是finally块无论在什么情况下都是会执行的（这点要非常注意，因此部分情况下，都会将释放资源的操作放在finally块中进行）。</li></ul><p>2）在 该代码的方法体外用throws进行抛出声明</p><ul><li>在调用该方法时再用try..catch捕获</li></ul><p>3）在代码块直接用throw手动抛出一个异常对象</p><h2 id="4-3-反射机制"><a href="#4-3-反射机制" class="headerlink" title="4.3 反射机制"></a>4.3 反射机制</h2><h3 id="4-3-1-什么是反射"><a href="#4-3-1-什么是反射" class="headerlink" title="4.3.1 什么是反射"></a>4.3.1 什么是反射</h3><p>Reflection反射机制允许程序在执行期间借助于Reflection API取得任何类内部的信息，并能直接操作任意对象的内部属性及方法（包括private修饰的）</p><p>加载完类之后，在内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p><p>由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完全确定，在运行期仍然可以扩展</p><p>java属于一种静态语言，而反射的功能使得java成为可以在运行时改变其结构的准动态语言</p><h3 id="4-3-2-反射机制的优缺点"><a href="#4-3-2-反射机制的优缺点" class="headerlink" title="4.3.2 反射机制的优缺点"></a>4.3.2 反射机制的优缺点</h3><p>优点：能够运行时动态获取类的实例，提高灵活性；</p><p>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；</p><h3 id="4-3-3-如何获取反射中的Class对象？"><a href="#4-3-3-如何获取反射中的Class对象？" class="headerlink" title="4.3.3 如何获取反射中的Class对象？"></a>4.3.3 如何获取反射中的Class对象？</h3><ul><li>1 Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>2 类名.class。这种方法只适合在编译前就知道操作的 Class。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = String.class;</span><br></pre></td></tr></table></figure><ul><li>3 对象名.getClass()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Class clz = str.getClass();</span><br></pre></td></tr></table></figure><ul><li>4 如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。</li></ul><p>==4.3.4 反射机制的应用==</p><p>==4.3.5 反射机制的原理==</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java基础小解面经。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统大赏</title>
    <link href="https://wukang555.github.io/2021/07/25/%E9%9D%A2%E7%BB%8F_02_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://wukang555.github.io/2021/07/25/%E9%9D%A2%E7%BB%8F_02_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-25T14:55:00.000Z</published>
    <updated>2022-05-17T12:16:34.753Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统面经，分为基础、进程管理、内存管理三个部分讲解。</p><a id="more"></a><blockquote><p>[1] 参考《现代操作系统》</p><p>[2] 参考了JavaGuide的<a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis">操作系统文章</a>]</p><p>[3] 参考了cyc2018的<a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.html#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">操作系统文章</a></p><p>[4] 参考了小牛的<a href="http://interviewtop.top/#/list">面经网站</a></p></blockquote><p>之前看《现代操作系统》的时候，看了前四章分别是引论、进程线程、内存管理、文件系统。似乎针对面试而言，进程线程、内存管理比较重要。Guide的总结恰好也是如此，面向面试学习主要就是弄懂Guide的文章、总结好自己能够理解的回答然后背下来，所以文章的主要结果分别是基础、进程和线程、内存管理、虚拟内存。</p><h2 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1 操作系统基础"></a>1 操作系统基础</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>操作系统是管理计算机硬件和软件资源的计算机程序。本质上讲，操作系统也是一个软件，向上对用户程序提供接口，向下接管硬件资源。</p><p>作为最接近硬件的系统软件，操作系统存在屏蔽了硬件层的复杂性，操作系统内核（Kernel）负责的基本功能有进程管理、内存管理、设备管理、文件管理。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212155.png" alt="Kernel_Layout" style="zoom:50%;"><h3 id="1-2-操作系统的基本特征"><a href="#1-2-操作系统的基本特征" class="headerlink" title="1.2 操作系统的基本特征"></a>1.2 操作系统的基本特征</h3><p><strong>并发</strong></p><ul><li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，在单个周期内只运行了一个指令。</p></li><li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。</p></li></ul><p><strong>共享</strong></p><ul><li>共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。</li><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li></ul><p><strong>虚拟</strong></p><ul><li>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li><li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li><li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，==地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。== </li></ul><p><strong>异步</strong></p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h3 id="1-3-什么是内核态和用户态？"><a href="#1-3-什么是内核态和用户态？" class="headerlink" title="1.3 什么是内核态和用户态？"></a>1.3 什么是内核态和用户态？</h3><p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。</p><p>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</p><p>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</p><p>操作系统内核运行在内核态，用户程序运行在用户态。</p><h3 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h3><p><strong>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</strong>系统调用就是为了使用操作系统内核的功能，如进程管理、内存管理、文件管理、设备管理等 (操作系统内核现在也分为宏内核和微内核，微内核将部分功能模块化需要频繁的进行用户态和内核态的切换)</p><ul><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li></ul><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th align="center">Task</th><th>Commands</th></tr></thead><tbody><tr><td align="center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td align="center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td align="center">文件操作</td><td>open(); read(); write();</td></tr><tr><td align="center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td align="center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td align="center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h3 id="1-5-用户态向内核态切换的三种方式（也叫中断分类）"><a href="#1-5-用户态向内核态切换的三种方式（也叫中断分类）" class="headerlink" title="1.5 用户态向内核态切换的三种方式（也叫中断分类）"></a>1.5 用户态向内核态切换的三种方式（也叫中断分类）</h3><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p><ol><li>用户程序使用系统调用，陷入内核态。系统调用本身是一种软中断。</li><li>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。</li><li>外部中断，由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li></ol><h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2 进程和线程"></a>2 进程和线程</h2><h3 id="2-1-线程-进程的区别"><a href="#2-1-线程-进程的区别" class="headerlink" title="2.1 线程/进程的区别"></a>2.1 线程/进程的区别</h3><p>进程是资源分配的基本单位，而线程是任务调度和执行的基本单位。简单来说，进程就是一个正在运行的程序，并且一个进程中包含多个并发执行的线程（CPU调度，分配时间片给不同的线程）。</p><p>多个线程共享进程的资源（如堆和方法区），同时线程也拥有自己的程序计数器、虚拟机栈和本地方法栈。</p><p>总结来说 进程之间的执行和调度需要分配内存空间、开销较大。而线程之间的切换，开销较小</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212205.png" alt="img" style="zoom:50%;"><h3 id="2-2-进程的5种状态"><a href="#2-2-进程的5种状态" class="headerlink" title="2.2 进程的5种状态"></a>2.2 进程的5种状态</h3><p>进程一共有5种状态，分别是创建、就绪、运行（执行）、阻塞、终止。 （线程也是类似的5种状态）</p><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212209.png" alt="A61F5B5322ED49038C64BDD82D341987"></p><h3 id="2-3-进程间通信的方式"><a href="#2-3-进程间通信的方式" class="headerlink" title="2.3 进程间通信的方式"></a>2.3 进程间通信的方式</h3><blockquote><p>我还不懂，后面原理还是要看书</p><p>Guide推荐:<a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> 推荐阅读，总结的非常不错。</p></blockquote><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212212.png" alt="进程间通信模型"></p><p>进程间通信主要包括 管道、命名管道FIFO、消息队列、信号量、信号、共享内存、以及套接字socket。</p><ul><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。调用pipe系统函数即可创建一个管道。</li></ul><blockquote><p>管道本质是一个伪文件(实为内核缓冲区)，使用环形队列机制实现</p><p>管道的局限性：</p><ol><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li><li>只能公共祖先的进程间可以使用管道。</li></ol></blockquote><ul><li><strong>有名管道(Names Pipes)</strong> : 管道只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li></ul><blockquote><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</p><p>有名管道的名字存在于文件系统中，内容存放在内存中。</p></blockquote><ul><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。</li></ul><blockquote><p>消息队列允许一个或多个进程向它写入与读取消息.</p><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</p><p>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</p></blockquote><ul><li><strong>信号量（Semaphores）</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。</li><li><strong>共享内存(Shared memory)</strong> ：允许多个进程共享访问同一块内存空间，因为数据不需要在进程之间复制，所以这是最快的一种 IPC。这种方式需要依靠同步操作，如信号量来同步对共享内存的访问。</li></ul><blockquote><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。（这里没懂）</p></blockquote><ul><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ul><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3* 进程同步"></a>2.3* 进程同步</h3><blockquote><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul></blockquote><p>操作系统中，进程是具有不同的地址空间。有时候，需要多个进程来协同完成一些任务。 进程的互斥是解决进程间竞争关系的方法，即同一个时刻只有一个进程可以进入临界区。同步可以认为是一中更高级的互斥，指多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p><p>进程的同步主要有个两种方式：信号量和管程</p><p><strong>信号量</strong>：用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作（减操作）和V操作（加操作）。基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。特别的当信号量只能是0和1时就是一个互斥量</p><p> <strong>管程</strong>：是由一个或多个过程、一个初始化序列和局部数据组成的软件模块</p><ul><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li><li>一个进程通过调用管程的一个过程进入管程。</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</li></ul><h3 id="2-4-进程的调度算法"><a href="#2-4-进程的调度算法" class="headerlink" title="2.4 进程的调度算法"></a>2.4 进程的调度算法</h3><p>进程调度的原因</p><ul><li><p>在操作系统中，由于进程总数多于CPU的数量，它们必然会竞争CPU资源。</p></li><li><p>进程调度是指按照某种调度算法（或原则）从就绪队列中选取进程分配CPU。</p></li><li><p>通常有以下两种进程调度方式：非抢占方式、抢占方式</p><p>进程调度的常见算法</p></li></ul><p><strong>1 先来先服务调度算法（FCFS，First Come First Server）</strong></p><blockquote><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业</p></blockquote><p><strong>2 短作业优先调度算法（SJF，Short Job First）</strong></p><blockquote><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死</p></blockquote><p><strong>3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><blockquote><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。新作业少就挂起当前线程</p></blockquote><p><strong>4 优先级调度算法</strong></p><blockquote><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></blockquote><p><strong>5 时间片轮转法（RR，Round Robin）</strong></p><blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系</p></blockquote><p><strong>6 多级反馈队列调度算法（MLFQ，Multi-Level Feedback Queue）</strong></p><blockquote><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p></blockquote><h3 id="2-5-死锁的四个必要条件"><a href="#2-5-死锁的四个必要条件" class="headerlink" title="2.5 死锁的四个必要条件"></a>2.5 死锁的四个必要条件</h3><p>死锁：两个或两个以上进程在执行过程中，陷入一种循环等待资源的阻塞状态的现象。死锁的四个必要条件如下</p><ul><li>互斥条件: 一个资源每次只能被一个进程使用</li><li>不可剥夺条件:进程已获得的资源，在末使用完之前，不能被强行剥夺</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源仍然保持不放</li><li>循环等待条件：多个线程之间存在一种首尾相接、循环等待资源的关系.</li></ul><h3 id="2-6-出现死锁如何处理"><a href="#2-6-出现死锁如何处理" class="headerlink" title="2.6 出现死锁如何处理"></a>2.6 出现死锁如何处理</h3><ul><li><strong>预防——及时破环四个必要条件</strong><ul><li>破坏互斥条件、让资源共享。（比如假脱机打印技术允许若干个进程同时输出，但实际只有一个真正请求物理打印机的进程）</li><li>破坏不可剥夺条件，可能造成前段工作失效——效率很低</li><li>破坏请求和保持条件，采用预先分配资源的方法，一次性分配一个进程所需的所有资源——过于消耗资源</li><li>破坏循环等待条件，采用顺序资源分配法，就是给资源编号、顺序取用——资源数量很多时、找不到这样的一个完美的顺序的</li></ul></li><li><strong>避免——维持一个安全的系统状态</strong><ul><li>安全的系统状态一定不会导致死锁，不安全的系统状态可能导致死锁。如果资源分配不会进入不安全的系统状态就给进程分配资源</li><li>银行家算法：动态的进行资源分配，使之不进入不安全状态</li></ul></li><li><strong>检测和解除</strong><ul><li>画出资源分配图，圆圈表示进程，框表示一类资源。如果出现环路，说明死锁了。（资源重复采用矩阵的方法）</li><li>①资源剥夺法：挂起某些死锁进程并剥夺其资源。②撤销进程法：撤销一个甚至全部死锁进程并剥夺其 资源。③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</li></ul></li></ul><h2 id="3-操作系统的内存管理基础"><a href="#3-操作系统的内存管理基础" class="headerlink" title="3 操作系统的内存管理基础"></a>3 操作系统的内存管理基础</h2><h3 id="3-1-什么是虚拟内存？为什么要引入虚拟内存【自用】"><a href="#3-1-什么是虚拟内存？为什么要引入虚拟内存【自用】" class="headerlink" title="3.1 什么是虚拟内存？为什么要引入虚拟内存【自用】"></a>3.1 什么是虚拟内存？为什么要引入虚拟内存【自用】</h3><p>虚拟内存是计算机系统内存管理的一种技术。每个程序拥有自己的虚拟地址空间，这些虚拟地址一般以分页的方式被映射到物理内存，但不需要映射到连续的物理内存，当程序引用到不在物理内存中的页时，就发生缺页中断修改映射关系，操作系统将再需要访问的页面映射到物理内存中以便程序顺利进行。这样造成的效果将物理内存扩充成了更大的虚拟内存，进程看起来像是拥有了更多的可用内存。</p><p>说到虚拟内存，其实也可以提一下当不使用抽象储存的情景。比如上世纪60年代的IBM360机器。直接简单粗暴的使用物理内存地址，从0到某个上限值。这样会带来两个问题：1当在一个物理内存中运行多道程序时，会出现“保护和重定位”的问题，就是一个进程的指令可能跳转到另一个进程的地址中去了（之前是使用保护键、基址寄存器和界限寄存器的解决方案来区分不同的进程）。2 就是内存的大小问题，一个现代操作系统动辄就是几十个甚至几百个进程，而内存的大小受价格等现实因素的约束一般是无法满足一些软件对内存的需求的。</p><p>所以说白了虚拟内存就是解决了这两个问题，1首先每个进程拥有私有的地址空间，进程的虚拟地址空间是独立于其他进程了，解决了保护和重定位的问题。 2其次，虚拟内存技术使用了空分复用技术，使物理内存抽象为地址空间，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。解决了内存大小不够用的问题</p><h3 id="3-2-虚拟地址和物理地址及其转换原理？"><a href="#3-2-虚拟地址和物理地址及其转换原理？" class="headerlink" title="3.2 虚拟地址和物理地址及其转换原理？"></a>3.2 虚拟地址和物理地址及其转换原理？</h3><p>虚拟地址：页面号+偏移量；物理地址：页框号+偏移量</p><p>程序或进程自己的地址称为虚拟地址，它们构成了虚拟地址空间。虚拟地址通过<strong>内存管理单元（Memory Management Unit， MMU）</strong> 映射到物理内存地址上，从而被执行。</p><p><strong>MMU是CPU里面专门用来完成地址转换的单元。MMU通过查找页表来完成虚拟地址到物理地址的转换。</strong>有两种情况：1一种是该虚拟地址存在于物理内存中时直接查出物理地址；2该虚拟地址没有映射到物理内存中，那就需要缺页中断，利用页面置换算法，将该页面置换到物理内存中，然后重新查页表得到物理地址。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212226.png" alt="image-20210728110226493"></p><p>通过页表查询物理地址具体的过程：1 通过虚拟地址的页号作为索引找到对应的“页框号”和“在不在”位，2 如果在不在位为1，就将页框号拼接上偏移量得到物理地址。如果在不在为0，就先缺页中断进行页面的调度，最后也是获得页框号后拼接上偏移量的到物理地址。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212229.png" alt="image-20210728110242076" style="zoom:80%;"><h3 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h3><blockquote><p>普通的分页和MMU查询页表进行地址的转换还存在着两个问题：</p><ul><li>1)虚拟地址到物理地址的映射必须非常快。 ——使用TLB</li><li>2)如果虚拟地址空间很大，页表也会很大——使用多级页表、倒排页表<ul><li>每个进程都需要有自己的页表，，</li><li>32位的电脑、每页4k个地址的话，，就是100万个页，，太多了</li><li>页表太大 查询的就会慢</li></ul></li></ul></blockquote><p><strong>快表TLB</strong></p><p>快表其实就是使用<strong>转换检测缓冲区（TLB）</strong>，为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。TLB一般位于MMU中，TLB中包换少量频繁使用的表项，当要转换的虚拟地址位于TLB中时、直接获取对应的物理地址，而无需再查询页表了！</p><p>TLB的实现其实是基于局部性原理：大多数程序总是对少量的页面进行多次的访问，而不是相反的。因此，只有很少的页表项会 被反复读取，而其他的页表项很少被访问。。所以我们将这些常用的访问页面的映射存在TLB中，将极大提高转换效率。</p><p><strong>多级页表</strong></p><p>引入多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。</p><ul><li>引入多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。</li><li>比如一个程序只需要12M的内存，，但虚拟内存的空间有4G。这4GB被分为1024个4MB的块，，真正是需要将3个虚拟内存块映射的物理内存加入到内存中间就好了！！</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212233.png" alt="image-20210728122507555" style="zoom:67%;"><h3 id="3-4-常用的页面置换算法"><a href="#3-4-常用的页面置换算法" class="headerlink" title="3.4 常用的页面置换算法"></a>3.4 常用的页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>包括以下算法：</p><ul><li><strong>最佳算法</strong>：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</li><li><strong>先进先出</strong>：选择换出的页面是最先进入的页面。该算法将那些经常被访问的页面也被换出，从而使缺页率升高。</li><li><strong>LRU</strong>：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。<code>LRU</code> 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 <code>LRU</code> 代价很高。</li><li><strong>时钟算法</strong>：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。它将整个环形链表的每一个页面做一个标记，如果标记是<code>0</code>，那么暂时就不会被替换，然后时钟算法遍历整个环，遇到标记为<code>1</code>的就替换，否则将标记为<code>0</code>的标记为<code>1</code>。</li></ul><h3 id="3-5-分段和段页式管理机制"><a href="#3-5-分段和段页式管理机制" class="headerlink" title="3.5 分段和段页式管理机制"></a>3.5 分段和段页式管理机制</h3><p>分段：</p><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><p>段页式：</p><p>段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p><h2 id="4-操作系统磁盘IO"><a href="#4-操作系统磁盘IO" class="headerlink" title="4 操作系统磁盘IO"></a>4 操作系统磁盘IO</h2><blockquote><p>[1] 完全参考小林coding的文章<a href="https://mp.weixin.qq.com/s/P0IP6c_qFhuebwdwD8HM7w">原来 8 张图，就可以搞懂「零拷贝」了</a> 建议阅读文章理解</p></blockquote><p>磁盘由核心态管理，用户程序想要访问磁盘数据，一般要经过系统调用，陷入核心态，进而获取数据。磁盘IO相比内存存储和cpu寄存器，是相当耗时的操作，所以要尽可能地提高磁盘IO操作的速度。</p><h3 id="4-1-三种IO方式"><a href="#4-1-三种IO方式" class="headerlink" title="4.1 三种IO方式"></a>4.1 三种IO方式</h3><blockquote><p>忙等待是阻塞的。一般来说普通异步IO和DMA模式的IO都是非阻塞的。它们的区别在于：</p><ul><li>普通异步IO在磁盘IO处理完之后就发起中断，交由CPU拷贝数据。</li><li>DMA模式的IO在DMA将磁盘数据拷贝到内核内存上之后，再发起中断，占用CPU</li></ul></blockquote><p>《现代操作系统》中介绍了实现输入输出（IO）的三种方式：忙等待、异步IO 中断、DMA中断。</p><ul><li><strong>忙等待</strong>：用户程序发出一个系统调用，然后就执行I/O过程，CPU一直等待I/O的数据，直到得到数据后处理，处理完以后返回结果，CPU才继续处理其他事情。这种方式称为忙等待。</li><li><strong>异步IO</strong>：第二种是通过异步IO和中断机制，需要I/O时，先让I/O设备执行对应操作，这个时候CPU不需要等待，继续做其他事情，如果I/O执行完，拿到数据了，这个时候由中断控制器对CPU发起一个中断，处理这个I/O得到的数据。大白话就是先让CPU处理其他事情，当得到I/O数据后，告诉CPU，你先停一下现在手头上的事儿，你刚刚要的数据准备好了，现在给你，你处理下。</li><li><strong>DMA的异步IO</strong>：使用直接存储器访问芯片(DMA,Direct Memory Access)，直接控制位流，DMA得到数据时，也会对CPU发起中断。（DMA模式的IO在DMA将磁盘数据拷贝到内核内存上之后，再发起中断，占用CPU）</li></ul><h4 id="1-传统的忙等待IO过程"><a href="#1-传统的忙等待IO过程" class="headerlink" title="1 传统的忙等待IO过程"></a><strong>1 传统的忙等待IO过程</strong></h4><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器（内核缓冲区PageCache），然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212239.png" alt="6401" style="zoom:50%;"><h4 id="2-异步IO过程"><a href="#2-异步IO过程" class="headerlink" title="2 异步IO过程"></a>2 异步IO过程</h4><blockquote><p>DMA和异步IO一般都是非阻塞的IO</p></blockquote><p>异步IO用于处理cpu阻塞的问题。 当不使用PageCache 内核缓存时也称为直接IO</p><p>过程如下：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212242.png" alt="6403" style="zoom:50%;"><h4 id="3-DMA中断IO过程"><a href="#3-DMA中断IO过程" class="headerlink" title="3 DMA中断IO过程"></a>3 DMA中断IO过程</h4><p><strong>DMA直接内存访问</strong>（Direct Memory Access）在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p><p>简单来讲就是，传统IO由CPU负责将数据的拷贝搬运：从磁盘缓存器—&gt;到内核缓存区—&gt;再到用户缓冲区。。而使用DMA之后，<strong>磁盘缓存器—&gt;到内核缓存区</strong>过程由DMA负责，此时cpu可以处理其他的事情也可以闲置等待….</p><p>过程如下：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务（这其实就是一种的异步IO）；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212246.png" alt="6402" style="zoom:50%;"><h3 id="4-2-零拷贝技术（传输小文件）"><a href="#4-2-零拷贝技术（传输小文件）" class="headerlink" title="4.2 零拷贝技术（传输小文件）"></a>4.2 零拷贝技术（传输小文件）</h3><p>传统的文件传输模式：read+write：4次上下文切换和4次数据拷贝过程。要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。零拷贝有两种方式：</p><ul><li>mmap + write：4 次上下文切换，和 3 次数据拷贝过程</li><li>sendfile： 2 次上下文切换，和 3/2 次数据拷贝过程</li></ul><h4 id="1-传统的文件传输模式（4次切换、4次拷贝）"><a href="#1-传统的文件传输模式（4次切换、4次拷贝）" class="headerlink" title="1 传统的文件传输模式（4次切换、4次拷贝）"></a>1 传统的文件传输模式（4次切换、4次拷贝）</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。如下两个系统调用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212250.png" alt="6404" style="zoom:50%;"><p>期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>分别对应着两次系统调用：一次是 <code>read()</code> ，一次是 <code>write()</code>，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的。</p><h4 id="2-mmap-write（4-次切换，和-3-次拷贝）"><a href="#2-mmap-write（4-次切换，和-3-次拷贝）" class="headerlink" title="2 mmap + write（4 次切换，和 3 次拷贝）"></a>2 mmap + write（4 次切换，和 3 次拷贝）</h4><p><code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">buf</span> = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212253.png" alt="6405" style="zoom:50%;"><p><strong>数据不用来回从内核态拷贝到用户态（只进行一个映射），减少了一次拷贝的过程</strong></p><h4 id="3-sendfile（2-次切换，和-3-次拷贝-2次拷贝）"><a href="#3-sendfile（2-次切换，和-3-次拷贝-2次拷贝）" class="headerlink" title="3 sendfile（2 次切换，和 3 次拷贝/2次拷贝）"></a>3 sendfile（2 次切换，和 3 次拷贝/2次拷贝）</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="attribute">ssize_t</span> sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><p><code>sendfile()</code>可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212257.png" alt="6405" style="zoom:50%;"><p>对于支持网卡支持 SG-DMA 技术的情况下，还可以直接通过SG-DMA拷贝，将内核缓存区的数据直接拷贝到网卡上，可以再省一次的拷贝过程：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212259.png" alt="6405" style="zoom:50%;"><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面（内核内存和用户内存）去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h3 id="4-3-传输大文件（异步直接IO）"><a href="#4-3-传输大文件（异步直接IO）" class="headerlink" title="4.3 传输大文件（异步直接IO）"></a>4.3 传输大文件（异步直接IO）</h3><blockquote><p>零拷贝使用了内核缓存区PageCache（一种高速缓存）来缓存磁盘数据，提高了效率，但显然不适用于大文件的传输（高速缓存区放不下大文件）</p></blockquote><p>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p><p><strong>传输大文件应当使用：异步IO+直接IO</strong>（即不使用PageCache内核高速缓存）</p><p>直接 I/O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /video/ &#123; </span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>; </span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>; </span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当文件大小大于 directio 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;操作系统面经，分为基础、进程管理、内存管理三个部分讲解。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://wukang555.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络大赏</title>
    <link href="https://wukang555.github.io/2021/07/20/%E9%9D%A2%E7%BB%8F_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://wukang555.github.io/2021/07/20/%E9%9D%A2%E7%BB%8F_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-07-20T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:59.771Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络面经，极简共22个问题。</p><a id="more"></a><blockquote><p>[1] <a href="http://www.cyc2018.xyz/">参考了cyc2018的总结（偏理解）</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/">参考了JavaGuide的一些总结</a>]</p><p>[3] <a href="https://mp.weixin.qq.com/mp/homepage?__biz=Mzg4MjUxMTI4NA==&hid=1&sn=991fdb47b57f5a276873f5c4d976f59f&scene=18&uin=&key=&devicetype=Windows+10+x64&version=6302019c&lang=zh_CN&ascene=7&fontgear=2">参考了公众号程序员库森的面经总结</a></p></blockquote><h2 id="1-计算机网络的各层协议及作用？"><a href="#1-计算机网络的各层协议及作用？" class="headerlink" title="1. 计算机网络的各层协议及作用？"></a>1. 计算机网络的各层协议及作用？</h2><p>计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。</p><p>五层网络体系结构各层的主要功能：</p><ul><li>应用层：通过不同主机上应用进程之间的交互来完成特定的网络功能，例如 HTTP、DNS 等协议。数据单位为报文。</li><li>运输层：负责为两台主机进程之间的通信提供通用的数据传输服务。运输层主要有两种协议：<ul><li>TCP：提供面向连接的、可靠的数据传输服务；数据单位为报文段</li><li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。数据单位为用户数据报</li></ul></li><li>网络层：选择合适的路由和交换结点，确保数据及时传送。网络层把传输层传递下来的报文段或者用户数据报封装成分组进行传输。主要包括IP协议。</li><li>数据链路层：将网络层传下来的IP分组封装成帧，并再相邻节点的链路上传送帧。</li><li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212117.png" alt="图片"></p><h2 id="2-TCP和UDP的区别？"><a href="#2-TCP和UDP的区别？" class="headerlink" title="2. TCP和UDP的区别？"></a>2. TCP和UDP的区别？</h2><p>TCP\UDP都是传输层的协议，TCP指传输控制协议，UDP指用户数据报协议</p><ul><li><p>TCP 保证数据的可靠传输，UDP 只尽最大努力交付，即不保证可靠交付。</p></li><li><p>TCP 是面向连接的，而 UDP 是无连接的，发送数据之前不需要建立连接，减少了开销和发送数据之前 的时延。</p></li><li><p>TCP 是面向字节流的，UDP 是面向报文的。UDP 对应用层交下来的报文既不拆分也不合并，传输整个报文。当报文过短或过长都会影响网络层的传输效率。</p></li><li><p>TCP 有拥塞控制，UDP 没有拥塞控制，因此网络中出现的拥塞不会降低源主机的发送速率。</p></li><li><p>TCP 是点到点之间的一对一通信，UDP 支持一对一、一对多和多对多的交互通信。</p></li><li><p>UDP 的首部开销很小，只有 8 字节，TCP 的首部开销为20个字节。</p></li></ul><p>适应场景的区别：</p><ul><li>TCP：适应用于传输效率要求较低，但准确率要求较高的场景，例如：文件传输、接收邮件、HTTP。</li><li>UDP：适用于效率要求相对较高，但准确性相对较低的场景， 例如：QQ聊天、在线视频、语音电话、DNS等</li></ul><h2 id="3-详细介绍一下-TCP-的三次握手机制？"><a href="#3-详细介绍一下-TCP-的三次握手机制？" class="headerlink" title="3. 详细介绍一下 TCP 的三次握手机制？"></a>3. 详细介绍一下 TCP 的三次握手机制？</h2><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212121.png" alt="image-20210616092718682" style="zoom: 50%;"><ul><li>SYN同步字段：用来建立连接，需要消耗一个序号；ACK确认字段：是确认报文段的标识，确认报文须设置ACK为1。</li><li>假设A是客户端，B是服务器；初始都是CLOSED状态，B会先创建一个连接控制块TCB并进入LISTEND收听状态，监听端口是否收到了连接请求、以便及时响应</li><li>第一次握手：A主动打开，发送建立连接的请求报文、其中SYN同步字段=1，并且消耗一个序号；假设A此时的发送序号为x。发送完之后A处于SYN_SENT同步已发送的状态；</li><li>第二次握手：B收到A发送过来的请求连接的报文，发送给A一个确认收到的报文。其中SYN同步字段=1，ACK确认字段=1；假设此时B的发送序号为y，确认号为x+1。发送完之后B处于SYN_RCVD同步已收到的状态；</li><li>第三次握手：A收到B的确认报文之后，还要给B发送一个确认报文。其中ACK确认字段=1；发送序号为x+1，确认号为y+1；发送完之后A处于连接已建立的状态；当B收到这个确认报文后、也进入连接已建立的状态。服务器要比客户端稍晚一点进入已连接的状态</li></ul><h2 id="4-为什么需要三次握手，而不是两次？"><a href="#4-为什么需要三次握手，而不是两次？" class="headerlink" title="4. 为什么需要三次握手，而不是两次？"></a>4. 为什么需要三次握手，而不是两次？</h2><p>三次握手的两个主要原因：信息对等和防止超时</p><ul><li>信息对等指客服端服务器都需要确认自己和对方有接受和发送报文段的能力。如果只有两次握手，那么站在服务器的角度、就不确定对方是否有接受报文段的能力。</li><li>三次握手也防止失效连接突然到达导致脏连接。客服端的某个超时连接突然到达，服务器以为A发送了连接请求，就发送确认报文，建立连接。如果是两报文握手连接就建立了、浪费了资源。。三报文握手A收到确认报文时并非处于同步已发送状态，所以并不会向B发送确认报文，不会建立连接。</li></ul><h2 id="5-三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#5-三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="5. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a>5. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？</h2><p><strong>服务端：</strong></p><ul><li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为同步已收到SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送对A的确认报文（SYN+ACK包），以便客户端重新发送第三次握手的确认报文（ACK包）。</li><li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li></ul><p><strong>客户端：</strong></p><p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p><h2 id="6-详细介绍一下-TCP-的四次挥手机制？"><a href="#6-详细介绍一下-TCP-的四次挥手机制？" class="headerlink" title="6. 详细介绍一下 TCP 的四次挥手机制？"></a>6. 详细介绍一下 TCP 的四次挥手机制？</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212125.png" alt="image-20210616102556722"></p><ul><li>FIN指终止字段，释放连接时用来同步序号、需要消耗一个序号</li><li>第一次挥手：当A已经没有要发送的数据就会释放连接，A发送一个请求终止连接的报文，其中FIN终止字段=1，发送序号假设等于x；x等于A发送的上一个报文的序号+1；发送完毕后A进入终止等待1状态。</li><li>第二次挥手：当B收到A的终止连接报文后，向A发送一个确认报文，其中ACK确认字段=1，发送序号假设为y，确认序号为x+1；发送完毕后B进入关闭等待的状态，A收到确认报文后就进入终止等待2的状态。。。此时整个连接处于半关闭状态，B向上通知应用层结束A到B的连接。</li><li>第三次挥手：当B的数据发送完毕后准备释放连接，就向A发送终止连接报文，其中FIN终止字段=1，发送序号设为z，此时z=y+n，n表示这个期间B发送的字节数。。确认号为x+1；发送完之后B进入最后确认阶段。</li><li>第四次挥手：当A收到B的终止报文后，再向B发送一个确认报文，其中确认字段ACK=1，发送序号=x+1，确认号为z+1；发送完之后，A进入时间等待状态，等2MSL（最大报文寿命）之后进入关闭状态；B收到确认后，进入关闭状态。一般服务器先于客服端关闭。</li></ul><h2 id="7-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？"><a href="#7-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？" class="headerlink" title="7. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？"></a>7. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</h2><ul><li>1、保证A的最后一个确认报文能够到达B，然后B能够正常关闭。如果该确认报文丢失，B这边没有收到就会超时重传一次终止连接的报文，重传的报文能够在2MSL时间内到达A，然后A就可以重传确认关闭的报文了。</li><li>2、2MSL时间之后本连接所有的报文都会消失，可以防止已失效的连接请求与正常的连接请求相混淆。</li></ul><h2 id="8-如果已经建立了连接，但是客户端出现故障了怎么办？"><a href="#8-如果已经建立了连接，但是客户端出现故障了怎么办？" class="headerlink" title="8. 如果已经建立了连接，但是客户端出现故障了怎么办？"></a>8. 如果已经建立了连接，但是客户端出现故障了怎么办？</h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p><p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p><p>保活计时器：使客服端挂掉之后，服务器端能够主动终止连接</p><ul><li>服务器每收到一次客户端的数据就重置保活器为两小时，如果两小时内没有收到就每间隔75秒发送一次探测报文，连续发10次客服端还没响应，就关闭连接。</li></ul><h2 id="9-TCP流量控制"><a href="#9-TCP流量控制" class="headerlink" title="9 TCP流量控制"></a>9 TCP流量控制</h2><ul><li>利用滑动窗口实现流量控制，即让发送方的速率不要太快、以便接收方能够来得及接收</li><li>主要流程：接受方的确认字段含 reverse Windows 大小的信息：”rwnd=x”，并确认字段要带ACK=1标识</li><li>如果确认字段rwnd=x丢失，可能会出现相互等待的死锁情况。为此设置一个持续计时器、按时发送零窗口探测报文。</li></ul><h2 id="10-TCP拥塞控制"><a href="#10-TCP拥塞控制" class="headerlink" title="10 TCP拥塞控制"></a>10 TCP拥塞控制</h2><p>拥塞指对资源的需求大于可用的资源，，拥塞是一个全局动态的过程、仅仅增加资源可能并不会解决拥塞。</p><p>通过拥塞窗口（是一个变量）控制：发送方一般让自己的发送窗口的大小等于拥塞窗口的大小。然后动态修改之，当没有出现拥塞时，就增大拥塞窗口；当可能出现拥塞时，就缩减拥塞窗口值；</p><p>拥塞控制的算法：</p><ul><li>1慢开始算法<ul><li>由小逐渐间增大拥塞窗口cwnd的值，每经过一个传输轮次、窗口值就加倍。。为防止指数增长、设置一个慢开始门限ssthresh，当cwnd值大于门限时，启用拥塞避免算法。</li></ul></li><li>2拥塞避免算法<ul><li>cwnd以线性规律增长</li></ul></li><li>3快重传算法<ul><li>接收方只要发现有缺失，无论下一个接受到的是什么报文段，总是立即返回丢失报文的上一个报文段的确认。</li><li>一旦发送方收到三个重复的确认，就能尽早的知道发生了失序。然后立刻重传（那个重复确认报文段的）下一个报文段</li></ul></li><li>4快恢复算法<ul><li>当仅丢失个别失序报文段时，启动快速重传、、此时重传没必要从最开始的慢开始算法启动，而是直接执行拥塞避免算法，即调整慢开始门限值和当前拥塞窗口值为原先拥塞窗口的一半，直接启动拥塞避免算法。</li></ul></li></ul><h2 id="11-TCP可靠传输"><a href="#11-TCP可靠传输" class="headerlink" title="11 TCP可靠传输"></a>11 TCP可靠传输</h2><p>TCP打包传输过程：</p><ul><li>报文被分割成 TCP 认为最适合发送的报文段，然后把每个报文段打包传输。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</li><li>序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</li></ul><p>TCP的两个重传协议：</p><ul><li>超时重传协议：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的</li><li>连续ARQ（自动重传请求）协议：<ul><li>发送方维持一个发送窗口、窗口内的分组都可以连续发送出去，而不必等待确认重传；</li><li>如果窗口按序收到了一个“确认”、窗口就向后滑动一格</li><li>这里的确认机制指累计确认方式、接收方对按序收到的最后一个分组发送确认，确认一旦接受、就认为这个分组之前的确认都收到了</li></ul></li></ul><h2 id="12-浏览器输入url地址-到显示页面的过程"><a href="#12-浏览器输入url地址-到显示页面的过程" class="headerlink" title="12 浏览器输入url地址,到显示页面的过程"></a>12 浏览器输入url地址,到显示页面的过程</h2><ul><li><p>1 DNS解析：实现了网址到IP地址的转换</p><ul><li><p><strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。</p></li><li><p>若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p></li></ul></li><li><p>2 TCP连接：发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 <strong>80</strong> 端口发起 tcp 的连接。</p></li><li><p>3 建立 tcp 连接后客户端发起 http 请求</p></li><li><p>4 服务器处理请求并返回HTTP报文</p><ul><li>服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。</li></ul></li><li><p>5 浏览器解析解析 html 代码，并对页面进行渲染，呈现给用户。</p></li><li><p>6 连接结束</p></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212131.png" alt="20210616124706"></p><h2 id="13-介绍一下HTTP协议"><a href="#13-介绍一下HTTP协议" class="headerlink" title="13 介绍一下HTTP协议"></a>13 介绍一下HTTP协议</h2><p>HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP定义了浏览器怎样向万维网服务器请求文档、以及服务器怎样把文档传输给浏览器</p><p>HTTP在运输层使用TCP协议，TCP 为 HTTP 提供可靠的数据传输服务。</p><p>HTTP 是一种无状态的协议，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何区别。一般靠cookie和session来保存状态</p><h2 id="14-HTTP常见的状态码有哪些？"><a href="#14-HTTP常见的状态码有哪些？" class="headerlink" title="14 HTTP常见的状态码有哪些？"></a>14 HTTP常见的状态码有哪些？</h2><p>常见状态码：</p><ul><li>200：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li><li>301 ：(永久移动) 请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li><li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>400 ：客户端请求有语法错误，不能被服务器所理解。</li><li>403 ：服务器收到请求，但是拒绝提供服务。</li><li>404 ：(未找到) 服务器找不到请求的网页。</li><li>500：(服务器内部错误) 服务器遇到错误，无法完成请求。</li></ul><p>状态码开头代表类型：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212135.png" alt="图片"></p><h2 id="15-HTTP-常用的请求方式？"><a href="#15-HTTP-常用的请求方式？" class="headerlink" title="15 HTTP 常用的请求方式？"></a>15 HTTP 常用的请求方式？</h2><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体</td></tr><tr><td align="left">PUT</td><td align="left">上传文件</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件</td></tr><tr><td align="left">HEAD</td><td align="left">和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td align="left">PATCH</td><td align="left">对资源进行部分修改</td></tr><tr><td align="left">OPTIONS</td><td align="left">查询指定的URL支持的方法</td></tr><tr><td align="left">CONNECT</td><td align="left">要求用隧道协议连接代理</td></tr><tr><td align="left">TRACE</td><td align="left">服务器会将通信路径返回给客户端</td></tr></tbody></table><p>为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。</p><ul><li>PUT：上传文件，向服务器添加数据，可以看作增。</li><li>DELETE：删除文件。</li><li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li><li>GET：获取资源，查询服务器资源。</li></ul><h2 id="16-post和get区别"><a href="#16-post和get区别" class="headerlink" title="16 post和get区别"></a>16 post和get区别</h2><ul><li>GET 用于获取资源，而 POST 用于传输实体主体。</li><li>GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。<ul><li>因此GET 只支持 ASCII 码，且参数长度有限制&lt;2kb</li><li>POST 参数支持标准字符集多种编码方式。</li></ul></li><li>GET和POST本质上就是TCP链接，并无差别。</li><li>GET请求会被浏览器主动缓存，GET在浏览器回退/刷新时是无害的，而POST会再次提交请求。</li></ul><h2 id="17-HTTP请求报文和响应报文的格式？"><a href="#17-HTTP请求报文和响应报文的格式？" class="headerlink" title="17 HTTP请求报文和响应报文的格式？"></a>17 HTTP请求报文和响应报文的格式？</h2><p><strong>请求报文格式</strong>：</p><ol><li>请求行（请求方法+URI协议+版本）</li><li><strong>请求头部（具体几个参数还要看一看）</strong></li><li>空行</li><li>请求主体</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jspHTTP&#x2F;1.1 请求行</span><br><span class="line">Accept:image&#x2F;gif.image&#x2F;jpeg, 浏览器可以接收的内容类型</span><br><span class="line">Accept-Language:zh-cn  浏览器接收的语言</span><br><span class="line">Connection:Keep-Alive 是否开启长连接</span><br><span class="line">Host:localhost  被服务器的域名或IP地址，如果不是通用端口，还包含该端口号</span><br><span class="line">User-Agent:Mozila&#x2F;4.0(compatible;MSIE5.01;Window NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate 浏览器可以处理的编码方式</span><br><span class="line">&#x2F;&#x2F;还可以有cookie等...</span><br><span class="line"></span><br><span class="line">username&#x3D;jinqiao&amp;password&#x3D;1234 请求主体</span><br></pre></td></tr></table></figure><p><strong>响应报文</strong>：</p><ol><li>状态行（版本+状态码+原因短语）</li><li>响应首部</li><li>空行</li><li>响应主体</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server:Apache Tomcat&#x2F;5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;HTTP响应示例&lt;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello HTTP!</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="18-解释一下HTTP长连接和短连接？"><a href="#18-解释一下HTTP长连接和短连接？" class="headerlink" title="18 解释一下HTTP长连接和短连接？"></a>18 解释一下HTTP长连接和短连接？</h2><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p><strong>在HTTP/1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 <strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><h2 id="19-http和https的区别"><a href="#19-http和https的区别" class="headerlink" title="19 http和https的区别"></a>19 http和https的区别</h2><ul><li>端口 ：HTTP默认使用端口80，而HTTPS使用端口443。</li><li>安全性和资源消耗：HTTP 安全性没有 HTTPS高，但是 HTTP 比HTTPS耗费的服务器资源更少。<ul><li> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li>HTTPS所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。<ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ul></li></ul><h2 id="20-Cookie、Session的区别"><a href="#20-Cookie、Session的区别" class="headerlink" title="20 Cookie、Session的区别"></a>20 Cookie、Session的区别</h2><p><strong>Cookie通过在客户端记录信息确定用户身份</strong></p><p>类似给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。Cookie实际上是一小段的文本信息，储存在浏览器中。服务器还可以根据需要修改Cookie的内容。</p><p><strong>Session通过在服务器端记录信息确定用户身份</strong></p><p>Session相当于程序在服务器上建立的一份客户档案，类似于一份“客户明细表”，客户来访的时候只需要查询客户档案表就可以了。Session会增加一些服务器端的存储压力。</p><p><strong>cookie和session的区别</strong></p><ul><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上.</p></li><li><p>一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</p></li><li><p>session会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie，考虑到安全应当使用session。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p></li></ul><h2 id="21-SQL注入是什么，如何避免SQL注入？"><a href="#21-SQL注入是什么，如何避免SQL注入？" class="headerlink" title="21 SQL注入是什么，如何避免SQL注入？"></a>21 SQL注入是什么，如何避免SQL注入？</h2><p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。</p><p><strong>SQL注入的原理主要有以下 4 点</strong></p><ul><li>恶意拼接查询</li><li>利用注释执行非法命令</li><li>传入非法参数</li><li>添加额外条件</li></ul><p><strong>避免SQL注入的一些方法</strong>：</p><ul><li>限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。</li><li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）转义处理。</li><li>提供参数化查询接口，不要直接使用原生SQL。</li><li>${} #{}都是进行动态传参的标记符，尽量用#{}进行传参<ul><li>${}在动态解析SQL阶段就直接替换为一个字符串</li><li>#{}是先用一个占位符?占位，然后在SQL执行的时候进行变量替换</li><li>#{}可以避免sql注入，能用#{}的应该尽量用#{}。表名参数的传递必须用${}</li></ul></li></ul><h2 id="22-负载均衡算法有哪些？"><a href="#22-负载均衡算法有哪些？" class="headerlink" title="22 负载均衡算法有哪些？"></a>22 负载均衡算法有哪些？</h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p><ul><li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li><li>随机法：随机获取一台，和轮询类似。</li><li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li><li>加权轮询：根据服务器性能不同加权。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络面经，极简共22个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机网络" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/07/10/%E6%A1%86%E6%9E%B6_09_RabbitMQ_wukang/"/>
    <id>https://wukang555.github.io/2021/07/10/%E6%A1%86%E6%9E%B6_09_RabbitMQ_wukang/</id>
    <published>2021-07-10T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:39.338Z</updated>
    
    <content type="html"><![CDATA[<p>狂神RabbitMQ教学视频学习笔记，包括消息队列介绍、RabbitMQ安装、RabbitMQ的5中订阅和发布的模式Demo等内容</p><a id="more"></a><blockquote><p>[1] 主体是狂神说系列的RabbitMQ教程<a href="https://www.bilibili.com/video/BV1dX4y1V73G?p=1">https://www.bilibili.com/video/BV1dX4y1V73G?p=1</a></p><p>[2] 参考了cyc2018关于消息中间件的文章<a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">http://www.cyc2018.xyz</a></p><p>[3] 参考了JavaGuide主页的链接文章<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/RabbitMQ%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86">https://snailclimb.gitee.io/javaguide/#/</a></p></blockquote><h1 id="1-消息队列和RabbitMQ"><a href="#1-消息队列和RabbitMQ" class="headerlink" title="1 消息队列和RabbitMQ"></a>1 消息队列和RabbitMQ</h1><h2 id="1-1-消息队列介绍"><a href="#1-1-消息队列介绍" class="headerlink" title="1.1 消息队列介绍"></a>1.1 消息队列介绍</h2><p>消息系统允许软件、应用相互连接和扩展．这些应用可以相互链接起来组成一个更大的应用。通俗来讲，<strong>消息队列用来处理分布式应用各个系统之间的通信问题。</strong>（举几个例子？搞项目之后回来再看）</p><p>消息模型一般分两种：点对点 和 发布/订阅</p><ul><li><strong>点对点</strong></li></ul><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211919.png" alt="img"></p><ul><li><strong>发布/订阅</strong></li></ul><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。（发布/订阅和设计模式中的观察者模式不同，是异步的并且通过频道通信）</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211922.png" alt="img"></p><h2 id="1-2-消息队列使用场景【重要】"><a href="#1-2-消息队列使用场景【重要】" class="headerlink" title="1.2 消息队列使用场景【重要】"></a>1.2 消息队列使用场景【重要】</h2><p>消息队列带来的优点就是 异步、削峰和解耦，这三点同样也是它的应用场景</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><blockquote><p>举个🌰，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信和邮件。</p><p>省略中间的网络通信时间消耗，假设购票系统处理需要 150ms ，短信系统处理需要 200ms，邮件系统处理需要 200ms</p></blockquote><ul><li>如果采用同步的处理：需要等待短信、邮件都处理啊完毕后，才表示购票成功<ul><li>所需时间150ms + 200ms + 200ms = 550ms</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211925.jpg" alt="img"></p><ul><li>如果采用异步的处理，在购票系统和短信、邮件系统中增加一个中间件——消息队列。我们将消息存入消息队列之后，就代表购票成功、<ul><li>150ms + 10ms = 160ms。</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211928.jpg" alt="img"></p><h3 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><blockquote><p>还是购票系统的栗子：</p><p>主业务购票系统的流量承受能力较强、但短信和邮件系统一般配备的硬件资源不会太高，无法承受和购票系统一样的流量压力。</p><p>使用消息队列可以将购买完成的信息发送到消息队列中，短信、邮件系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> </p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211931.jpg" alt="img"></p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p><em>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</em></p><h2 id="1-3-RabbitMQ介绍"><a href="#1-3-RabbitMQ介绍" class="headerlink" title="1.3 RabbitMQ介绍"></a>1.3 RabbitMQ介绍</h2><blockquote><p>ActiveMQ、 RabbitMQ、 Kafka、RocketMQ都是不同的消息中间件</p></blockquote><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，用于在分布式系统中存储转发消息。</p><h3 id="RabbitMQ的优点"><a href="#RabbitMQ的优点" class="headerlink" title="RabbitMQ的优点"></a>RabbitMQ的优点</h3><ul><li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由</strong>：消息在到达队列前是通过交换机进行路由的。RabbitMQ为典型的路由逻辑提供了多种内置交换机类型。</li><li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性：</strong> 在同一个集群里，队列可以被镜像到多个机器中，以确保当其中某些硬件出现故障后，你的消息仍然安全。</li></ul><h3 id="RabbitMQ-的整体架构"><a href="#RabbitMQ-的整体架构" class="headerlink" title="RabbitMQ 的整体架构"></a>RabbitMQ 的整体架构</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211935.jpg" alt="图1-RabbitMQ 的整体模型架构"></p><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。</p><ul><li><p><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</p></li><li><p><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</p></li><li><p><strong>Exchange(交换器)</strong> ：用来接收生产者发送的消息并将这些消息路由给服务器中的队列中。RabbitMQ 有四种交换器类型。</p></li><li><p><strong>Queue(消息队列)</strong> ：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。</p></li><li><p><strong>RabbitMQ Broker</strong> 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。</p></li></ul><h1 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2 RabbitMQ安装"></a>2 RabbitMQ安装</h1><blockquote><p>RabbitMQ官网查看版本支持：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a>  </p><p>erlang 官网：<a href="https://www.erlang.org/">https://www.erlang.org</a>   (不要在这里下载)</p><p>下载rabbitmq-server-3.8.19-1.el7.noarch.rpm：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.19">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.19</a></p><p>下载erlang-solutions-2.0-1.noarch.rpm <a href="https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm">https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</a></p><p>环境准备：CentOS7.x    安装路径 /usr/rabbitmq</p></blockquote><h2 id="2-1-安装Erlang和RabbitMQ"><a href="#2-1-安装Erlang和RabbitMQ" class="headerlink" title="2.1 安装Erlang和RabbitMQ"></a>2.1 安装Erlang和RabbitMQ</h2><p>Erlang</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/rabbitmq <span class="comment">#再安装路径下创建文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /usr/rabbitmq <span class="comment">#进入安装文件夹</span></span><br><span class="line"><span class="comment">#使用 XFTP将两个安装包拷贝进rabbitmq文件夹下</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># erlang-solutions-2.0-1.noarch.rpm  </span></span><br><span class="line"><span class="comment"># rabbitmq-server-3.8.19-1.el7.noarch.rpm</span></span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm </span><br><span class="line">yum install -y erlang</span><br><span class="line">erl -v</span><br></pre></td></tr></table></figure><p>RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install -y socat</span><br><span class="line">rpm -Uvh rabbitmq-server-3.8.19-1.el7.noarch.rpm <span class="comment">#没用？</span></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="comment"># 查看服务状态，如图</span></span><br><span class="line">systemctl status rabbitmq-server.service</span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211941.png" alt="image-20210708005845710" style="zoom:67%;"><h2 id="2-2-RabbitMQWeb管理界面"><a href="#2-2-RabbitMQWeb管理界面" class="headerlink" title="2.2 RabbitMQWeb管理界面"></a>2.2 RabbitMQWeb管理界面</h2><blockquote><p>1 安装web端插件</p><p>2 重启服务，开放阿里云的安全组和防火墙</p><p>3 浏览器访问初始界面</p><p>4 授权新的账号和密码</p><ul><li>新增用户</li><li>设置用户的操作权限</li><li>为用户添加资源权限</li></ul><p>5 网页登录成功</p></blockquote><p>1 默认情况下，是没有安装web端的客户端插件，需要安装才可以生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment"># 说明：rabbitmq有一个默认账号和密码是：`guest`默认情况只能在 localhost本计下访问，所以需要添加一个远程登录的用户</span></span><br></pre></td></tr></table></figure><p>2 安装完毕以后，重启服务即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server #重启服务</span><br></pre></td></tr></table></figure><ul><li>一定要记住，在对应服务器（阿里云）的安全组、防火墙中开放<code>15672</code>端口</li></ul><p>3 在浏览器访问 <a href="http://47.98.220.123:15672/">http://47.98.220.123:15672/</a></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211948.jpg"></p><p>4 <strong>授权账号和密码</strong></p><ul><li>新增用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><ul><li>设置用户分配操作权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="comment"># 用户级别：</span></span><br><span class="line"><span class="comment"># administrator：可以登录控制台、查看所有信息、可以对 rabbitmq进行管理</span></span><br><span class="line"><span class="comment"># monitoring：监控者 登录控制台，查看所有信息</span></span><br><span class="line"><span class="comment"># policymaker：策略制定者 登录控制台，指定策略</span></span><br><span class="line"><span class="comment"># managment 普通管理员 登录控制台,只能看自己的信息</span></span><br></pre></td></tr></table></figure><ul><li>为用户添加资源权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot;&quot;.*&quot;&quot;.*&quot;</span><br></pre></td></tr></table></figure><p>5 网页登录成功 设置的账号密码均为admin</p><ul><li>访问 <a href="http://47.xx.xxx.xx:15672/">http://47.XX.XXX.XX:15672/</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211952.png" alt="image-20210708010313311" style="zoom:67%;"><h1 id="3-RabbitMQ五种工作模式"><a href="#3-RabbitMQ五种工作模式" class="headerlink" title="3 RabbitMQ五种工作模式"></a>3 RabbitMQ五种工作模式</h1><p>生产者、消费者是分别两个项目、通过RabbitMQ这个消息中间件的通道进行连接。RabbitMQ的后台页面上显示队列等中间件里面所有的全部信息。</p><p>先搭建项目环境</p><p>1 新建一个空项目rabbitmq</p><p>2 空项目下新建一个springboot项目rabbitmq-provider，勾选Web 和 RabbitMQ支持</p><p>3 配置rabbitmq-provider的配置文件application.yaml</p><p>4 导入依赖lombok\fastjson，编写实体类Vehicle表示车辆</p><p>5 重复234的操作，新建一个rabbitmq-consumer项目</p><p>6 阿里云开启防火墙和安全组的5672和5673端口！！【重要】</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#我这里仅写了ip 其余端口账号密码由于是演示 采用默认即可，不必要写</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">47.98</span><span class="number">.220</span><span class="number">.123</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="1、简单队列（Easy"><a href="#1、简单队列（Easy" class="headerlink" title="1、简单队列（Easy)"></a>1、简单队列（Easy)</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211957.png" alt="img"></p><p>　　<strong>一个生产者对应一个消费者！！！</strong></p><blockquote><p>生产者：</p><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><p>2 写EasyProviderServer类，发送JSON格式的信息</p><p>3 测试类中调用Server类中的方法，运行之。查看rabbitMQ后台页面</p></blockquote><p>1 建easy包 下写EasyRabbitConfig配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">easyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_easy_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写EasyProviderServer类，业务实现后发送JSON格式的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sendEasyMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            String s = JSON.toJSONString(<span class="keyword">new</span> Vehicle(i, i + <span class="string">&quot;easy车车&quot;</span>));</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;rabbit_easy_queue&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类中调用Server类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProviderApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EasyProviderServer easyProviderServer;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        easyProviderServer.sendEasyMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212001.png" alt="image-20210708105408993"></p><blockquote><p>消费者：</p><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><p>2 写EasyConsumer类，接受message信息，打印车辆信息</p><p>3 运行项目，消费队列中的信息</p><p>// 如果报错记得去rabbitmq控制页面Admin下设置admin的权限，点一下就好！！</p></blockquote><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">easyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_easy_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写EasyConsumer类，接受message信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_easy_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;easy模式：消费者接收到车辆消息: &quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行项目，发现队列清空了</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212005.png" alt="image-20210708124038722" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212008.png" alt="image-20210708124053092" style="zoom:67%;"><h2 id="2、work-模式"><a href="#2、work-模式" class="headerlink" title="2、work 模式"></a>2、work 模式</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212011.png" alt="img"></p><p>　　<strong>一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息！！！</strong></p><blockquote><p>生产者：和easy的完全一致，这里新建一个work包</p></blockquote><p>1 WorkRabbitConfig配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//work的神生产者和easy一样</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">workQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_work_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写WorkProviderServer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//work模式的生产者和easy的一样</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWorkMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;rabbit_work_queue&quot;</span>, JSON.toJSONString(<span class="keyword">new</span> Vehicle(i,i+<span class="string">&quot;work车车&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类中增加一个workTest()方法，运行之</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WorkProviderServer workProviderServer;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    workProviderServer.sendWorkMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212015.png" alt="image-20210708130550835"></p><blockquote><p>消费者：与easy中也很相似，就是WorkConsumer类下多写几个消费方法！！很简单</p></blockquote><p>1 写WorkRabbitConfig配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">workQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_work_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写WorkConsumer类，下面含三个方法即三个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work1</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work3</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者3--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行项目，发现队列清空了</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212020.png" alt="image-20210708130948085" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212023.png" alt="image-20210708131013920" style="zoom:67%;"><h2 id="3、发布-订阅模式（Fanout）"><a href="#3、发布-订阅模式（Fanout）" class="headerlink" title="3、发布/订阅模式（Fanout）"></a>3、发布/订阅模式（Fanout）</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212026.png" alt="img"></p><p><strong>一个消费者将消息首先发送到交换器，交换器绑定到多个队列，然后被监听该队列的消费者所接收并消费。</strong></p><p>ps:X表示交换器，在RabbitMQ中，交换器主要有四种类型:direct、fanout、topic、headers，这里的交换器是 fanout。</p><p>这里演示一个交换机绑定两个队列，每个队列分别被两个消费者监听的情况！！</p><blockquote><p>生产者：与work模式的不同在于FanoutExchangeConfig 中需要定义交换机并将队列与交换机绑定。这里新建一个fanout包</p></blockquote><p>1 FanoutConfig配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 发布订阅模式 配置两个队列一个交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列一</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">FanoutQueueOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_fanout_queue_one&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列二</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">FanoutQueueTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_fanout_queue_two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机 声明为FanoutExchange类型</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;fanout_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列一到交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> FanoutQueueOne 上方定义的队列一方法名  根据此方法名参数 器会自动注入对应bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fanoutExchange 上方定义的交换机方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutExchangeA</span><span class="params">(Queue FanoutQueueOne, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(FanoutQueueOne).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列二到交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> FanoutQueueTwo  上方定义的队列二方法名  根据此方法名参数 器会自动注入对应bean   当</span></span><br><span class="line"><span class="comment">     *                        然也可以省略参数 直接在bind中指定队列构建方法名 例如 FanoutQueueTwo()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fanoutExchange 上方定义的交换机方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutExchangeB</span><span class="params">(Queue FanoutQueueTwo, FanoutExchange  fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(FanoutQueueTwo).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 FanoutProviderServer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanoutMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;fanout_exchange&quot;</span>,<span class="string">&quot;&quot;</span>, JSON.toJSONString(<span class="keyword">new</span> Vehicle(i,i+<span class="string">&quot;发布订阅车车&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">FanoutProviderServer fanoutProviderServer;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fanoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fanoutProviderServer.sendFanoutMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>消费者：与work的不同在于出现了队列！！每个队列有属于自己的消费者</p></blockquote><p>1 FanoutConfig与生产者相同</p><p>2 FanoutConsumer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerOne</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_one队列 消费者1：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerOne2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_one队列 消费者2：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------一个队列绑定两个消费者 --------------------------------</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTwo</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_two队列 消费者1：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTwo2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_two队列 消费者2：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212031" alt="image-20200715222028261" style="zoom:80%;"><p>？交换机中有10辆车，结果是：每个队列中都有10辆车、然后每个消费者只收到5个订阅？（有点不太符合常理、队列的里面也应该只有5辆车才对啊）</p><h2 id="4、路由模式-Direct"><a href="#4、路由模式-Direct" class="headerlink" title="4、路由模式(Direct)"></a>4、路由模式(Direct)</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212034.png" alt="img"></p><p>生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。</p><p><strong>也就是让消费者有选择性的接收消息。</strong></p><blockquote><p>生产者：</p></blockquote><blockquote><p>消费者：</p></blockquote><h2 id="5、主题模式-Topic"><a href="#5、主题模式-Topic" class="headerlink" title="5、主题模式(Topic)"></a>5、主题模式(Topic)</h2><p>　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212039.png" alt="img"></p><p>上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。</p><p><strong>符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。</strong></p><blockquote><p>生产者：</p></blockquote><blockquote><p>消费者：</p></blockquote><h1 id="4-RabbitMQ进阶"><a href="#4-RabbitMQ进阶" class="headerlink" title="4 RabbitMQ进阶"></a>4 RabbitMQ进阶</h1><p>（下次一定，目前学会整合RabbitMQ就行07/08）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神RabbitMQ教学视频学习笔记，包括消息队列介绍、RabbitMQ安装、RabbitMQ的5中订阅和发布的模式Demo等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RabbitMQ" scheme="https://wukang555.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Linux_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/07/05/%E6%A1%86%E6%9E%B6_08_Linux_wukang/"/>
    <id>https://wukang555.github.io/2021/07/05/%E6%A1%86%E6%9E%B6_08_Linux_wukang/</id>
    <published>2021-07-05T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:15.737Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Linux教学视频学习笔记，包括购买服务器、Linux简介、Linux文件、Vim编辑器、磁盘管理、环境安装等内容</p><a id="more"></a><h1 id="0-前置环境部署"><a href="#0-前置环境部署" class="headerlink" title="0 前置环境部署"></a>0 前置环境部署</h1><blockquote><p>购买服务器及环境部署</p><p>1 阿里云购买服务器</p><p>2 安装宝塔部署开发环境</p></blockquote><h2 id="0-1-阿里云购买及部署"><a href="#0-1-阿里云购买及部署" class="headerlink" title="0.1 阿里云购买及部署"></a>0.1 阿里云购买及部署</h2><blockquote><p>阿里云购买连接 <a href="https://developer.aliyun.com/plan/grow-up">https://developer.aliyun.com/plan/grow-up</a></p><p>1 购买阿里云</p><p>2 进入阿里云控制台、创建安全组</p><p>3 然后在控制台、点击<strong>轻量应用服务器</strong>进入你的服务器列表、修改密码并重启、概述里可以看到ip地址、也可以设置密码  <a href="https://swas.console.aliyun.com/">https://swas.console.aliyun.com/</a></p><p>4 下载Xshell的SSH工具、远程连接服务器  <a href="https://www.netsarang.com/zh/xshell/">https://www.netsarang.com/zh/xshell/</a></p></blockquote><p>1 购买阿里云</p><ul><li>我选的轻量应用服务器2核2G，新人99/年。购买时选择系统镜像、CentOS7.6即可。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211709.png" alt="image-20210705083032303" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211714.png" alt="image-20210705083300326" style="zoom: 50%;"><p>2 进入阿里云控制台、创建安全组</p><ul><li>点击云服务器ECS、侧边栏的网络与安全-安全组、创建安全组（默认就行）</li><li>如果购买的是轻量应用服务器这里是没有ECS服务器的、在这里创建安全组就可以了</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211717.png" alt="image-20210705084425389" style="zoom: 33%;"><p>3 进入<strong>轻量应用服务器</strong>列表、修改密码并重启、概述里可以看到ip地址、也可以设置密码</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211719.png" alt="image-20210705084659511" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211721.png" alt="image-20210705084831033" style="zoom: 33%;"><p>4 下载Xshell的SSH工具、远程连接服务器  </p><ul><li>无脑下载安装就完事，注意Xshell和XFTP都要安装</li><li>连接时新建会话、填入主机名（就是Ip地址），账号密码等等，就可以连接成功</li><li>连接教程：<a href="https://jingyan.baidu.com/article/f3e34a12f45306f5ea653542.html">https://jingyan.baidu.com/article/f3e34a12f45306f5ea653542.html</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211725.png" alt="image-20210705085231311" style="zoom:50%;"><h2 id="0-2-安装宝塔部署开发环境"><a href="#0-2-安装宝塔部署开发环境" class="headerlink" title="0.2 安装宝塔部署开发环境"></a>0.2 安装宝塔部署开发环境</h2><blockquote><p>1 安装宝塔 官方有详细教程 <a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>​    唯一要注意的就是开端口，安全组和防火墙两处都需要开启8888端口</p><p>2 进入宝塔管理面板一键部署应用</p></blockquote><p>1 安装宝塔 得到url 、username、password</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211728.png" alt="img" style="zoom: 50%;"><p>2 宝塔管理面板的软件商店一键部署应用</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211731.png" alt="image-20210705090046831" style="zoom: 33%;"><h1 id="1-Linux简介"><a href="#1-Linux简介" class="headerlink" title="1 Linux简介"></a>1 Linux简介</h1><p><strong>Linux简介</strong></p><p>​        Linux是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX (可移植操作系统接口)和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。<br>​        Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux 继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p><strong>Linux发行版</strong></p><p>发行版就是将Linux内核与应用软件做一个打包<br><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211734.png" alt="在这里插入图片描述"></p><p>​        今天各种场合都有使用各种Linux发行版,从嵌入式设备到超级计算机,并且在服务器领域确定了地位,通常服务器使用LAMP(Linux + Apache + MySQL + PHP)或LNMP(Linux + Nginx + MySQL + PHP)组合。目前Linux不仅在家庭与企业中使用,并且在政府中也很受欢迎。</p><h1 id="2-Linux常用命令"><a href="#2-Linux常用命令" class="headerlink" title="2 Linux常用命令"></a>2 Linux常用命令</h1><h2 id="2-1-系统目录"><a href="#2-1-系统目录" class="headerlink" title="2.1 系统目录"></a>2.1 系统目录</h2><p>1、Linux系统 一切皆文件<br>2、根目录/ ,所有的文件都挂载在这个节点下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="comment">#查看当前下的目录、可能时最常用的命令</span></span><br><span class="line">ls -a <span class="comment">#查看当前目录下的所有目录，包括隐藏</span></span><br><span class="line">ls -l <span class="comment">#列出当前下目录的包含文件的属性与权限等等数据；(常用)</span></span><br><span class="line">ls -al <span class="comment">#列出当前下目录的包含文件的属性与权限等等数据,包括隐藏</span></span><br><span class="line">ls / <span class="comment">#查看根目录/下的目录</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211741.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</span><br><span class="line">&#x2F;boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">&#x2F;dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">&#x2F;etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">&#x2F;home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</span><br><span class="line">&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">&#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</span><br><span class="line">&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</span><br><span class="line">&#x2F;opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</span><br><span class="line">&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</span><br><span class="line">&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</span><br><span class="line">&#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</span><br><span class="line">&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。</span><br><span class="line">&#x2F;sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</span><br><span class="line">&#x2F;tmp：这个目录是用来存放一些临时文件的。 用完即丢的文件可以放在这个目录下</span><br><span class="line">&#x2F;usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</span><br><span class="line">&#x2F;usr&#x2F;bin： 系统用户使用的应用程序。</span><br><span class="line">&#x2F;usr&#x2F;sbin： 超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">&#x2F;usr&#x2F;src： 内核源代码默认的放置目录。</span><br><span class="line">&#x2F;var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br><span class="line">&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</span><br><span class="line">&#x2F;www：存放服务器网站相关的资源，环境，网站的项目</span><br></pre></td></tr></table></figure><h2 id="2-2-目录管理【重要】"><a href="#2-2-目录管理【重要】" class="headerlink" title="2.2 目录管理【重要】"></a>2.2 目录管理【重要】</h2><p>切换目录cd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">cd</span> [绝对路径] <span class="comment">#切换至该绝对路径下</span></span><br><span class="line"><span class="built_in">cd</span> /  <span class="comment">#表示切换到根目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..  <span class="comment">#表示返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment"># 表示回到/root目录下（特殊）</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示目前所在的目录</span></span><br><span class="line"><span class="built_in">pwd</span> -P <span class="comment"># 如果是链接，要显示真实地址</span></span><br></pre></td></tr></table></figure><p>创建目录 mkdir</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p test2/test3/test4 <span class="comment"># 用-p递归创建层级目录</span></span><br></pre></td></tr></table></figure><p>删除空的目录 rmdir</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p test2/test3/test4 <span class="comment">#递归删除文件</span></span><br></pre></td></tr></table></figure><p>复制文件或者目录 cp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/install.sh /home <span class="comment">#将install.sh 复制到home文件夹中</span></span><br></pre></td></tr></table></figure><p>移除文件或者目录 rm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f <span class="comment">#忽略不存在的文件,不会出现警告,强制删除!</span></span><br><span class="line">-r <span class="comment">#递归删除目录! 这是非常危险的选项！！！</span></span><br><span class="line">-i <span class="comment">#互动,删除询问是否删除</span></span><br><span class="line">rm -rf install.sh  <span class="comment">#删除系统中的install.sh</span></span><br></pre></td></tr></table></figure><p>移动文件或者目录|重命名文件 mv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f <span class="comment">#强制</span></span><br><span class="line">-u <span class="comment">#只替换已经更新过的文件</span></span><br><span class="line">mv install.sh cqhstudy <span class="comment">#移动文件</span></span><br><span class="line">mv cqhstudy cqhstudy2 <span class="comment">#重命名文件夹名</span></span><br></pre></td></tr></table></figure><h2 id="2-3-基本属性"><a href="#2-3-基本属性" class="headerlink" title="2.3 基本属性"></a>2.3 基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><h3 id="1-基本属性查看"><a href="#1-基本属性查看" class="headerlink" title="1 基本属性查看"></a>1 基本属性查看</h3><p>下面以/home目录下的几个文件或目录的基本属性作为介绍：<code>ls -l</code>查看文件属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp14cwp14hjrpbcb149wZ /]<span class="comment"># cd /home</span></span><br><span class="line">[root@iZbp14cwp14hjrpbcb149wZ home]<span class="comment"># ls -l</span></span><br><span class="line">total 1668</span><br><span class="line">-rw-r--r-- 1 root  root  1694239 Jul  5 09:19 36、Linux使用.pdf</span><br><span class="line">drwx------ 3 admin admin    4096 Jul  4 20:33 admin</span><br><span class="line">drwx------ 2 redis redis    4096 Jul  4 22:00 redis</span><br><span class="line">drwx------ 3 www   www      4096 Jul  4 22:00 www</span><br><span class="line">[root@iZbp14cwp14hjrpbcb149wZ home]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>以<code>36、Linux使用.pdf</code>这个pdf文件为例，属性分为几个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  前十个字符：表示类型和读写权限</span><br><span class="line">1  表示hard links的个数</span><br><span class="line">root  root  表述属主和属组都是root</span><br><span class="line">1694239 表示文件的大小？（对的）</span><br><span class="line">Jul  5 09:19 36、Linux使用.pdf 表示时间和文件名</span><br></pre></td></tr></table></figure><p>每个文件的属性由左边第一部分的10个字符来确定 (如下图) :</p><ul><li>第一位表示文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当为[d]则是目录</span><br><span class="line">当为[-]则是文件;</span><br><span class="line">若是[l]则表示为链接文档( link file);</span><br><span class="line">若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ;</span><br><span class="line">若是[c]则表示为装置文件里面的串行端口设备,例如键盘、鼠标( 一次性读取装置)。</span><br></pre></td></tr></table></figure><ul><li>后9位表示 权限，如下所示</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211747.png" alt="在这里插入图片描述" style="zoom: 25%;"><h3 id="2-修改文件的属性"><a href="#2-修改文件的属性" class="headerlink" title="2 修改文件的属性"></a>2 修改文件的属性</h3><p>1 chgrp :更改文件属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名文件名</span><br><span class="line"><span class="comment"># -R :递归更改文件属组,就是在更改某个目录文件的属组时,如果加上R的参数,那么该目录下的所有文件的属组都会更改。</span></span><br></pre></td></tr></table></figure><p>2、chown :更改文件属主,也可以同时更改文件属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 属主名文件名</span><br><span class="line">chown [-R] 属主名:属组名文件名</span><br></pre></td></tr></table></figure><p>3、chmod :更改文件9个属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h2 id="2-4-文件内容查看"><a href="#2-4-文件内容查看" class="headerlink" title="2.4 文件内容查看"></a>2.4 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="comment">#由第一行开始显示文件内容</span></span><br><span class="line">tac <span class="comment">#从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</span></span><br><span class="line">nl <span class="comment">#显示的时候，顺道输出行号！</span></span><br><span class="line">more <span class="comment">#一页一页的显示文件内容</span></span><br><span class="line">less <span class="comment">#与 more 类似，但是比 more 更好的是，他可以往前翻页！</span></span><br><span class="line">head <span class="comment">#只看头几行</span></span><br><span class="line">tail <span class="comment">#只看尾巴几行</span></span><br></pre></td></tr></table></figure><p>1 cat 由第一行开始显示文件内容  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv] 文件名</span><br><span class="line">-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</span><br><span class="line">-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</span><br><span class="line">-E ：将结尾的断行字节 $ 显示出来；</span><br><span class="line">-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</span><br><span class="line">-T ：将 [tab] 按键以 ^I 显示出来；</span><br><span class="line">-v ：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure><p>2 nl 显示的时候，顺道输出行号！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br><span class="line">-b ：指定行号指定的方式，主要有两种：</span><br><span class="line">-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</span><br><span class="line">-b t ：如果有空行，空的那一行不要列出行号(默认值)；</span><br><span class="line">-n ：列出行号表示的方法，主要有三种：</span><br><span class="line">-n ln ：行号在荧幕的最左方显示；</span><br><span class="line">-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</span><br><span class="line">-n rz ：行号在自己栏位的最右方显示，且加 0 ；</span><br><span class="line">-w ：行号栏位的占用的位数。</span><br></pre></td></tr></table></figure><p>3 more #一页一页的显示文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">move 文件</span><br><span class="line">more 这个程序的运行过程中，你有几个按键可以按的</span><br><span class="line">空白键 (space)：代表向下翻一页；</span><br><span class="line">    Enter ：代表向下翻『一行』；</span><br><span class="line">    /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</span><br><span class="line">    :f ：立刻显示出档名以及目前显示的行数；</span><br><span class="line">    q ：代表立刻离开 more ，不再显示该文件内容。</span><br><span class="line">    b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用</span><br></pre></td></tr></table></figure><p><strong>硬链接和软链接：</strong></p><ul><li>硬链接：A—B,假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种机制硬链接到一个重要文件上，防止误删</li><li>软链接：类似Windows下的快捷方式，删除源文件，快捷方式也就访问不了</li></ul><blockquote><p>操作步骤：<br>1 创建链接 ln命令！<code>ln</code>  <code>ln -s</code><br>2 touch命令创建文件！<br>3 echo输入字符串<br>4 删除f1之后，查看f2和f3的区别</p></blockquote><p>123步骤如下：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211831.png" alt="在这里插入图片描述"></p><p>4 删除f1之后，查看f2和f3的区别：</p><ul><li>f2 硬链接还在   f3软连接失效</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211834.png" alt="在这里插入图片描述"></p><h2 id="2-5-Vim编辑器【重要】"><a href="#2-5-Vim编辑器【重要】" class="headerlink" title="2.5 Vim编辑器【重要】"></a>2.5 Vim编辑器【重要】</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器。vim 是vi的升级，具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h3 id="1-三种输入模式"><a href="#1-三种输入模式" class="headerlink" title="1 三种输入模式"></a>1 三种输入模式</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是</p><ul><li>命令模式：敲击键盘动作会被Vim识别为命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 切换到输入模式，以输入字符。</span><br><span class="line">x 删除当前光标所在处的字符。</span><br><span class="line">: 切换到底线命令模式，以在最底一行输入命令。</span><br></pre></td></tr></table></figure><ul><li>输入模式：编辑文本、输入多行字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字符按键以及Shift组合，输入字符</span><br><span class="line">ENTER，回车键，换行</span><br><span class="line">BACK SPACE，退格键，删除光标前一个字符</span><br><span class="line">DEL，删除键，删除光标后一个字符</span><br><span class="line">方向键，在文本中移动光标</span><br><span class="line">HOME&#x2F;END，移动光标到行首&#x2F;行尾</span><br><span class="line">Page Up&#x2F;Page Down，上&#x2F;下翻页</span><br><span class="line">Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</span><br><span class="line">ESC，退出输入模式，切换到命令模式</span><br></pre></td></tr></table></figure><ul><li>底线命令模式 : 可以输入单个或多个字符的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q 退出程序</span><br><span class="line">w 保存文件</span><br><span class="line">&#x2F;&#x2F;一般就wq组合使用</span><br></pre></td></tr></table></figure><h3 id="2-vim新建txt文件示例"><a href="#2-vim新建txt文件示例" class="headerlink" title="2 vim新建txt文件示例"></a>2 vim新建txt文件示例</h3><blockquote><p>1 进入目标目录，执行 vim 文件名</p><p>2 按下 i 进入输入模式，编写文本内容</p><p>3 按下 ESC 按钮回到一般模式，执行wq保存并退出</p></blockquote><p>1 使用 vim 来建立一个名为 runoob.txt 的文件时，输入：</p><ul><li>直接输入 <strong>vim 文件名</strong> 就能够进入 vi 的一般模式了。文件不存在则新建、存在则修改。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211753.jpg" alt="img" style="zoom:33%;"><p>2 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</p><ul><li>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211756.jpg" alt="img" style="zoom:33%;"><p>3 按下 ESC 按钮回到一般模式，执行wq保存并退出</p><ul><li><p>按下 <strong>Esc</strong> 这个按钮，会发现画面左下角的 – INSERT – 不见了！，表示进入了一般模式</p></li><li><p>存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211758.jpg" alt="img" style="zoom:33%;"><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><h2 id="2-6-用户和用户组管理"><a href="#2-6-用户和用户组管理" class="headerlink" title="2.6 用户和用户组管理"></a>2.6 用户和用户组管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><blockquote><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul></blockquote><h3 id="1-Linux系统用户账号的管理"><a href="#1-Linux系统用户账号的管理" class="headerlink" title="1 Linux系统用户账号的管理"></a>1 Linux系统用户账号的管理</h3><p><strong>用户账号的管理</strong>：添加、修改和删除。</p><p>添加账号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure><p>删除账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure><p>修改帐号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure><p><strong>用户口令的管理：</strong></p><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><ul><li>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure><h3 id="2-Linux系统用户组的管理"><a href="#2-Linux系统用户组的管理" class="headerlink" title="2 Linux系统用户组的管理"></a>2 Linux系统用户组的管理</h3><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p>增加一个新的用户组使用groupadd命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure><p>删除一个已有的用户组，使用groupdel命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><p>修改用户组的属性使用groupmod命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure><p>用户可以在用户组之间切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br><span class="line"><span class="comment"># 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-磁盘管理"><a href="#2-7-磁盘管理" class="headerlink" title="2.7 磁盘管理"></a>2.7 磁盘管理</h2><blockquote><p>占个坑，以后来补，下次一定。</p></blockquote><h3 id="1-磁盘管理"><a href="#1-磁盘管理" class="headerlink" title="1 磁盘管理"></a>1 磁盘管理</h3><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><blockquote><p>Linux磁盘管理常用三个命令为df、du和fdisk。</p><ul><li>df：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li><li>fdisk：用于磁盘分区</li></ul></blockquote><h3 id="2-磁盘格式化"><a href="#2-磁盘格式化" class="headerlink" title="2 磁盘格式化"></a>2 磁盘格式化</h3><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 <code>mkfs</code>（make filesystem） 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs [-t 文件系统格式] 装置文件名</span><br></pre></td></tr></table></figure><h3 id="3-磁盘检验"><a href="#3-磁盘检验" class="headerlink" title="3 磁盘检验"></a>3 磁盘检验</h3><p>fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><h3 id="4-磁盘挂载与卸除"><a href="#4-磁盘挂载与卸除" class="headerlink" title="4 磁盘挂载与卸除"></a>4 磁盘挂载与卸除</h3><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><h2 id="2-8-进程管理"><a href="#2-8-进程管理" class="headerlink" title="2.8 进程管理"></a>2.8 进程管理</h2><p>在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。  每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。  </p><p>每个进程都可能以两种方式存在的。前台与后台 。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。  </p><p>ps 查看当前系统中正在执行的各种进程的信息！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps- xx：</span><br><span class="line">  -a 显示当前终端所有的进程信息</span><br><span class="line">  -u 以用户的信息显示进程</span><br><span class="line">  -x 显示后台运行进程的参数</span><br><span class="line"><span class="comment">#ps -aux  查看所有进程</span></span><br><span class="line">ps-aux|grep mysql  查看mysql相关进程</span><br><span class="line"><span class="comment">#命令格式：命令A|命令B，即命令A的正确输出作为命令B的操作对象（输入）</span></span><br><span class="line"><span class="comment"># grep 查找文件中符合条件的字符串</span></span><br></pre></td></tr></table></figure><p>kill 结束进程：杀掉进程 等价于Windows结束任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br><span class="line"><span class="comment"># 常用选项： -9 :表示强迫进程立即停止</span></span><br></pre></td></tr></table></figure><h1 id="3-环境安装"><a href="#3-环境安装" class="headerlink" title="3 环境安装"></a>3 环境安装</h1><blockquote><p>下载jdk\tomcat\docker，直接宝塔。。环境应该不用自己配吧？答：不用，真香。</p></blockquote><h2 id="3-1-安装Redis"><a href="#3-1-安装Redis" class="headerlink" title="3.1 安装Redis"></a>3.1 安装Redis</h2><p>Redis宝塔安装的6.X版本有问题，我这里卸载了手动安装一遍！！安装路径为 /www/server/redis</p><p>1 官网下载tar.gz文件，XFTP传到root文件夹下</p><p>2 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf redis-5.0.8.tar.gz</span><br></pre></td></tr></table></figure><p>3 移动redis目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /root/redis-5.0.8 /www/server/redis</span><br></pre></td></tr></table></figure><p>4 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>5 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/www/server/redis install</span><br></pre></td></tr></table></figure><p>6 后台启动Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line"><span class="comment"># 按ctrl+z退出</span></span><br></pre></td></tr></table></figure><p>7 修改配置文件redis.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将<span class="built_in">bind</span>注释</span><br><span class="line">将protected-mode设置为no</span><br><span class="line">daemonize改为yes</span><br></pre></td></tr></table></figure><p>8  运行redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis   <span class="comment">#进入redis目录</span></span><br><span class="line">./bin/redis-server ./redis.conf <span class="comment">#开启服务</span></span><br><span class="line">src/./redis-cli <span class="comment">#建立连接</span></span><br></pre></td></tr></table></figure><p>9 查看连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep redis <span class="comment">#查看redis相关的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程号  <span class="comment">#强制关闭某进程</span></span><br></pre></td></tr></table></figure><p>10 关闭连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>11 使命令全局可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /www/server/redis/src/redis-server /usr/<span class="built_in">local</span>/bin/redis-server</span><br><span class="line">sudo cp /www/server/redis/src/redis-cli /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>12 新的建立连接命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli <span class="comment">#直接运行 舒服了</span></span><br></pre></td></tr></table></figure><h2 id="3-2-LInux运行jar包，跑起来"><a href="#3-2-LInux运行jar包，跑起来" class="headerlink" title="3.2 LInux运行jar包，跑起来"></a>3.2 LInux运行jar包，跑起来</h2><p>然后我们打包一个不需要连接数据库的项目springboot-03-web02，看看能不能直接在服务器上跑起来。</p><blockquote><p>1 保证能运行起来，然后clear、package</p><p>2 target下找到jar包，在Windows本地资源目录下cmd命令窗口运行之</p><p>​    java -jar 文件名  #确保能够在本地跑起来</p><p>3 用XFTP将该jar包丢入服务器某个文件夹下</p><p>4 查看防火墙开启了哪些端口，如果要用的端口没开请启用之。</p><p>5 查看进程占用了哪些端口、如果被占用了、请kill该进程</p><p>6 定位目标文件夹 java -jar运行之，公网ip即可访问该网站</p></blockquote><p>123过于傻瓜操作、我不屑之。</p><p>4 查看防火墙开启了哪些端口，如果要用的端口没开请启用之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-portsv <span class="comment">#查看已开启的端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=9000/tcp --permanent  <span class="comment">#开启某个端口、这里以9000为例</span></span><br><span class="line">systemctl restart firewalld.service <span class="comment">#重启防火墙命令 发现有9000了（如果是阿里云还要设置安全组）</span></span><br></pre></td></tr></table></figure><p>5 查看进程占用了哪些端口、如果被占用了、请kill该进程</p><ul><li>我操作时项目发布是默认8080端口，但被占用了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp|grep 80  <span class="comment">#查看80相关的端口、被占用的情况，找到进程id</span></span><br><span class="line"><span class="built_in">kill</span> -9 4770  <span class="comment">#例如，如果是4770进程占用，就关闭之。</span></span><br><span class="line">netstat -lnp|grep 80 <span class="comment">#关闭之后记得再次查看端口占用情况，如果还占用、继续kill</span></span><br></pre></td></tr></table></figure><p>6 定位目标文件夹 java -jar运行之，公网ip即可访问该网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/wukang</span><br><span class="line">java -jar springboot-03-web02.jar</span><br><span class="line"><span class="comment"># 然后就跑起来了...嘿嘿嘿嘿嘿</span></span><br></pre></td></tr></table></figure><p>登录之、一切正常：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211808.png" alt="image-20210705201741583" style="zoom: 33%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211811.png" alt="image-20210705201903075" style="zoom: 33%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Linux教学视频学习笔记，包括购买服务器、Linux简介、Linux文件、Vim编辑器、磁盘管理、环境安装等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://wukang555.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/30/%E6%A1%86%E6%9E%B6_07_Redis_wukang/"/>
    <id>https://wukang555.github.io/2021/06/30/%E6%A1%86%E6%9E%B6_07_Redis_wukang/</id>
    <published>2021-06-30T14:55:00.000Z</published>
    <updated>2022-05-17T12:14:34.367Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Redis教学视频学习笔记，包括NoSQL介绍、Redies数据类型、Redis事务、整合SpringBoot、Redis持久化、Redis主从复制等内容</p><a id="more"></a><blockquote><p>[1] 主要框架及内容都是狂神Redis的课堂笔记 <a href="https://www.kuangstudy.com/">https://www.kuangstudy.com/</a></p><p>[2] 参考了javaguide的文章 <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all?id=_1-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-redis-%e5%91%97">redis</a></p></blockquote><h1 id="1-NoSQL概述"><a href="#1-NoSQL概述" class="headerlink" title="1 NoSQL概述"></a>1 NoSQL概述</h1><h2 id="1-1-数据库架构的演变"><a href="#1-1-数据库架构的演变" class="headerlink" title="1.1 数据库架构的演变"></a>1.1 数据库架构的演变</h2><blockquote><p>数据库架构演进：</p><p>1 单机MySQL的美好年代  </p><p>2 Memcached（缓存）+ MySQL + 垂直拆分（多个完整的数据库）</p><p>3 MySQL主从读写分离 （读写分离、主从复制）</p><p>4 分表分库 + 水平拆分 + Mysql 集群  </p><p>5 现在的架构</p></blockquote><p><strong>1 单机MySQL的美好年代</strong>  </p><ul><li>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211332.png" alt="image-20210704162507809" style="zoom: 67%;"><p><strong>2 Memcached（缓存）+ MySQL + 垂直拆分（多个完整的数据库）</strong></p><ul><li>Memcached缓解数据库的读取压力  </li><li>垂直拆分：多个完整的数据库供读写，缓解压力</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211334.png" alt="image-20210704162715236" style="zoom:67%;"><p><strong>3 MySQL主从读写分离 （读写分离、主从复制）</strong></p><ul><li>读写分离：使的大量的数据库用于读，部分用于写</li><li>主从复制：写数据库修改后、立马更新到读数据库，提高了读写性能和读库的可扩展性  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211339.png" alt="image-20210704162949719" style="zoom:67%;"><p><strong>4 分表分库 + 水平拆分 + Mysql 集群</strong>  </p><ul><li>MySQL主库的写压力开始出现瓶颈，开始流行使用分表分库来缓解写压力和数据增长的扩展问题  【重要】</li><li>MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211342.png" alt="image-20210704163213199" style="zoom:67%;"><p><strong>5 现在的架构</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211346.png" alt="image-20210704163340611" style="zoom: 67%;"><p><strong>目前的困境：</strong></p><p>MySQL关系数据库很强大，但是它并不能很好的应付所有的应用场景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。  </p><p>比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变的非常的小 。这时就需要用非关系型数据库NoSQL</p><h2 id="1-2-什么是NoSQL"><a href="#1-2-什么是NoSQL" class="headerlink" title="1.2 什么是NoSQL"></a>1.2 什么是NoSQL</h2><h3 id="1-NoSQL-概述"><a href="#1-NoSQL-概述" class="headerlink" title="1 NoSQL  概述"></a>1 NoSQL  概述</h3><p><strong>NoSQL = Not Only SQL 不仅仅是SQL，泛指非关系型的数据库 。</strong></p><p><strong>Nosql特点</strong></p><p>1 方便扩展（数据之间没有关系，很好扩展！）</p><p>2 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p><p>3 数据类型是多样型的！（不需要事先设计数据库，随取随用）</p><p><strong>大数据时代的3V和3高b</strong></p><p>大数据时代的3V ：指描述问题的<strong>海量Velume、多样Variety、实时Velocity</strong></p><p>大数据时代的3高 ： 指对程序的要求：<strong>高并发、高扩展性、高性能</strong></p><h3 id="2-Nosql的四大分类"><a href="#2-Nosql的四大分类" class="headerlink" title="2 Nosql的四大分类"></a>2 Nosql的四大分类</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>键值对（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, <strong>Redis</strong>, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td>Key 指向 Value 的键值对，用hash table实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td></tr></tbody></table><h3 id="3-关系型数据库和非关系型数据库的区别【理解背】"><a href="#3-关系型数据库和非关系型数据库的区别【理解背】" class="headerlink" title="3 关系型数据库和非关系型数据库的区别【理解背】"></a>3 关系型数据库和非关系型数据库的区别【理解背】</h3><ul><li>关系型数据库：<ul><li>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</li><li>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</li><li>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</li></ul></li><li>非关系型数据库 not only SQL<ul><li>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</li><li>面向高性能并发读写的key-value数据库</li><li>面向可扩展性的分布式数据库</li></ul></li><li>数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库</li></ul><h1 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2 Redis入门"></a>2 Redis入门</h1><blockquote><p>Redis：REmote DIctionary Server（远程字典服务器）  </p><p><a href="https://redis.io/">https://redis.io/</a> 官网  </p><p><a href="http://www.redis.cn/">http://www.redis.cn</a> 中文网  </p></blockquote><h2 id="2-1-Redis概述"><a href="#2-1-Redis概述" class="headerlink" title="2.1 Redis概述"></a>2.1 Redis概述</h2><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库（可以称之为内存中的数据库），可以存储键和五种不同类型的值之间的映射。</p><p>Redis 支持很多特性，<strong>例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</strong>具体的功能有：将内存异步写入硬盘、发布订阅系统消息、地图信息分析、定时器计数器等</p><h2 id="2-2-启动Redis"><a href="#2-2-启动Redis" class="headerlink" title="2.2 启动Redis"></a>2.2 启动Redis</h2><blockquote><p>宝塔安装有问题，我是后来自己安装，见Linux笔记。启动和运行的命令如下</p><p>redis-server /www/server/redis/redis.conf #指定配置文件<br>redis-cli #直接运行 舒服了</p></blockquote><p>启动Redis、并测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli -p 6379 <span class="comment">#使用默认端口6379开启连接</span></span><br><span class="line">ping <span class="comment">#测试是否成功，成功就返回PONG</span></span><br><span class="line"><span class="built_in">set</span> k1 helloworld <span class="comment">#设置一个键为k1,值为helloworld的键值对</span></span><br><span class="line">get k1 <span class="comment">#获取k1键的值，返回helloworld则成功</span></span><br></pre></td></tr></table></figure><p>查看系统当前进程、关闭redis连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新开一个连接窗口</span></span><br><span class="line">ps -ef|grep redis <span class="comment">#查看当前进程</span></span><br><span class="line">shutdown <span class="comment">#关闭连接</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></span><br><span class="line">ps -ef|grep redis <span class="comment">#查看当前进程</span></span><br></pre></td></tr></table></figure><ul><li>执行ps命令 发现进程正开启</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211353.png" alt="image-20210705220738127" style="zoom:67%;"><ul><li>关闭连接并退出</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211356.png" alt="image-20210705221251869"></p><ul><li>执行ps命令 发现进程已关闭</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211359.png" alt="image-20210705221355936" style="zoom:80%;"><h2 id="2-3-基础知识说明"><a href="#2-3-基础知识说明" class="headerlink" title="2.3 基础知识说明"></a>2.3 基础知识说明</h2><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库</p><blockquote><p>Select命令切换数据库</p><p>Dbsize查看当前数据库的key的数量</p><p>Flushdb：清空当前库</p><p>Flushall：清空全部的库</p></blockquote><p>Redis为什么使用单线程？</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p>为什么要用Redis/为什么要用缓存？</p><p>高性能：</p><ul><li>缓存位于内存中，直接操作内存比读取数据库更快</li><li>为了保证数据的一致性，数据库中的数据改变时需要同时改变缓存中的数据</li></ul><p>高并发</p><ul><li>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g）</li><li>使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</li></ul><blockquote><p>QPS（Query Per Second）每秒查询率，是用来衡量服务性能的一个重要指标</p></blockquote><h1 id="3-五大数据类型-2"><a href="#3-五大数据类型-2" class="headerlink" title="3 五大数据类型[2]"></a>3 五大数据类型[2]</h1><h2 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h2><ol><li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li><li><strong>常用命令:</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li><li><strong>应用场景</strong> ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>普通字符串的基本操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value <span class="comment">#设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>批量设置</strong> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 <span class="comment"># 批量设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 <span class="comment"># 批量获取多个 key 对应的 value</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>过期</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure><h2 id="3-2-list"><a href="#3-2-list" class="headerlink" title="3.2 list"></a>3.2 list</h2><ol><li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li><li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li><li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList 1 <span class="comment"># 将 list的尾部(最左边)1个元素取出</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop myList2 1 <span class="comment"># 将 list的头部(最右边)的1个元素取出</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>我专门花了一个图方便小伙伴们来理解：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211406.png" alt="redis list"></p><p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p><p><strong>通过 <code>llen</code> 查看链表长度：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen myList</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="3-3-hash"><a href="#3-3-hash" class="headerlink" title="3.3 hash"></a>3.3 hash</h2><ol><li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li><li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li><li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;guide&quot;</span></span><br><span class="line">3) <span class="string">&quot;description&quot;</span></span><br><span class="line">4) <span class="string">&quot;dev&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;description&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line">1) <span class="string">&quot;guide&quot;</span></span><br><span class="line">2) <span class="string">&quot;dev&quot;</span></span><br><span class="line">3) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4 set"></a>3.4 set</h2><ol><li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li><li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li><li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard mySet <span class="comment"># 查看 set 的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-sorted-set"><a href="#3-5-sorted-set" class="headerlink" title="3.5 sorted set"></a>3.5 sorted set</h2><ol><li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li><li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-6-bitmap-不太懂"><a href="#3-6-bitmap-不太懂" class="headerlink" title="3.6 bitmap(不太懂)"></a>3.6 bitmap(不太懂)</h2><ol><li><strong>介绍 ：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li><li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li><li><strong>应用场景:</strong> 适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：</span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">0</span><br><span class="line"><span class="comment"># getbit 获取操作</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3 <span class="comment"># 查看周四是否打卡</span></span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6 <span class="comment"># 查看周七是否打卡</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># 统计这周打卡的记录，可以看到只有3天是打卡的状态：</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="4-Redis事务"><a href="#4-Redis事务" class="headerlink" title="4 Redis事务"></a>4 Redis事务</h1><p>Redis事务的简单理解就是将命令以队列的形式打包、放入一个队列中、然后一起执行所有命令。某条命令执行失败不会影响其他命令。Redis事务的操作和执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始事务（MULTI）。</span><br><span class="line">命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</span><br><span class="line">执行事务(EXEC)。</span><br></pre></td></tr></table></figure><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><ul><li>使用 <a href="https://redis.io/commands/multi"><code>MULTI</code></a>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec"><code>EXEC</code></a>命令将执行所有命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Guide哥&quot;</span></span><br></pre></td></tr></table></figure><ul><li>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话(在本事务外被修改)，整个事务都不会执行，直接返回失败。</li></ul><p>在本事务中修改watch的变量a,不会有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a 11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> a 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) <span class="string">&quot;11&quot;</span></span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;22&quot;</span></span><br></pre></td></tr></table></figure><p>在本事务外修改name的值，将会出错，<strong>整个事务都不会执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口1 事务</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;wukang1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment">#执行完这条后去窗口2</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment">#发现执行的结果为nil 出问题了</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 窗口2 修改name的值</span></span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;wukang1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;wukang2&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）</li><li>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</li><li>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</li></ul><h1 id="5-Jedis"><a href="#5-Jedis" class="headerlink" title="5 Jedis"></a>5 Jedis</h1><p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件。是springboot集成Redis的前置知识，了解即可。</p><p><strong>5.1 Jedis连接Redis</strong></p><p>直接new一个Jedis对象，填入ip和端口号，就可以了。步骤如下：</p><blockquote><p>1 新建一个redis-study的空项目，项目下建一个普通maven项目resid-01-jedis，注意我这里jdk用的11</p><p>2 导入redis依赖，开启本地windows下的redis软件，双击redis-server.exe 和 redis-cli.exe</p><p>3 编写测试代码、连接redis</p></blockquote><p>2 导入redis依赖，开启本地redis软件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 编写测试代码、连接redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.ping;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：连接成功！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211416.png" alt="image-20210706135357768" style="zoom:50%;"><p><strong>5.2 Jedis类的API调用</strong></p><p>连接和关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.connect(); <span class="comment">//连接</span></span><br><span class="line">jedis.disconnect(); <span class="comment">//断开连接</span></span><br></pre></td></tr></table></figure><p>对key操作的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB();</span><br><span class="line"><span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>)</span><br><span class="line"><span class="string">&quot;系统中所有的键如下：&quot;</span> Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"><span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey()</span><br><span class="line"><span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize()</span><br><span class="line"><span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll()</span><br></pre></td></tr></table></figure><p>对String操作的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mget();</span><br><span class="line">jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br></pre></td></tr></table></figure><p>对List操作命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jedis.lpush();</span><br><span class="line">jedis.rpop;</span><br><span class="line">jedis.lrange();</span><br><span class="line">jedis.ltrim();</span><br><span class="line">jedis.sort();</span><br></pre></td></tr></table></figure><p>对Set的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd();</span><br><span class="line">jedis.smembers();</span><br><span class="line">jedis.spop();</span><br><span class="line">jedis.sismember();</span><br><span class="line">jedis.sinter(); <span class="comment">//交集并集</span></span><br></pre></td></tr></table></figure><p>对Hash的操作命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jedis.hmset();</span><br><span class="line">jedis.hset();</span><br><span class="line">jedis.hgetAll();</span><br><span class="line">jedis.hkeys();</span><br><span class="line">jedis.hvals();</span><br><span class="line">jedis.hlen();</span><br><span class="line">jedis.hdel();</span><br><span class="line">jedis.hexists();</span><br><span class="line">jedis.hmget();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5.3 Jedis处理事务</strong></p><blockquote><p>//开启事务</p><p>Transaction multi = jedis.multi();</p></blockquote><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMulti</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端连接服务端，redis服务端需要被开启</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//向redis存入一条数据</span></span><br><span class="line">            multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">            <span class="comment">//再存入一条数据</span></span><br><span class="line">            multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">            <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">            <span class="comment">//int i = 100/0;</span></span><br><span class="line">            <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">            <span class="comment">//最终关闭客户端</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>没有出现异常（注释掉<code>int i = 100/0</code>)</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211421.png" alt="image-20210706142409593" style="zoom:50%;"><ul><li>出现异常</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211423.png" alt="image-20210706142445829" style="zoom:50%;"><h1 id="6-SpringBoot整合Redis"><a href="#6-SpringBoot整合Redis" class="headerlink" title="6 SpringBoot整合Redis"></a>6 SpringBoot整合Redis</h1><h2 id="6-1-使用内置RedisTemplate"><a href="#6-1-使用内置RedisTemplate" class="headerlink" title="6.1 使用内置RedisTemplate"></a>6.1 使用内置RedisTemplate</h2><p>先简单使用内置的RedisTemplate对象，用来连接和使用Redis</p><blockquote><p>0 开启本地windows下的redis软件，双击redis-server.exe 和 redis-cli.exe</p><p>1 新建一个springboot项目 勾选Redis</p><p>2 在application.properties配置文件中配置redis</p><p>3 在test文件夹下的Redis02SpringbootApplicationTests类中编写测试代码</p><p>4 运行contextLoads方法、测试</p></blockquote><p>1 新建一个springboot项目 勾选Redis，初始化的配置如下图</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211427.png" alt="image-20210706144801199" style="zoom: 50%;"><p>2 在application.properties配置文件中配置redis</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure><p>3  在test文件夹下的Redis02SpringbootApplicationTests类中编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;wukang&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 测试结果，打印值wukang成功！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211431.png" alt="image-20210706185427629" style="zoom:50%;"><p>事实上，所有Redis的命令都集成在RedisTemplate中，使用RedisTemplate.XX()即可调用，一些基本的原生命令，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.基本命令（原生命令，实际开发中需要使用工具类RedisUtils）</span></span><br><span class="line"><span class="comment">// redisTemplate  操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line"><span class="comment">// opsForValue    操作字符串 类似String</span></span><br><span class="line"><span class="comment">// opsForList     操作List 类似List</span></span><br><span class="line"><span class="comment">// opsForSet      操作Set</span></span><br><span class="line"><span class="comment">// opsForHash     操作Hash</span></span><br><span class="line"><span class="comment">// opsForZSet     操作ZSet</span></span><br><span class="line"><span class="comment">// opsForGeo      操作Geo</span></span><br><span class="line"><span class="comment">// opsForHyperLogLog  操作HyperLogLog</span></span><br></pre></td></tr></table></figure><h2 id="6-2-手动配置一个RedisTemplate"><a href="#6-2-手动配置一个RedisTemplate" class="headerlink" title="6.2 手动配置一个RedisTemplate"></a>6.2 手动配置一个RedisTemplate</h2><h3 id="1-为什么要自己配置"><a href="#1-为什么要自己配置" class="headerlink" title="1 为什么要自己配置"></a>1 为什么要自己配置</h3><p>对每一个组件springboot中都有一个XXXAutoConfiguration的自动配置类，和对应的XXXProperties，这里我们先看 <strong>RedisAutoConfiguration 自动配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class,JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt;redisTemplate(RedisConnectionFactory redisConnectionFactory)<span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span></span><br><span class="line">        <span class="comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。内置的RedisTemplate有一些缺点</p><ul><li>内置的RedisTemplate的泛型是&lt;Object,Object&gt;，，泛型为&lt;String,Object&gt;将会更好用</li><li>内置的RedisTemplate没有设置key及value的序列化方式</li></ul><p><strong>@ConditionalOnMissingBean(name = “redisTemplate”) 该注解表明我们自己配置一个RedisTemplate对象后、内置的RedisTemplate就不会被实例化了。所以这里我们自己写一个配置类RedisConfig配置之。</strong></p><h3 id="2-编写RedisConfig和工具类"><a href="#2-编写RedisConfig和工具类" class="headerlink" title="2 编写RedisConfig和工具类"></a>2 编写RedisConfig和工具类</h3><blockquote><p>1 编写RedisConfig类</p><p>2 写一个Redis工具类</p><p>3 测试</p></blockquote><p>1 编写RedisConfig类：主要工作是序列化、算是一个模板，也不知道到底有没有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RedisTemplate序列化配置 -- &gt;  注意要使用 @Qualifier(&quot;redisTemplate&quot;) 避免歧义（测试类中有使用案例）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.utils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类,位于test包下的哦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;wukang&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisConfigTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;吴康&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//将传入的对象序列化为json（自己配置RedisTemplate后就不需要这个）</span></span><br><span class="line">        <span class="comment">//String jsonUser=new ObjectMapper().writeValueAsString(user);</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisUtilTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisUtil.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;吴康工具人&quot;</span>);</span><br><span class="line">        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-Redis配置conf"><a href="#7-Redis配置conf" class="headerlink" title="7 Redis配置conf"></a>7 Redis配置conf</h1><p>目录下有redis.conf时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf <span class="comment">#进入编辑该文件的界面</span></span><br><span class="line">i <span class="comment">#进入编辑模式</span></span><br><span class="line">Esc <span class="comment">#退出编辑进入一般模式</span></span><br><span class="line">:q <span class="comment">#退出</span></span><br><span class="line">:wq <span class="comment">#保存并退出</span></span><br></pre></td></tr></table></figure><p>简单列几个重要的配置</p><ul><li>网络</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379 <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><ul><li>通用 GENERAL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span></span><br><span class="line">databases 16 <span class="comment"># 数据库的数量，默认是 16 个数据库</span></span><br></pre></td></tr></table></figure><ul><li>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof。redis 是内存数据库，如果没有持久化，那么数据断电及失！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试！</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存rdb文件的时候，进行错误的检查校验！</span></span><br><span class="line">dir ./ <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure><ul><li>SECURITY 安全，这里演示命令行设置一个密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span> <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 <span class="comment"># 使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><ul><li>APPEND ONLY 模式 aof配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></pre></td></tr></table></figure><h1 id="8-Redis-持久化"><a href="#8-Redis-持久化" class="headerlink" title="8 Redis 持久化"></a>8 Redis 持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化。</p><p>Redis 支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><h2 id="8-1-快照（snapshotting）持久化（RDB）"><a href="#8-1-快照（snapshotting）持久化（RDB）" class="headerlink" title="8.1 快照（snapshotting）持久化（RDB）"></a>8.1 快照（snapshotting）持久化（RDB）</h2><p>RDB（Redis DataBase）：Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s(15分钟)内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s(5分钟)内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s(1分钟)内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>RDB的优缺点</p><ul><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。<strong>如果需要进行大规模数据的恢复</strong>，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li><li>RDB的缺点是最后一次持久化后的数据可能丢失。</li><li>fork进程的时候，会占用一定的内存空间！！</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211447.png" alt="image.png" style="zoom:80%;"><h2 id="8-2-AOF（append-only-file）持久化"><a href="#8-2-AOF（append-only-file）持久化" class="headerlink" title="8.2 AOF（append-only file）持久化"></a>8.2 AOF（append-only file）持久化</h2><p>AOF将我们的所有命令都记录下来。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#让操作系统决定何时进行同步Copy to clipboardErrorCopied</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p>AOF的优缺点</p><ul><li>每一次修改都同步，文件的完整会更加好！</li><li>从不同步，效率最高的！</li><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li></ul><h1 id="9-Redis主从复制"><a href="#9-Redis主从复制" class="headerlink" title="9 Redis主从复制"></a>9 Redis主从复制</h1><h2 id="9-1-主从复制架构"><a href="#9-1-主从复制架构" class="headerlink" title="9.1 主从复制架构"></a>9.1 主从复制架构</h2><p>在第一节，数据库的架构演变中我们就提到过读写分离和主从复制。同样Redis所谓一种缓存（易失型数据），也有类似的主从复制的模式。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211451.png" alt="image-20210704162949719" style="zoom:67%;"><p>Redis主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）。</p><p><strong>主从复制的作用主要包括：</strong></p><ol><li>==数据冗余==：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>==故障恢复==：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>==负载均衡==：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>==高可用基石==：主从复制还是哨兵和集群能够实施的基础。</li></ol><p>真实的项目为了防止宕机不可能使用单机的Redis，所以主从复制的架构是必须的，并且最简单的情况是一主二从。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211454.png" alt="image.png" style="zoom: 50%;"><h2 id="9-2-一主二从环境配置"><a href="#9-2-一主二从环境配置" class="headerlink" title="9.2 一主二从环境配置"></a>9.2 一主二从环境配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info replication   <span class="comment"># 查看当前库的信息 执行</span></span><br><span class="line"><span class="comment"># 执行结果：</span></span><br><span class="line">role:master <span class="comment">#该服务器的角色是主机</span></span><br><span class="line">connected_slaves:0 <span class="comment">#该服务器没有从机</span></span><br></pre></td></tr></table></figure><p>我的redis.conf在 /www/server/redis目录下，经过全局后简化了开启redis的命令，如下：（全局命令见Linux笔记）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli <span class="comment">#直接运行 舒服了</span></span><br><span class="line">ps -aux | grep redis <span class="comment">#查看redis相关的进程</span></span><br></pre></td></tr></table></figure><h3 id="1-开始配置主从环境"><a href="#1-开始配置主从环境" class="headerlink" title="1 开始配置主从环境"></a>1 开始配置主从环境</h3><blockquote><p>这里通过开启多个进程来模拟主从环境只是一种演示，实际业务中是需要多台服务器的！！</p><p>1 复制并修改三个配置文件 redis79 redis80 redis81</p><p>2 三个会话窗口开启三个不同的服务</p><p>3 配置一主（79）二从（80、81），从机认老大</p></blockquote><p>1 复制并修改三个配置文件 redis79 redis80 redis81</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis</span><br><span class="line">cp redis.conf redis79.conf</span><br><span class="line">cp redis.conf redis80.conf</span><br><span class="line">cp redis.conf redis81.conf</span><br><span class="line">vim redis79.conf</span><br><span class="line">vim redis80.conf</span><br><span class="line">vim redis81.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分别修改 端口、oid文件名、log文件名、dump文件名</span><br><span class="line">1 指定端口 6379，依次类推</span><br><span class="line">2 Pid文件名字 pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid, 依次类推</span><br><span class="line">3 Log文件名字 logfile &quot;6379.log&quot;, 依次类推</span><br><span class="line">4 Dump.rdb文件名字 dbfilename dump6379.rdb, 依次类推</span><br></pre></td></tr></table></figure><p>2 三个会话窗口开启三个不同的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis79.conf</span><br><span class="line">redis-cli -p 6379</span><br><span class="line">redis-server /www/server/redis/redis80.conf</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">redis-server /www/server/redis/redis81.conf</span><br><span class="line">redis-cli -p 6381</span><br><span class="line">ps -aux | grep redis <span class="comment">#查看发现有三个进程 </span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211500.png" alt="image-20210707105010907" style="zoom: 50%;"><p>3 配置一主（79）二从（80、81），从机认老大</p><ul><li>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从就好了！</li><li>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里用的是命令，是暂时的！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 127.0.0.1 6379 <span class="comment">#两个从机分别执行</span></span><br></pre></td></tr></table></figure><h3 id="2-主从机的特点"><a href="#2-主从机的特点" class="headerlink" title="2 主从机的特点"></a>2 主从机的特点</h3><ul><li><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动从机保存！</p></li><li><p>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个候，主机如果回来了，从机依旧可以直接获取到该主机写的信息！</p></li><li><p>如果从机重启了（命令行来配置的主从的情况），就会变回主机（默认）！只要（重新设置）变为从机，立马就会从主机中获取值！</p><ul><li>只要是重新连接master，一次完全同步（全量复制）将被自动执行！</li></ul></li></ul><blockquote><p>复制原理</p><p>Slave 启动成功连接到 master 后会发送一个sync同步命令。</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p></li></ul></blockquote><p>在没有使用哨兵模式前，如果主机断开了连接，我们只能手动配置主机、从机！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF no one <span class="comment">#让自己变成主机</span></span><br></pre></td></tr></table></figure><h2 id="9-3-哨兵模式"><a href="#9-3-哨兵模式" class="headerlink" title="9.3 哨兵模式"></a>9.3 哨兵模式</h2><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵是一个独立的进程，作为进程，它会独立运行。</p><p>==其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。==</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211503.png" alt="image.png" style="zoom: 50%;"><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211509.png" alt="image.png" style="zoom:50%;"><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为 <strong>==主观下线==</strong> 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**==客观下线==**。</p><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ol><p><strong>缺点：</strong></p><ol><li>Redis 不好线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li></ol><h1 id="10-缓存穿透和缓存雪崩-2"><a href="#10-缓存穿透和缓存雪崩-2" class="headerlink" title="10 缓存穿透和缓存雪崩[2]"></a>10 缓存穿透和缓存雪崩[2]</h1><h2 id="10-1-缓存穿透"><a href="#10-1-缓存穿透" class="headerlink" title="10.1 缓存穿透"></a>10.1 缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211509.png" alt="image-20210707115232430"></p><p>解决缓存穿透问题，最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p>除了基本的参数校验方法外，还有缓存无效key和布隆过滤器</p><h3 id="1-缓存无效key"><a href="#1-缓存无效key" class="headerlink" title="1 缓存无效key"></a>1 缓存无效key</h3><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况.</p><p>如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2 布隆过滤器"></a>2 布隆过滤器</h3><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211513.png" alt="image" style="zoom: 80%;"><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><h2 id="10-2-缓存雪崩"><a href="#10-2-缓存雪崩" class="headerlink" title="10.2 缓存雪崩"></a>10.2 缓存雪崩</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong>可能导致宕机。</p><h3 id="缓存雪崩的原因"><a href="#缓存雪崩的原因" class="headerlink" title="缓存雪崩的原因"></a>缓存雪崩的原因</h3><ul><li>系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</li><li>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</li></ul><h3 id="缓存雪崩的解决办法："><a href="#缓存雪崩的解决办法：" class="headerlink" title="缓存雪崩的解决办法："></a>缓存雪崩的解决办法：</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h1 id="11-Redis发布订阅"><a href="#11-Redis发布订阅" class="headerlink" title="11 Redis发布订阅"></a>11 Redis发布订阅</h1><p>简单来说就是用Redis server作为一个消息队列，实现消息通信！！Redis可以做，但我后面要学RabittMQ，这里就不深究了</p><p><strong>发布订阅的示意图如下：</strong></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211517.png" alt="image.png"></p><p><strong>使用场景：</strong></p><ol><li>实时消息系统！</li><li>事实聊天！（频道当做聊天室，将信息回显给所有人即可！） </li><li>订阅，关注系统都是可以的！ 稍微复杂的场景我们就会使用 消息中间件MQ</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Redis教学视频学习笔记，包括NoSQL介绍、Redies数据类型、Redis事务、整合SpringBoot、Redis持久化、Redis主从复制等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Redis" scheme="https://wukang555.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/25/%E6%A1%86%E6%9E%B6_06_springboot_wukang/"/>
    <id>https://wukang555.github.io/2021/06/25/%E6%A1%86%E6%9E%B6_06_springboot_wukang/</id>
    <published>2021-06-25T14:55:00.000Z</published>
    <updated>2022-05-17T12:14:00.366Z</updated>
    
    <content type="html"><![CDATA[<p>狂神SpringBoot教学视频学习笔记，包括SpringBoot运行原理、配置文件、自动配置原理、静态资源导入、管理系统实战项目、整合Mybatis、SpringSecurity、Swagger等内容</p><a id="more"></a><h1 id="1-SpringBoot和微服务"><a href="#1-SpringBoot和微服务" class="headerlink" title="1 SpringBoot和微服务"></a>1 SpringBoot和微服务</h1><h2 id="1-1-SpringBoot介绍"><a href="#1-1-SpringBoot介绍" class="headerlink" title="1.1 SpringBoot介绍"></a>1.1 SpringBoot介绍</h2><p><strong>Spring家族</strong></p><p>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。Spring家族为我们提供了整个从开始构建应用到大型分布式应用全流程方案</p><ul><li>springboot用来快速构建一个个功能独立的微服务应用单元</li><li>spring cloud实现分布式，完成对大型分布式网络服务的调用</li><li>spring cloud data flow用于在分布式中间，进行流式数据计算、批处理</li></ul><p><strong>SpringBoot</strong></p><p>简单来说就是进一步减轻开发的难度和步骤、解放开发人员的一些复杂繁琐的代码和配置文件。</p><ul><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置。集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等）</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><h2 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2 微服务"></a>1.2 微服务</h2><blockquote><p>狂神讲的比较狗屎，这里参考一个博客园的文章：</p><p><a href="https://www.cnblogs.com/skabyy/p/11396571.html">https://www.cnblogs.com/skabyy/p/11396571.html</a></p></blockquote><p><strong>1 最开始简单的需求</strong></p><blockquote><p>只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。</p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210737.png" alt="img"></p><p><strong>2 业务发展 增加营销手段</strong></p><blockquote><p>开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。</p><p>拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。</p><p>精准营销。利用历史数据对用户进行分析，提供个性化服务。</p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210741.png" alt="img"></p><p>粗暴的增加架构、带来了很多不合理的地方：</p><ul><li>网站和移动端应用有很多相同业务逻辑的重复代码。</li><li>数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。</li><li>单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。</li><li>数据库表结构被多个应用依赖，无法重构和优化。</li><li>所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。</li><li>开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。</li></ul><p><strong>3 做出改变——微服务架构</strong></p><blockquote><p>在编程的世界中，最重要的便是<strong>抽象能力</strong>。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：</p><ul><li>用户服务、商品服务、促销服务、订单服务、数据分析服务</li></ul><p>各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。</p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210745.png" alt="img"></p><p>虽然很好，但因为数据库同时被多个服务依赖，仍有缺点：</p><ol><li>数据库成为性能瓶颈，并且有单点故障的风险。</li><li>数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。</li><li>数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。</li></ol><p><strong>4 拆分数据库、缓存、消息队列</strong></p><blockquote><p>如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：</p><p>完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。</p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210748.png" alt="img"></p><p>….后面还有很多、这里就先交待到这里。</p><h1 id="2-第一个springboot程序"><a href="#2-第一个springboot程序" class="headerlink" title="2 第一个springboot程序"></a>2 第一个springboot程序</h1><h2 id="2-1-创建spirngboot项目框架"><a href="#2-1-创建spirngboot项目框架" class="headerlink" title="2.1 创建spirngboot项目框架"></a>2.1 创建spirngboot项目框架</h2><p><strong>这里介绍使用IDEA的创建方式：</strong></p><p>1、创建一个新项目 new project</p><p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p><p>3、填写项目信息</p><p>4、选择初始化的组件（初学勾选 Web 即可）</p><p>5、填写项目路径</p><p>6、等待项目构建成功</p><p><strong>项目结构分析：</strong></p><p>删除暂时不用的文件，发现就是一个普通的maven项目的结果。一个src里面有java和resource；然后还有一个pom.xml的配置文件</p><p>1、程序的主启动类</p><p>2、一个 application.properties 配置文件</p><p>3、一个 测试类</p><p>4、一个 pom.xml</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210752.png" alt="image-20210626195613829" style="zoom:50%;"><h2 id="2-2-编写一个接口、打包cmd运行"><a href="#2-2-编写一个接口、打包cmd运行" class="headerlink" title="2.2 编写一个接口、打包cmd运行"></a>2.2 编写一个接口、打包cmd运行</h2><p><strong>Springboot只需要简单几步，就可以完成了一个web接口的开发，不走如下：</strong></p><p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210754.png" alt="image-20210626201703439" style="zoom:67%;"><p>2、在包中新建一个HelloController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RestController</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello the fuck world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210757.png" alt="image-20210626201825744" style="zoom:80%;"><p><strong>将项目打包、以便可以在“其他地方”运行</strong></p><p>1 点击 maven的 package，如果打包成功，则会在target目录下生成一个 jar 包</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210800.png" alt="1595397063721"></p><p>如果遇到以上②的错误，可以配置打包时跳过项目运行测试用例（自己百度的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 打成了jar包后，就可以在任何地方运行了！测试结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\helloword01-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210803.png" alt="1595397745294"></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210807.png" alt="image-20210626204655154" style="zoom:80%;"><h2 id="3-3-彩蛋？"><a href="#3-3-彩蛋？" class="headerlink" title="3.3 彩蛋？"></a>3.3 彩蛋？</h2><p>（先码住、回头再装逼。）</p><ol><li><p>更改端口号</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更改项目的端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure></li><li><p>如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；</p><p>只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。</p><p>图案可以到：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a> 这个网站生成，然后拷贝到文件中即可！</p></li></ol><p>​        <img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210815.png" alt="1595409428560" style="zoom:50%;"></p><p><strong>SpringBoot这么简单的东西背后一定有故事，我们之后去进行一波源码分析！</strong></p><h1 id="3-运行原理初探"><a href="#3-运行原理初探" class="headerlink" title="3 运行原理初探"></a>3 运行原理初探</h1><blockquote><p>有一说一，狂神这节讲的很拉跨。</p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210822.png" alt="springboot自动配置原理"></p><h2 id="3-1-SpringBootApplication-主配置"><a href="#3-1-SpringBootApplication-主配置" class="headerlink" title="3.1@SpringBootApplication 主配置"></a>3.1@SpringBootApplication 主配置</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置</p><ul><li><p><strong>@EnableAutoConfiguration 开启自动配置</strong></p><ul><li>@AutoConfigurationPackage自动配置包<ul><li>@Import({Registrar.class})：Spring底层注解@import ，用来导入（这个导入和下面的自动扫描配合使用）</li><li>Registrar.class 作用：自动配置包注册，将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</li></ul></li><li>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件【自动导包的核心】</li><li>{AutoConfigurationImportSelector.class} 自动配置导入选择器，选择了什么东西？<ul><li>getAutoConfigurationEntry() 获得自动配置的实体（调用下面）</li><li>getCandidateConfigurations() 获取候选的配置<ul><li>getSpringFactoriesLoaderFactoryClass（）方法，返回的就是我们最开始看的启动自动导入配置文件的注解类:EnableAutoConfiguration<ul><li>getCandidateConfigurations</li><li>protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {</li><li>return EnableAutoConfiguration.class;}</li></ul></li></ul></li><li>loadFactoryNames() 方法，获取所有的加载配置<ul><li>项目资源，最终获取一个资源:META-INF/spring.factories，位置在spring-boot-autoconfigure-2.5.2.jar包下<ul><li>META-INF<ul><li>spring.factories 所有的自动配置类全部在这里</li><li>思考：为什么这么多配置没有生效、需要导入对应的start才能有作用？<ul><li>XXAutoConfiguration，满足一定条件才生效</li></ul></li></ul></li></ul></li><li>系统资源，最终获取一个资源:META-INF/spring.factories</li><li>从这些资源中遍历了所有的nextElement（自动配置），封装成properties供我们使用</li></ul></li></ul></li><li>总结<ul><li>springboot的所有配置都在启动时扫描并加载，spirng.factories所有的自动装配类都在这里，但不一定生效，需要判断条件是否成立，只要导入了对应的start，有了对应的启动器，自动装配就会生效、配置成功。</li></ul></li><li>自动装配步骤：<ul><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>以前我们需要自动配置的东西，现在springboot帮我们做了</li><li>整合JavaEE，整体解决方案和自动配置的东西都在springboot-autoconfigure的jar包中；</li><li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器中</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并自动配置，@Configuration（javaConfig） ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ul></li></ul></li><li><p><strong>@SpringBootConfigurationspingboot的配置</strong></p><p>标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p><ul><li>@Configuration 配置（表明配置类，对应Spring的xml 配置文件）<ul><li>@Component 组件 （说明启动类本身也是Spring中的一个组件而已，负责启动应用！）</li></ul></li></ul></li><li><p><strong>@ComponentScan</strong> <strong>自动扫描包并加载符合条件的组件或者bean</strong></p></li></ul><h2 id="3-2-run方法流程分析（跳过）"><a href="#3-2-run方法流程分析（跳过）" class="headerlink" title="3.2 run方法流程分析（跳过）"></a>3.2 run方法流程分析（跳过）</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210835.png" alt="aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy91SkRBVUtyR0M3TDF2RlFNbmFSSUpTbWVaNThUMmVaaWNqYWZpYXdRTHA5dTh3YzRpYzFNank2T3lmaWJ6ZmpWb2ZlTDVwblMxTlNGS1ZqbElnNm5lSTl5U2cvNjQw"></p><h1 id="4-配置文件-yaml和-properties"><a href="#4-配置文件-yaml和-properties" class="headerlink" title="4 配置文件 .yaml和.properties"></a>4 配置文件 .yaml和.properties</h1><h2 id="4-1-配置文件分类"><a href="#4-1-配置文件分类" class="headerlink" title="4.1 配置文件分类"></a>4.1 配置文件分类</h2><p>Spring Boot 中有以下两种配置文件：bootstrap.properties（bootstrap.yml） 和 application.properties（application.yml）</p><p>application 配置文件主要用于 Spring Boot 项目的自动化配置(这里讲这个)。application.properties和 application.yml的优先级和语法结构不一样、但功能都是一样的。<strong>传统的xml与yaml、properties配置语法的对比如下:</strong></p><ul><li>传统xml配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>yaml配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server：</span></span><br><span class="line">  <span class="attr">prot:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><ul><li>properties配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><p>springboot推荐使用yaml配置、下面主要讲一下yaml的语法格式</p><h2 id="4-2-yaml配置的语法"><a href="#4-2-yaml配置的语法" class="headerlink" title="4.2 yaml配置的语法"></a>4.2 yaml配置的语法</h2><p><strong>yaml 的语法：</strong></p><ul><li><p>空格不能省略</p></li><li><p>以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p></li><li><p>属性和值的大小写都是十分敏感的。</p></li></ul><p>1 普通变量 k: v</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">wukang</span></span><br></pre></td></tr></table></figure><p>2 对象、或者键值对Map</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对象</span></span><br><span class="line"><span class="attr">student1:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">huang</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对象的行内写法</span></span><br><span class="line"><span class="attr">student2:</span> &#123;<span class="attr">name:</span> <span class="string">huang</span>,<span class="attr">age:</span> <span class="number">22</span>&#125;</span><br></pre></td></tr></table></figure><p>3 数组（list\set)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组</span></span><br><span class="line"><span class="attr">pet1:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数组的行类写法</span></span><br><span class="line"><span class="attr">pet2:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br></pre></td></tr></table></figure><p>4 修改默认配置，如端口号</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><h2 id="4-3-使用配置文件application-yml"><a href="#4-3-使用配置文件application-yml" class="headerlink" title="4.3 使用配置文件application.yml"></a>4.3 使用配置文件application.yml</h2><p>有三种方式，通常也会组合使用，如下：</p><blockquote><ul><li><p>直接用@Value(“${name}”)获取默认配置文件中的值</p></li><li><p><strong>@PropertySource ：</strong>加载指定属性的（*.properties）配置文件；（只能适用.properties）</p></li><li><p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；（@ConfigurationProperties(prefix = “personinfo”)这个注解一般加载实体类上面，用来将yaml中定义的所有属性，赋值给实体类的各个示例变量）</p></li></ul></blockquote><h3 id="1-Value-“-name-”"><a href="#1-Value-“-name-”" class="headerlink" title="1 @Value(“${name}”)"></a><strong>1 @Value(“${name}”)</strong></h3><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210842.png" alt="image-20210627163942918" style="zoom:50%;"><p>1 resources下建application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改默认端号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="comment">#两个普通变量值</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">wukangzuishuai</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"><span class="comment">#一个对象</span></span><br><span class="line"><span class="attr">personInfo:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wukang</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">19</span></span><br></pre></td></tr></table></figure><p>2 测试代码如下<code>GetPersonInfoController.java</code>文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    @SpringBootTest:用于测试的注解，可指定入口类或测试环境等</span></span><br><span class="line"><span class="comment">    @RunWith(SpringRunner.class):在Spring测试环境中进行测试。</span></span><br><span class="line"><span class="comment">    @Test：表示一个测试方法</span></span><br><span class="line"><span class="comment">    @Value：获取配置文件中的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetPersonInfoController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取配置文件中的age</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//获取配置文件中的name</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//该注解表示一个测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该注解表示一个测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 点击测试getName()方法。说明@Value(“${name}”)读取了配置文件中的name</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210848.png" alt="image-20210627164142165" style="zoom:50%;"><h3 id="2-PropertySource"><a href="#2-PropertySource" class="headerlink" title="2 @PropertySource()"></a>2 @PropertySource()</h3><p> 1 在application.properties文件中，写name和age两个属性值</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">wukangzuishuai555</span></span><br><span class="line"><span class="attr">age</span>=<span class="string">22</span></span><br></pre></td></tr></table></figure><p>2 在<code>GetPersonInfoController.java</code>类上面加上一个PropertySource注解，指定某个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(value &#x3D; &quot;classpath:application.properties&quot;)</span><br></pre></td></tr></table></figure><p>3 运行getName()或getAge()方法，结果说明使用了application.properties这个配置文件的值</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210851.png" alt="image-20210627165643867" style="zoom:67%;"><h3 id="3-configurationProperties"><a href="#3-configurationProperties" class="headerlink" title="3 @configurationProperties"></a><strong>3 @configurationProperties</strong></h3><blockquote><p>@ConfigurationProperties(prefix = “personinfo”)这个注解一般加载实体类上面，用来将yaml中定义的所有属性，赋值给实体类的各个实例变量</p><p>prefix = “personinfo”这个参数好像必须要小写，，我yaml里面是personInfo，然后这个也要用小写personinfo？</p></blockquote><p>1 写一个实体类personInfo，最后的目的就是用yaml的参数给实体类的变量赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//personinfo是yaml配置文件中的一个对象！！</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;personinfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">personInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 在<code>GetPersonInfoController.java</code>类下加一个测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Autowired注解解释：它表示被修饰的类需要注入对象。Spring会扫描所有被@Autowired标注的类，然后根据类型在loC容器中找到匹配的类进行注入。被@Autowired注解后的类不需要再导入文件。</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> personInfo personInfo1;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">getPersonYaml</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(personInfo1.getName()+personInfo1.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 并且进行测试，显示了yaml中personInfo对象定义的两个属性值</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210855.png" alt="image-20210627172024276" style="zoom:50%;"><h3 id="4-对比-Value和-ConfigurationProperties"><a href="#4-对比-Value和-ConfigurationProperties" class="headerlink" title="4 对比@Value和@ConfigurationProperties"></a>4 对比@Value和@ConfigurationProperties</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><ol><li><code>@ConfigurationProperties</code>只需要写一次即可 ， @Value则需要每个字段都添加</li><li>复杂类型封装，yml中可以封装对象 ， 使用value就不支持等…</li><li>JSR303数据校验 ， 这个就是我们可以在字段上增加一层过滤器验证 ， 可以保证数据的合法性</li><li><font color="red">松散绑定</font>：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</li></ol><p>结论：</p><ul><li><p>配置yml和配置properties都可以获取到值 ， **<font color="red">强烈推荐 yml</font>**；</p></li><li><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p></li><li><p>如果说，我们专门编写了一个<strong>JavaBean来和配置文件进行一一映射</strong>，就直接**@configurationProperties**，不要犹豫！</p></li></ul><h2 id="4-4-多配置环境切换、配置文件的加载顺序"><a href="#4-4-多配置环境切换、配置文件的加载顺序" class="headerlink" title="4.4 多配置环境切换、配置文件的加载顺序"></a>4.4 多配置环境切换、配置文件的加载顺序</h2><h3 id="1-多配置环境切换"><a href="#1-多配置环境切换" class="headerlink" title="1 多配置环境切换"></a>1 多配置环境切换</h3><p><strong>1 使用application.properties选择不同环境的配置文件</strong></p><p>​        因为开发和测试的环境一般不一样，为了快速切换环境，开发环境和测试环境会各写一个.properties配置文件。然后根据实际环境在主配置环境中，选择激活哪一个环境：</p><ul><li><p>application-test.properties 代表测试环境配置</p></li><li><p>application-dev.properties 代表开发环境配置</p></li><li><p>application.properties 代表主配置环境</p></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210858.png" alt="1595484043622"></p><p>通过application.properties的一个配置来选择需要激活的环境：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比如在配置文件中指定使用dev环境</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><p><strong>2 使用application.yaml选择不同环境的配置文件</strong></p><p>​        使用yml去实现不需要创建多个配置文件，直接在主配置文件application.yaml，写多种不同的环境，然后选择一个配置环境<code>spring: profiles: active: dev</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="comment">#选择要激活那个环境块</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span> <span class="comment">#配置环境的名称</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">test</span>  <span class="comment">#配置环境的名称</span></span><br></pre></td></tr></table></figure><h3 id="2-配置文件的加载顺序"><a href="#2-配置文件的加载顺序" class="headerlink" title="2 配置文件的加载顺序"></a>2 配置文件的加载顺序</h3><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210903.png" alt="1595482583892" style="zoom:67%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优先级1：项目路径下的config文件夹配置文件</span><br><span class="line">优先级2：项目路径下配置文件</span><br><span class="line">优先级3：资源路径下的config文件夹配置文件</span><br><span class="line">优先级4：资源路径下配置文件</span><br><span class="line">优先级由高到底，高优先级的配置会覆盖低优先级的配置；</span><br></pre></td></tr></table></figure><p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；并且同一个位置下，properties文件的优先级要大于yaml文件</strong></p><p>​        当然，后期运维时，也可以通过命令行的参数来指定配置文件的新位置；</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-boot-config.jar --spring.config.location=F:/application.properties</span><br></pre></td></tr></table></figure><h2 id="4-5-JSR303数据校验"><a href="#4-5-JSR303数据校验" class="headerlink" title="4.5 JSR303数据校验"></a>4.5 JSR303数据校验</h2><p>​        之前说过了  通过@ConfigurationProperties()注入属性可以使用 JSR303数据校验功能 ，下面介绍一下JSR303校验。</p><p>​        JSR303校验是用来规范输入内容的。根据“前端不可信”原则，后台最好再校验一遍数据，Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常。</p><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h3><blockquote><p>这里为了演示校验过程、重新写一个实体类、配置文件进行新的测试</p><p>1 编写一个Person实体类 含实例变量name age email hobbies等</p><p>2 编写yaml文件 对实体类中的变量赋值注入</p><p>3 写一个测试类 PersonControllerTest测试一下</p></blockquote><p>1 编写一个Person实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Boolean happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; hobbies;</span><br><span class="line">    <span class="comment">//有参无参构造、get、set方法、toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Component 表示该类被spring接管，是一个bean</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;person&quot;) 表示采用yaml中定义的属性，赋值给实体类的各个实例变量</span><br></pre></td></tr></table></figure><p>2 编写yaml文件 对实体类中的变量赋值注入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Person对象</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">luofeng</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">email:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">happy:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2000</span><span class="string">/01/01</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="attr">hobbies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">girl</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">music</span></span><br></pre></td></tr></table></figure><p>3 写一个测试类 PersonControllerTest测试，运行contextLoads方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/25/%E6%A1%86%E6%9E%B6_06_springboot_wukang/../../../%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/%25E6%25A1%2586%25E6%259E%25B6_06_springboot_wukang/image-20210627200458224.png" alt="image-20210627200458224"></p><p>发现所有的实例变量属性都正确的赋值给Person变量了</p><h3 id="2-JSR303校验邮箱"><a href="#2-JSR303校验邮箱" class="headerlink" title="2 JSR303校验邮箱"></a>2 JSR303校验邮箱</h3><p><strong>接下来使用 JSR303数据校验功能</strong>对email格式进行验证，发现如果注入1123456，无法运行；当注入<a href="mailto:&#49;&#x32;&#x33;&#52;&#53;&#x36;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;">&#49;&#x32;&#x33;&#52;&#53;&#x36;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a>时，可以运行成功。</p><p>1 添加validation启动器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 Person类上添加 @Validated 激活数据校验，email变量上面添加@Email</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//注册bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span>  <span class="comment">//数据校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email(message=&quot;邮箱格式错误&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 邮箱为123456，格式错误、运行报错</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210908.png" alt="image-20210627202206772" style="zoom: 50%;"><p>4 修改yaml中的邮箱值，再运行,正确</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Person对象</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">luofeng</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">email:</span> <span class="number">123456</span><span class="string">@163.com</span></span><br><span class="line">  <span class="string">....</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210911.png" alt="image-20210627202417584"></p><h3 id="3-JSR303校验常见参数"><a href="#3-JSR303校验常见参数" class="headerlink" title="3 JSR303校验常见参数"></a>3 JSR303校验常见参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message=&quot;名字不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="meta">@Max(value=120,message=&quot;年龄最大不能查过120&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="meta">@Email(message=&quot;邮箱格式错误&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">空检查</span><br><span class="line"><span class="meta">@Null</span>       验证对象是否为<span class="keyword">null</span></span><br><span class="line"><span class="meta">@NotNull</span>    验证对象是否不为<span class="keyword">null</span>, 无法查检长度为<span class="number">0</span>的字符串</span><br><span class="line"><span class="meta">@NotBlank</span>   检查约束字符串是不是Null还有被Trim的长度是否大于<span class="number">0</span>,只对字符串,且会去掉前后空格.</span><br><span class="line"><span class="meta">@NotEmpty</span>   检查约束元素是否为NULL或者是EMPTY.</span><br><span class="line">    </span><br><span class="line">Booelan检查</span><br><span class="line"><span class="meta">@AssertTrue</span>     验证 Boolean 对象是否为 <span class="keyword">true</span>  </span><br><span class="line"><span class="meta">@AssertFalse</span>    验证 Boolean 对象是否为 <span class="keyword">false</span>  </span><br><span class="line">    </span><br><span class="line">长度检查</span><br><span class="line"><span class="meta">@Size(min=, max=)</span> 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  </span><br><span class="line"><span class="meta">@Length(min=, max=)</span> string is between min and max included.</span><br><span class="line"></span><br><span class="line">日期检查</span><br><span class="line"><span class="meta">@Past</span>       验证 Date 和 Calendar 对象是否在当前时间之前  </span><br><span class="line"><span class="meta">@Future</span>     验证 Date 和 Calendar 对象是否在当前时间之后  </span><br><span class="line"><span class="meta">@Pattern</span>    验证 String 对象是否符合正则表达式的规则</span><br><span class="line"></span><br><span class="line">.......等等</span><br></pre></td></tr></table></figure><p>除此以外，我们还可以自定义一些数据校验规则</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210916.png" alt="1595480813196" style="zoom: 50%;"><h1 id="5-自动配置原理"><a href="#5-自动配置原理" class="headerlink" title="5 自动配置原理"></a>5 自动配置原理</h1><p>先思考一个原问题：配置文件到底能写什么？怎么写？答曰：<code>spring.factories</code>，看如下分解：</p><p>SpringBoot官方文档中有大量的配置，也就100多个？反正记不住。</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#core-properties">https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-application-properties.html#core-properties</a></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210919.png" alt="1595493746481" style="zoom:50%;"></blockquote><p>配置文件application.yaml如何与 类路径下的<code>META-INF/spring.factories</code>联系起来呢？</p><p><strong>一句话的结论就是：yaml配置文件能配置什么 就必然参照某个功能xxProperties对应的一个属性类</strong></p><h2 id="5-1-发现-spring-factories"><a href="#5-1-发现-spring-factories" class="headerlink" title="5.1 发现 spring.factories"></a>5.1 发现 spring.factories</h2><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration</p><p><strong>@EnableAutoConfiguration 作用</strong></p><ul><li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件</p></li><li><p>可以查看selectImports()方法的内容,他返回了一个autoConfigurationEnty,来自<code>this.getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</code>这个方法我们继续来跟踪：</p></li><li><p>这个方法有一个值：<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</code>叫做获取候选的配置 ，我们点击继续跟踪</p><ul><li><code>SpringFactoriesLoader.loadFactoryNames()</code></li><li>扫描所有jar包类路径下<code>META-INF/spring.factories</code></li><li>把扫描到的这些文件的内容包装成properties对象</li><li>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210923.png" alt="@EnableAutoConfiguration" style="zoom: 50%;"><p>现在我们来看一下<code>META-INF/spring.factories</code>（有好几页，这里只看前面一点点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br></pre></td></tr></table></figure><blockquote><p>AopAutoConfiguration、RabbitAutoConfiguration、BatchAutoConfiguration、HttpEncodingAutoConfiguration….等等等</p><p>每一个这样的 xxxAutoConfiguration类都是容器中的一个<strong>组件，都加入到容器中；用他们来做自动配置；</strong></p></blockquote><h2 id="5-2-HttpEncodingAutoConfiguration一个具体的自动配置类"><a href="#5-2-HttpEncodingAutoConfiguration一个具体的自动配置类" class="headerlink" title="5.2 HttpEncodingAutoConfiguration一个具体的自动配置类"></a>5.2 HttpEncodingAutoConfiguration一个具体的自动配置类</h2><p>我们以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；该类的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；</span></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line">   </span><br><span class="line"><span class="comment">//启动指定类的ConfigurationProperties功能；</span></span><br><span class="line">  <span class="comment">//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；</span></span><br><span class="line">  <span class="comment">//并把HttpProperties加入到ioc容器中</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)</span> </span><br><span class="line">   </span><br><span class="line"><span class="comment">//Spring底层@Conditional注解</span></span><br><span class="line">  <span class="comment">//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；</span></span><br><span class="line">  <span class="comment">//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；</span></span><br><span class="line">  <span class="comment">//如果不存在，判断也是成立的</span></span><br><span class="line">  <span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.http.encoding&quot;,</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;</span><br><span class="line">    <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//。。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果HttpEncodingAutoConfiguration这个配置类生效，我们就开始装配：</p><ul><li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li><li>这些组件的属性是从对应的XXproperties类中获取的，这些类里面的每一个属性又是和配置文件application.yaml绑定的；</li><li><strong>即所有application.yaml配置文件中能配置的属性都是在xxxxProperties类中封装着；</strong></li></ul><p>比如：spring.http这个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们去配置文件里面试试前缀，看提示！</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210928.png" alt="1595493884773"></p><p><strong>这就是自动装配的原理！</strong></p><h2 id="5-3-判断自动配置类是否生效"><a href="#5-3-判断自动配置类是否生效" class="headerlink" title="5.3 判断自动配置类是否生效"></a>5.3 判断自动配置类是否生效</h2><p>​        自动配置类必须在一定的条件下才能生效。用来判断的条件一般就是@Conditional的派生注解。<strong>必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效</strong></p><table><thead><tr><th>@Conditional扩展注解</th><th>作用(判断是否满足当前指定条件)</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnJava</td><td>容器中存在指定Bean ;</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean ;</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean ,或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p>​        那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</p><p><strong>查看一个配置类是否生效</strong>：</p><p>​        我们可以在application.properties通过启用 <code>debug=true</code>属性；在控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启springboot的调试类</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">true </span></span><br></pre></td></tr></table></figure><ul><li><p>Positive matches:（自动配置类启用的：正匹配）</p></li><li><p>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</p></li><li><p>Unconditional classes: （没有条件的类）</p></li></ul><h1 id="6-静态资源处理"><a href="#6-静态资源处理" class="headerlink" title="6 静态资源处理"></a>6 静态资源处理</h1><p>​        回顾一下以前的web项目，我们的main下会有一个webapp，存放所有的页面（jsp或html）。那么对springboot的项目来说，静态资源应该放在哪里呢？答案是resources下的各种包下面。先看下源码、理解是为什么。</p><h2 id="6-1-静态资源映射规则"><a href="#6-1-静态资源映射规则" class="headerlink" title="6.1 静态资源映射规则"></a>6.1 静态资源映射规则</h2><ul><li>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</li><li>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</li><li>有一个方法：addResourceHandlers 添加资源处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        <span class="comment">// 已禁用默认资源处理</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存控制</span></span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="comment">// 方法一：webjars 配置</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法二：静态资源配置 放在指定的几个文件夹下</span></span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的源码，发现<code>&quot;/webjars/**&quot;</code>就是一个资源的存放路径， 都需要去 <code>classpath:/META-INF/resources/webjars/</code> 找对应的资源。</p><p>所谓的Webjars，本质就是以jar包的方式引入我们的静态资源 ，也是下面介绍的第一种导入方式</p><h2 id="6-2-导入静态资源的三种方式"><a href="#6-2-导入静态资源的三种方式" class="headerlink" title="6.2 导入静态资源的三种方式"></a>6.2 导入静态资源的三种方式</h2><h3 id="1-webjars导入静态资源"><a href="#1-webjars导入静态资源" class="headerlink" title="1 webjars导入静态资源"></a>1 webjars导入静态资源</h3><p>Webjars的官网有将Webjars引入spingboot的各种依赖。网站：<a href="https://www.webjars.org/">https://www.webjars.org</a> </p><p>要使用jQuery的 静态资源，我们只要要引入jQuery对应版本的pom依赖即可！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210935.png" alt="1595506633980"></p><p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：<a href="http://localhost:8080/webjars/jquery/3.4.1/jquery.js">http://localhost:8080/webjars/jquery/3.4.1/jquery.js</a></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210937.png" alt="image-20210628102503664" style="zoom:50%;"><h3 id="2-导入自己的静态资源"><a href="#2-导入自己的静态资源" class="headerlink" title="2 导入自己的静态资源"></a>2 导入自己的静态资源</h3><p>1、那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210940.png" alt="1595516976999"></p><p>2、我们去找<code>staticPathPattern</code>发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 <code>resourceProperties</code> 这个类，我们可以点进去看一下分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入方法</span></span><br><span class="line"><span class="keyword">public</span> String[] getStaticLocations() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.staticLocations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到对应的值</span></span><br><span class="line"><span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line"><span class="comment">// 找到路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; </span><br><span class="line">    <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;classpath:/resources/&quot;</span>, </span><br><span class="line">    <span class="string">&quot;classpath:/static/&quot;</span>, </span><br><span class="line">    <span class="string">&quot;classpath:/public/&quot;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p><p>4、所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;classpath:/META-INF/resources/&quot;</span></span><br><span class="line"><span class="string">&quot;classpath:/resources/&quot;</span></span><br><span class="line"><span class="string">&quot;classpath:/static/&quot;</span></span><br><span class="line"><span class="string">&quot;classpath:/public/&quot;</span></span><br></pre></td></tr></table></figure><p>5、我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210944.png" alt="1595517831392" style="zoom: 50%;"><p>6、比如我们访问 <a href="http://localhost:8080/1.js">http://localhost:8080/1.js</a> , 他就会去这些文件夹中寻找对应的静态资源文件；</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210947.png" alt="image-20210628103359207"></p><p>实验了一下，优先级：resources&gt;static&gt;public</p><h3 id="3-自定义静态资源路径"><a href="#3-自定义静态资源路径" class="headerlink" title="3 自定义静态资源路径"></a>3 自定义静态资源路径</h3><p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/wukang/</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210950.png" alt="image-20210628103731965" style="zoom: 50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210954.png" alt="image-20210628103753708" style="zoom:67%;"><p><strong>显而易见，自己设置路径的优先级最高，但不推荐这样做，这样做会使其他静态资源的路径都失效！！</strong></p><h2 id="6-4-首页的定义"><a href="#6-4-首页的定义" class="headerlink" title="6.4 首页的定义"></a>6.4 首页的定义</h2><ul><li>WebMvcAutoConfiguration自动装配类<ul><li>welcomePageHandlerMapping()欢迎页面处理<ul><li>getWelcomePage()方法用来获取欢迎页面<ul><li>getIndexHtml()  获取首页的html页面</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欢迎页就是一个location下的的 index.html 而已</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(Resource location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Resource resource = location.createRelative(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource.exists() &amp;&amp; resource.getURL() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截图说明（old）：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210957.png" alt="1595550098734"></p><p>结论：</p><p><strong>在上面的3个目录resources、static、public中任意一个中键index.html页面，当我们访问 <a href="http://localhost:8080/%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%BF%99%E4%B8%AAindex.html%E9%A1%B5%E9%9D%A2%EF%BC%81%EF%BC%81">http://localhost:8080/，就会自动跳转到这个index.html页面！！</a></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是首页哦<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211001.png" alt="image-20210628105854439" style="zoom:67%;"><h1 id="7-模板引擎Thymeleaf"><a href="#7-模板引擎Thymeleaf" class="headerlink" title="7 模板引擎Thymeleaf"></a>7 模板引擎Thymeleaf</h1><p><strong>模板引擎就是将一个模板页面Template和一个后台的数据Data，解析并填充、形成最终的output.html页面</strong></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211003.png" alt="1595555521951"></p><p>以前我们一般使用jsp，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。但springboot默认不支持jsp，springboot推荐使用Thymeleaf模板引擎。</p><h2 id="7-1-Thymeleaf-引入"><a href="#7-1-Thymeleaf-引入" class="headerlink" title="7.1 Thymeleaf 引入"></a>7.1 Thymeleaf 引入</h2><p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p><ul><li><p>Thymeleaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p></li><li><p>Thymeleaf 在Github 的主页：<a href="https://github.com/thymeleaf/thymeleaf">https://github.com/thymeleaf/thymeleaf</a></p></li><li><p>Spring官方文档：找到我们对应的版本<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter </a></p></li></ul><p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--thymeleaf--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入之后我们看一下thymeleaf的源码，Thymeleaf的自动配置类：<code>ThymeleafProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.thymeleaf&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkTemplateLocation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String prefix = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String suffix = <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String mode = <span class="string">&quot;HTML&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Charset encoding;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到默认的路径和后缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String prefix = <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> String suffix = <span class="string">&quot;.html&quot;</span>;</span><br></pre></td></tr></table></figure><p>结论：</p><p><strong>只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</strong></p><p>下面简单写一个引入Thymeleaf的测试示例：</p><blockquote><p>1 在templates包下编写test.html 前端页面 ，注意引入命名空间的约束</p><p>2 编写测试请求，传输一个变量值给前端页面</p><p>3 启动测试、访问前端界面的url</p></blockquote><p>1 编写test.html 前端页面 ，引入Thymeleaf命名空间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意引入命名空间的约束 --&gt;</span></span><br><span class="line">xmlns:th=&quot;http://www.thymeleaf.org&quot;</span><br></pre></td></tr></table></figure><p>test.html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WuKang<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试一下<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;value_wk&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 编写测试请求，传输一个变量值value_wk给前端页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;value_wk&quot;</span>,<span class="string">&quot;Hello,Thymeleaf&quot;</span>);</span><br><span class="line">        <span class="comment">//classpath:/templates/test.html</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试并访问</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211008.png" alt="image-20210628140604670" style="zoom:67%;"><h2 id="7-2-Thymeleaf-语法"><a href="#7-2-Thymeleaf-语法" class="headerlink" title="7.2 Thymeleaf 语法"></a>7.2 Thymeleaf 语法</h2><blockquote><p>官方文档在此：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax</a></p></blockquote><p>大体上有个印象即可，不会的直接百度或者看官方文档。这里只演示一个遍历循环的取值。</p><p><strong>Thmeleft的循环遍历语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fragment iterationth:each</span><br></pre></td></tr></table></figure><p>1 编写一个测试方法，给前端传入一个map集合，含两个键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">test2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;pig&quot;</span>,<span class="string">&quot;tiger&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>,list);</span><br><span class="line">    <span class="comment">//classpath:/templates/test2.html</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 前端界面取数据，并展示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>  <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test02<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>取第一个键值对：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--不转义 用text--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;key1&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--转义 用utext--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;key1&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>取第二个键值对：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;animal:$&#123;key2&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;animal&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者用行内写法（不推荐）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;animal:$&#123;key2&#125;&quot;</span>&gt;</span>[[$&#123;animal&#125;]]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 测试并访问</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211014.png" alt="image-20210628145827744" style="zoom:50%;"><p>这里简要介绍一下Thymeleaf的基本变量和运算符号，其中<strong>条件运算（三元运算符）</strong>用的比较多</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Literals（字面量）</span><br><span class="line">      Text literals: &#39;one text&#39; , &#39;Another one!&#39; ,…</span><br><span class="line">      Number literals: 0 , 34 , 3.0 , 12.3 ,…</span><br><span class="line">      Boolean literals: true , false</span><br><span class="line">      Null literal: null</span><br><span class="line">      Literal tokens: one , sometext , main ,…</span><br><span class="line">      </span><br><span class="line">Text operations:（文本操作）</span><br><span class="line">    String concatenation: +</span><br><span class="line">    Literal substitutions: |The name is $&#123;name&#125;|</span><br><span class="line">    </span><br><span class="line">Arithmetic operations:（数学运算）</span><br><span class="line">    Binary operators: + , - , * , &#x2F; , %</span><br><span class="line">    Minus sign (unary operator): -</span><br><span class="line">    </span><br><span class="line">Boolean operations:（布尔运算）</span><br><span class="line">    Binary operators: and , or</span><br><span class="line">    Boolean negation (unary operator): ! , not</span><br><span class="line">    </span><br><span class="line">Comparisons and equality:（比较运算）</span><br><span class="line">    Comparators: &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; ( gt , lt , ge , le )</span><br><span class="line">    Equality operators: &#x3D;&#x3D; , !&#x3D; ( eq , ne )</span><br><span class="line">    </span><br><span class="line">Conditional operators:条件运算（三元运算符）</span><br><span class="line">    If-then: (if) ? (then)</span><br><span class="line">    If-then-else: (if) ? (then) : (else)</span><br><span class="line">    Default: (value) ?: (defaultvalue)</span><br></pre></td></tr></table></figure><h1 id="8-实战：员工管理"><a href="#8-实战：员工管理" class="headerlink" title="8 实战：员工管理"></a>8 实战：员工管理</h1><blockquote><p>这里不贴具体的代码呐，只讲讲具体的流程、原理也最好不涉及，对于项目来说、会用就行。对于框架思想、在具体的知识点中学习就好了</p></blockquote><h2 id="8-1-静态资源、实体类的准备"><a href="#8-1-静态资源、实体类的准备" class="headerlink" title="8.1 静态资源、实体类的准备"></a>8.1 静态资源、实体类的准备</h2><p>1 前端界面的准备工作</p><ul><li>将index.html、404.html、dashboard.html、list.html四个html界面放入templates目录</li><li>将css，js，img放入到static目录</li></ul><p>2 实体类，有员工和部门两个实体类</p><ul><li>编写Department类，id、departmentName</li><li>编写Employee类，id、lastName、email、gender、department、birth</li></ul><p>3 dao层的编写 因为没有数据库，直接用静态代码写死数据、作为数据库</p><ul><li>DepartmentDao表示部门的dao层<ul><li>获得所有部门信息getDepartment()方法</li><li>通过id得到部门getDepartmentById(Integer id) 方法</li></ul></li><li>EmployeeDao表示员工的dao层<ul><li>增加一个员工save(Employee employee)</li><li>查询全部员工信息getAll()</li><li>通过id查询员工getEmployeeById(Integer id)</li><li>通过id删除员工 delete(Integer id)</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211019.png" alt="1595732679388" style="zoom:50%;"><h2 id="8-2-首页及国际化"><a href="#8-2-首页及国际化" class="headerlink" title="8.2 首页及国际化"></a>8.2 首页及国际化</h2><h3 id="指定首页的两种方式"><a href="#指定首页的两种方式" class="headerlink" title="指定首页的两种方式"></a>指定首页的两种方式</h3><p>方式一：创建一个<code>IndexController</code>,写一个返回首页的方法（<font color="red">不建议使用</font>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：使用自己的MyMvcConfig配置扩展springboot对mvc的自动配置。创建一个<code>config</code>目录，在里面写一个<code>MyMvcConfig</code>,里面重写<code>addViewControllers</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后导入thymeleaf依赖包，来加载静态资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改所有页面的静态资源，采用thymeleaf的语法，使用thymeleaf接管</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有的资源路径用 th:src=&quot;@&#123;&#125;&quot;来表示</span><br><span class="line">如：th:src=&quot;@&#123;/js/jquery-3.2.1.slim.min.js&#125;&quot;</span><br></pre></td></tr></table></figure><p>运行，得到首页的展示如下</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211022.png" alt="1595733822534" style="zoom:50%;"><h3 id="页面国际化"><a href="#页面国际化" class="headerlink" title="页面国际化"></a>页面国际化</h3><blockquote><p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p><p>我们的目的是可以根据按钮自动切换中文英文！</p></blockquote><p>1 首先在File Encodings里面将所有编码设为UTF-8格式（还有勾选）</p><p>2 编写i18n的配置文件（每一个页面都要写一组xxxx.properties配置） 挺烦的</p><ul><li>在resources资源文件下新建一个i18n目录，存放国际化配置，这里以login页面的国际化为例</li><li>建立一个login.properties文件，还有login_zh_CN.properties、login_en_US.properties文件</li><li>编写这三个properties文件，注意可以可视化的对比编写</li></ul><p>3 在application.properties配置文件中指定路径，是国际化的配置生效</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">i18n.login</span></span><br></pre></td></tr></table></figure><p>4 修改index.xml页面 中的取值操作，这些地方就对应于主页的那几个提示文字</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211026.png" alt="image-20210629002443214"></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211029.png" alt="image-20210629002601751" style="zoom:67%;"><p>5 增加根据按钮自动切换中文英文的功能</p><ul><li>修改前端页面的跳转连接：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在config包下写一个处理的组件类MyLocaleResolver</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求中的语言参数</span></span><br><span class="line">        String language=request.getParameter(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">        Locale locale=Locale.getDefault();<span class="comment">//如果没有就使用默认</span></span><br><span class="line">        <span class="comment">//如果请求的连接携带了国际化参数</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(language))&#123;</span><br><span class="line">            String[] split=language.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            locale=<span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在我们自己的MvcConofig下添加bean；使区域化信息生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义国际化生效</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重启项目，访问，可以正常切换中英文：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211034.jpg" alt="FotoJet" style="zoom: 25%;"><h2 id="8-3-登录页跳转和拦截器"><a href="#8-3-登录页跳转和拦截器" class="headerlink" title="8.3 登录页跳转和拦截器"></a>8.3 登录页跳转和拦截器</h2><blockquote><p>登录页跳转</p><p>​    验证用户名和密码，进入登录界面。</p><p>​    密码错误可以报错</p><p>​    隐藏url上用户名和密码的明文显示，用main.html字符代替</p><p>拦截器</p><p>​    避免直接输入<a href="http://localhost:8080/main.html">http://localhost:8080/main.html</a> 就能访问首页的i情况，只能登录之后才能进入首页</p></blockquote><h3 id="登录页跳转"><a href="#登录页跳转" class="headerlink" title="登录页跳转"></a><strong>登录页跳转</strong></h3><p>1 登录页面表单的修改，指定跳转路径 th:action=”@{/user/login}”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--提交表单的url是/user/login,由LoginController跳转过来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-signin&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user/login&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--增加错误提示行 当有msgWrong传过时，表示登录失败 给出提示信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: #ff0000&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msgWrong&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #strings.isEmpty(msgWrong)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 写一个LoginController登录验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@RequestParam(&quot;password&quot;)</span> String passWord,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                        HttpSession session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(userName)&amp;&amp;passWord.equals(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//设置session保存已经登录的账号的信息（用户名）</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,userName);</span><br><span class="line">            <span class="comment">//return &quot;dashboard&quot;; //避免密码和用户名泄露，不直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            model.addAttribute(<span class="string">&quot;msgWrong&quot;</span>,<span class="string">&quot;用户名或者密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 用main.html映射解决 明文密码的问题：</p><ul><li>修改<code>LoginController</code>跳转页面代码(redirect跳转) 上文已改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return &quot;dashboard&quot;; //避免密码和用户名泄露，不直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>加一个main.html映射在<code>MyMvcConfig</code>类的<code>addViewControllers</code>方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//避免url泄露用户名和密码的问题，将实际访问dashboard页面时与/main.html映射</span></span><br><span class="line">registry.addViewController(<span class="string">&quot;/main.html&quot;</span>).setViewName(<span class="string">&quot;dashboard&quot;</span>);</span><br></pre></td></tr></table></figure><p>密码为1登录成功 和密码不为1登录失败 分别如下：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211040.png" alt="image-20210629131537110" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211043.png" alt="image-20210629131700607" style="zoom:50%;"><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a><strong>拦截器</strong></h3><p>1 在<code>LoginController</code>中添加一个session判断登录（上文已写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置session保存已经登录的账号的信息（用户名）</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,userName);</span><br></pre></td></tr></table></figure><p>2 在<code>config</code>页面写一个<code>LoginHandlerInterceptor</code>拦截器 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录界面的拦截器，通过session来判断是否拦截</span></span><br><span class="line"><span class="comment">//实现了HandlerInterceptor接口的就是一个拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过session获取用户信息</span></span><br><span class="line">        Object loginUser = request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(loginUser==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//session里面无信息表示没有登录</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;msgWrong&quot;</span>,<span class="string">&quot;未登录，请先登录&quot;</span>);</span><br><span class="line">            <span class="comment">//这个是什么意思没搞懂？</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//拦截了</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//不拦截</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 <code>MyMvcConfig</code>页面重写拦截器方法<a href="http://localhost:8080/main.html%EF%BC%8C%E5%B0%86%E4%BC%9A%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF">http://localhost:8080/main.html，将会提示错误</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写拦截器方法！！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拦截所有界面&quot;/**&quot;，，排除主页和静态资源&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;static/**&quot;</span></span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">        .excludePathPatterns(<span class="string">&quot;/index.html&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/user/login&quot;</span>,<span class="string">&quot;/static/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有登录直接访问，将提示错误信息</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211047.png" alt="image-20210629132456232" style="zoom: 50%;"><h2 id="8-4-员工列表展示"><a href="#8-4-员工列表展示" class="headerlink" title="8.4 员工列表展示"></a>8.4 员工列表展示</h2><blockquote><p>1 编写后台EmployeeController，获取员工数据，作为集合传给前端</p><p>2 提取dashboard.html和list.html的公共页面：顶部导航栏、侧边栏</p><p>3 list.html写列表循环展示后端传来的员工信息数据 <code>th:each</code>命令</p></blockquote><p>1 编写后台EmployeeController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//controller层调用dao层 （其实还应该有service层 这里省略）</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//使用注解实现自动装配</span></span><br><span class="line">    EmployeeDao employeeDao;</span><br><span class="line">    <span class="comment">//展示所有员工</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/emps&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用dao层，获取数据</span></span><br><span class="line">        Collection&lt;Employee&gt; employees = employeeDao.getAll();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;emps&quot;</span>,employees); <span class="comment">//传递一个集合给前端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;emp/list&quot;</span>; <span class="comment">//返回的前端页面是emp文件夹下的list.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 提取dashboard.html和list.html的公共页面</p><ul><li>在<code>templates</code>目录下面创建<code>commons</code>目录，在<code>commons</code>目录下面创建<code>commons.html</code>放公共代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--只写改变的代码--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--顶部导航栏,设置框架名为topbar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;topbar&quot;</span>&gt;</span></span><br><span class="line">    .............</span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--侧边栏 设置框架名为sidebar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-sticky&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav flex-column&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这里首页的a标签 直接跳转到登陆页面--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index.html&#125;&quot;</span>&gt;</span></span><br><span class="line">                  .............</span><br><span class="line">                    首页 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            .............</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--员工管理的a标签 执行/emps的url会执行EmployeeController中的list方法--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emps&#125;&quot;</span>&gt;</span></span><br><span class="line">                    .............</span><br><span class="line">                    员工管理</span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            .............</span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        .............</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>dashboard.html和list.html页面一样，将原来的导航栏和侧边栏代码，替换为一行代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--顶部导航栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;commons/commons::topbar&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--侧边栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;commons/commons::sidebar&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 list.html写列表循环展示后端传来的员工信息数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--侧边栏--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;commons/commons::sidebar(active=&#x27;list.html&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Section title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table-responsive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-striped table-sm&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>department<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>birth<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;emp:$&#123;emps&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getId()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getLastName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getEmail()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.getGender()==0?&#x27;女&#x27;:&#x27;男&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.department.getDepartmentName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(emp.getBirth(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-primary&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-danger&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面展示</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211051.png" alt="image-20210629193959128" style="zoom: 50%;"><p>基本的框架搭建起来之后，就是后台数据的增删改的操作了！！</p><h2 id="8-5-添加员工信息"><a href="#8-5-添加员工信息" class="headerlink" title="8.5 添加员工信息"></a>8.5 添加员工信息</h2><blockquote><p>1 在list.html界面添加一个“新增员工“的按钮</p><p>2 后台编写toAddPage()方法，实现点击前端的”新增“按钮，跳转至添加员工的表单页面</p><p>3 编写add.html页面</p><p>4 后台获取add.html页面表单提交的数据，修改dao层数据</p><p>5 注意时间格式，在application.properties文件中添加格式配置</p></blockquote><p>1 在list.html界面添加一个“新增员工“的按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-success&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp&#125;&quot;</span>&gt;</span>添加员工<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 后台编写toAddPage()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">//使用注解实现自动装配</span></span><br><span class="line">DepartmentDao departmentDao;</span><br><span class="line"><span class="comment">//@getMapping = @requestMapping(method = RequestMethod.GET)。</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/toAddPage&quot;)</span> <span class="comment">//以get方式传递数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toAddPage</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查出所有部门的信息</span></span><br><span class="line">    Collection&lt;Department&gt; department = departmentDao.getDepartment();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;departments&quot;</span>,department);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;emp/add&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 编写add.html页面(其他部分和list.html页面一样，只改main中的代码即可）</p><ul><li>注意：下拉框提交的时候应提交一个属性，因为其在controller接收的是一个Employee，否则会报错</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/addEmp&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;海绵宝宝&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;1176244270@qq.com&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;department.id&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--我们在controller接收的是一个Employee，所以我们需要提交的是其中的一个属性--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;dept:$&#123;departments&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;dept.getDepartmentName()&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;dept.getId()&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;2020/07/25 18:00:00&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4 后台获取add.html页面表单提交的数据，修改dao层数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@postMapping = @requestMapping(method = RequestMethod.POST)。</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/addEmp&quot;)</span><span class="comment">//以post方式传递数据,传递一个Employee对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmp</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">    employeeDao.save(employee);<span class="comment">//调用底层业务方法保存员工信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/emps&quot;</span>; <span class="comment">//新增员工后就立即跳转刷新到展示员工的界面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 日期格式的修改</p><ul><li>如果输入的日期格式为2020-01-01，则会报错。在application.properties文件中添加配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.format.date</span>=<span class="string">yyyy-MM-dd</span></span><br></pre></td></tr></table></figure><p>页面展示：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211056.png" alt="image-20210629205448874" style="zoom: 50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211059.png" alt="image-20210629205535752" style="zoom: 50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211102.png" alt="image-20210629205617130" style="zoom: 50%;"><h2 id="8-6-修改、删除、注销和404页面"><a href="#8-6-修改、删除、注销和404页面" class="headerlink" title="8.6 修改、删除、注销和404页面"></a>8.6 修改、删除、注销和404页面</h2><p>1 修改员工信息步骤如下：</p><blockquote><p>1 list页面展示员工的表单里面添加编辑按钮</p><p>2 写toUpdateEmp()方法，用于跳转到修改页面</p><p>3 编写update.html页面（主体和update.html页面一样，修改main），接受数据，提交数据</p><p>4 写updateEmp()方法，修改dao层的数据</p></blockquote><p>2 删除员工信息步骤如下：</p><blockquote><p>1  list页面展示员工的表单里面添加删除按钮</p><p>2 编写deleteEmp()方法，删除员工，修改dao层的数据</p></blockquote><p>3 注销功能的实现步骤如下：</p><blockquote><p>1 在commons.html中修改注销按钮</p><p>2 在<code>LoginController.java</code>中编写注销页面的logout()方法</p></blockquote><p>4 404页面</p><blockquote><p>将404.html页面放入到templates目录下面的error目录中即可实现自动跳转404界面</p></blockquote><h2 id="8-7-总结：如何搭建一个网站"><a href="#8-7-总结：如何搭建一个网站" class="headerlink" title="8.7 总结：如何搭建一个网站"></a>8.7 总结：如何搭建一个网站</h2><p> 搭建一个网站的步骤：</p><ol><li>前端搞定：页面长什么样子</li><li><font color="red">设计数据库（数据库设计难点）</font></li><li>前端让他能够自动运行，独立化工程</li><li>数据接口如何对接：json，对象，all in one！</li><li>前后端联调测试</li></ol><p>模板：</p><ol><li>有一套自己熟悉的后台模板：工作必要！<strong>x-admin</strong></li><li>前端页面：至少自己能够通过前端框架，组合出来一个网站页面<ul><li>index</li><li>about</li><li>blog</li><li>post</li><li>user</li></ul></li><li>让这个网站能够独立运行！</li></ol><h1 id="9-整合JDBC、集成Druid、整合Mybatis"><a href="#9-整合JDBC、集成Druid、整合Mybatis" class="headerlink" title="9 整合JDBC、集成Druid、整合Mybatis"></a>9 整合JDBC、集成Druid、整合Mybatis</h1><p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p><blockquote><p>Sping Data 官网：<a href="https://spring.io/projects/spring-data">https://spring.io/projects/spring-data</a></p><p>数据库相关的启动器 ：可以参考官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</a></p></blockquote><h2 id="9-1-整合JDBC"><a href="#9-1-整合JDBC" class="headerlink" title="9.1 整合JDBC"></a>9.1 整合JDBC</h2><h3 id="1-测试显示默认数据源"><a href="#1-测试显示默认数据源" class="headerlink" title="1 测试显示默认数据源"></a>1 测试显示默认数据源</h3><blockquote><p>1 新建一个springboot的web项目 勾选JDBC API和MySQL Driver</p><p>2 编写yaml配置文件连接数据库</p><p>3 cmd打开Mysql服务，springboot连接数据库、选mybatis库（本来就有）</p><p>4 test包下的测试类打印默认数据源和数据库连接connection</p></blockquote><p>2 编写application.yaml配置文件连接数据库</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&#x27;526736&#x27;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>4  test包下的测试类Springboot04DataApplicationTests</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04DataApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//DI注入数据源</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//看一下默认数据源</span></span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        <span class="comment">//获得连接 打印连接</span></span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：我打印出来显示数据源为 : class com.zaxxer.hikari.HikariDataSource </p><p><strong>查看源码：DataSourceAutoConfiguration文件:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(&#123;DataSourceAutoConfiguration.PooledDataSourceCondition.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;DataSource.class, XADataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;Hikari.class, Tomcat.class, Dbcp2.class, OracleUcp.class, Generic.class, DataSourceJmxConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PooledDataSourceConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源。<strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p><p>当然也可以通过yaml配置指定数据源类型</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span> <span class="comment">#数据源DruidDataSource</span></span><br></pre></td></tr></table></figure><h3 id="2-使用-JDBCTemplate-操作CURD"><a href="#2-使用-JDBCTemplate-操作CURD" class="headerlink" title="2 使用 JDBCTemplate 操作CURD"></a>2 使用 JDBCTemplate 操作CURD</h3><ul><li><p>Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p></li><li><p>Spring Boot 默认将 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用。JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p><ul><li>execute方法可以用于执行任何SQL语句，一般用于执行DDL语句；</li><li>update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li><li>query方法及queryForXXX方法：用于执行查询相关语句；</li><li>call方法：用于执行存储过程、函数相关语句</li></ul></li></ul><blockquote><p>直接编写一个JDBCController，进行增删改查的工作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//注解方式引入bean</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userList&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; userList()&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; mapList = jdbcTemplate.queryForList(sql);</span><br><span class="line">        <span class="keyword">return</span> mapList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into mybatis.user(id, name, pwd) values(5,&#x27;小明&#x27;,&#x27;123456&#x27;)&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;add-ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/updateUser/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span><span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update mybatis.user set name  = ?,pwd = ? where id = &quot;</span> + id;</span><br><span class="line">        Object[] objects = <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;小明5&quot;</span>,<span class="string">&quot;ssss&quot;</span>&#125;;</span><br><span class="line">        jdbcTemplate.update(sql,objects);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;update-Ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deleteUser/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span><span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;delete from mybatis.user where id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;delete-Ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询<a href="http://localhost:8080/userList">http://localhost:8080/userList</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211109.png" alt="image-20210630193550419" style="zoom: 80%;"><ul><li>新增<a href="http://localhost:8080/addUser">http://localhost:8080/addUser</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211112.png" alt="image-20210630193830659" style="zoom:80%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211115.png" alt="image-20210630193855039" style="zoom:80%;"><ul><li>修改<a href="http://localhost:8080/updateUser/5">http://localhost:8080/updateUser/5</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211117.png" alt="image-20210630193946626" style="zoom:80%;"><ul><li>删除<a href="http://localhost:8080/deleteUser/5">http://localhost:8080/deleteUser/5</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211121.png" alt="image-20210630194022411" style="zoom:80%;"><h2 id="9-2-集成Druid数据源"><a href="#9-2-集成Druid数据源" class="headerlink" title="9.2 集成Druid数据源"></a>9.2 集成Druid数据源</h2><h3 id="1-Druid数据源介绍"><a href="#1-Druid数据源介绍" class="headerlink" title="1 Druid数据源介绍"></a>1 Druid数据源介绍</h3><ul><li><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p></li><li><p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p></li></ul><blockquote><p>Github地址：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p></blockquote><p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p><p>Druid 数据源部分参数含义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">initialSize:</span> <span class="number">5</span> <span class="comment">#初始化时建立物理连接的个数</span></span><br><span class="line"><span class="attr">minIdle:</span> <span class="number">5</span> <span class="comment">#最小连接池数量</span></span><br><span class="line"><span class="attr">maxActive:</span> <span class="number">20</span> <span class="comment">#最大连接池数量</span></span><br><span class="line"><span class="attr">maxWait:</span> <span class="number">60000</span> <span class="comment">#获取连接时最大等待时间，单位毫秒。</span></span><br><span class="line"><span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span> <span class="comment">#Destroy线程会检测连接的间隔时间</span></span><br><span class="line"><span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span>  <span class="comment">#连接保持空闲而不被驱逐的最长时间</span></span><br><span class="line"><span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span> <span class="comment">#单位:秒，检测连接是否有效的超时时间。</span></span><br><span class="line"><span class="attr">testWhileIdle:</span> <span class="literal">true</span> <span class="comment">#申请连接的时候检测 不影响性能，并且保证安全性</span></span><br><span class="line"><span class="attr">testOnBorrow:</span> <span class="literal">false</span> <span class="comment">#申请连接时执行validationQuery检测连接是否有效 降低性能</span></span><br><span class="line"><span class="attr">testOnReturn:</span> <span class="literal">false</span> <span class="comment">#归还连接时执行validationQuery检测连接是否有效，降低性能</span></span><br><span class="line"><span class="attr">poolPreparedStatements:</span> <span class="literal">true</span> <span class="comment">#是否缓存preparedStatement</span></span><br></pre></td></tr></table></figure><h3 id="2-集成Druid数据源"><a href="#2-集成Druid数据源" class="headerlink" title="2 集成Druid数据源"></a>2 集成Druid数据源</h3><blockquote><p>1 添加上 Druid 数据源依赖</p><p>2 配置文件切换数据源，并设置Druid 数据源的参数</p><p>3 导入Log4j 的依赖</p><p>4 编写DruidConfig类，为 DruidDataSource 绑定全局配置文件中的参数</p><p>5 测试 数据源是否切换成功</p><p>6 配置Druid数据源监控（重要）</p><p>7 配置 Druid web 监控 filter 过滤器（不重要）</p></blockquote><p>1 Druid 数据源依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 配置文件切换数据源，并设置Druid 数据源的参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span> <span class="comment"># 自定义数据源</span></span><br><span class="line">    <span class="comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定druid 数据源专有配置</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span></span><br><span class="line">    <span class="comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span></span><br><span class="line">    <span class="comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure><p>3 导入Log4j 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4 编写DruidConfig类，为 DruidDataSource 绑定全局配置文件中的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建</span></span><br><span class="line"><span class="comment">   绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效</span></span><br><span class="line"><span class="comment">   @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中</span></span><br><span class="line"><span class="comment">   前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 测试 数据源是否切换成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04DataApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//DI注入数据源</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//看一下默认数据源</span></span><br><span class="line">        System.out.println(dataSource.getClass());</span><br><span class="line">        <span class="comment">//获得连接 打印连接</span></span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"><span class="comment">//打印连接池信息</span></span><br><span class="line">        DruidDataSource druidDataSource = (DruidDataSource) dataSource;</span><br><span class="line">        System.out.println(<span class="string">&quot;druidDataSource 数据源最大连接数：&quot;</span> + druidDataSource.getMaxActive());</span><br><span class="line">        System.out.println(<span class="string">&quot;druidDataSource 数据源初始化连接数：&quot;</span> + druidDataSource.getInitialSize());</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211128.png" alt="image-20210701081752908" style="zoom:50%;"><p><strong>6 配置Druid数据源监控（重要）</strong></p><blockquote><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看。</p><p>但是需要自己设置一下后台管理页面，比如 登录账号、密码 等；配置后台管理；</p><p>相当于说Druid的一些功能都需要通过Servlet来实现，而在springboot中实现Servlet是通过注册的方式来实现的，注册一个开始页面的Servlet</p></blockquote><p>在DruidConfig类写一个开始页面的Servlet：statViewServlet()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置 Druid 监控管理后台的Servlet；</span></span><br><span class="line"><span class="comment">//springboot内置 Servlet 容器时没有web.xml文件，所以使用注册的 Servlet 方式</span></span><br><span class="line"><span class="comment">//注册返回一个ServletRegistrationBean对象</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet</span></span><br><span class="line">    <span class="comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span></span><br><span class="line">    Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>); <span class="comment">//后台管理界面的登录账号</span></span><br><span class="line">    initParams.put(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">//后台管理界面的登录密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台允许谁可以访问</span></span><br><span class="line">    <span class="comment">//initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span></span><br><span class="line">    <span class="comment">//initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span></span><br><span class="line">    initParams.put(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//deny：Druid 后台拒绝谁访问</span></span><br><span class="line">    <span class="comment">//initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置初始化参数</span></span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完毕后，我们可以选择访问 ：<a href="http://localhost:8080/druid/login.html">http://localhost:8080/druid/login.html</a></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211137.png" alt="image-20200727233409312" style="zoom: 50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211140.png" alt="image-20200727233436583"></p><p>进入之后</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211146.png" alt="image-20200727233436583" style="zoom: 50%;"><p>7 配置 Druid web 监控 filter 过滤器（可有可无）</p><blockquote><p>在DruidConfig类写一个过滤器的Servlet：webStatFilter()方法</p><p>//WebStatFilter类：用于配置Web和Druid数据源之间的管理关联监控统计</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 Druid 监控 之  web 监控的 filter</span></span><br><span class="line"><span class="comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span></span><br><span class="line">    Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    initParams.put(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.css,/druid/*,/jdbc/*&quot;</span>);</span><br><span class="line">    bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;/*&quot; 表示过滤所有请求</span></span><br><span class="line">    bean.setUrlPatterns(Arrays.asList(<span class="string">&quot;/*&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-3-整合Mybatis"><a href="#9-3-整合Mybatis" class="headerlink" title="9.3 整合Mybatis"></a>9.3 整合Mybatis</h2><blockquote><p>官方文档：<a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><p>Maven仓库地址：<a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.3">https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.3</a></p></blockquote><p>这里写的整合步骤是在已经完成数据库连接、数据源的配置、的基础之上，所以只需要引入依赖、写mapper接口、写xml的SQL语句、再写一个controller调用mapper就可。</p><blockquote><p>1 导入 MyBatis 所需要的依赖、导入Lombok的依赖</p><p>2 创建实体类</p><p>3 创建一个 Mapper 接口，路径为com.kuang.mapper</p><p>4 编写对应的Mapper映射文件UserMapper.xml，这里也放在com.kuang.mapper下（其实最好放在resources/mapper下，都可）</p><p>5 application.yaml配置文件加上MyBatis 的配置！！</p><p>6 编写部门的 UserController 进行测试！</p></blockquote><p>1 导入 MyBatis 所需要的依赖、导入Lombok的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 创建一个 Mapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span> <span class="comment">//表示是一个mybatis的mapper类</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">//由springboot接管</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 映射文件UserMapper.xml</p><ul><li>这里一定要注意绑定的命名空间 <mapper namespace="com.kuang.mapper.UserMapper"> 我因为这个搞了一上午</mapper></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.user set name=#&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5 application.yaml配置文件加上MyBatis 的配置！！</p><ul><li>这里给出两种格式的</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.kuang.pojo</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.kuang.pojo</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>6 编写 UserController 并测试</p><ul><li>注意方法名和mapper.xml中的id保持一致！！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="comment">//获取用户列表</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/userList1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/addUser1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userMapper.addUser(<span class="keyword">new</span> User(<span class="number">8</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;223344&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/updateUser1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userMapper.updateUser(<span class="keyword">new</span> User(<span class="number">8</span>,<span class="string">&quot;abcdef&quot;</span>,<span class="string">&quot;223344&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/deleteUser1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userMapper.deleteUser(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只展示<a href="http://localhost:8080/userList1">http://localhost:8080/userList1</a> 的结果</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211155.png" alt="image-20210702125644590" style="zoom:80%;"><h1 id="10-SpringSecurity"><a href="#10-SpringSecurity" class="headerlink" title="10 SpringSecurity"></a>10 SpringSecurity</h1><blockquote><p>认证跟授权</p></blockquote><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。</p><ul><li>用户认证指的是验证某个用户是否为系统中的合法主体。系统通过校验用户名和密码来完成认证过程。</li><li><strong>在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。</strong></li><li>用户授权指的是验证某个用户是否有权限执行某个操作。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</li><li><strong>在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</strong></li></ul><h2 id="10-1-认证和授权"><a href="#10-1-认证和授权" class="headerlink" title="10.1 认证和授权"></a>10.1 认证和授权</h2><p><strong>用户认证：不登陆的话总是跳转到登录界面</strong></p><blockquote><p>1 新建一个springboot项目、导入web模块，thymeleaf模块，security模块</p><p>2 导入静态资源 static 和 templates包下</p><p>3 写一个RouterController，控制视图跳转</p><p>4 启动项目 访问路径</p></blockquote><p>2 导入静态资源</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211158.png" alt="image-20200728130501139" style="zoom: 67%;"><p>3 写一个RouterController，控制视图跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//跳到主页</span></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index&quot;,&quot;/&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳到Login</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;views/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/level1/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">level1</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;views/level1/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/level2/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">level2</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;views/level2/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/level3/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">level3</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;views/level3/&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 访问设定的路径</p><blockquote><p><a href="http://localhost:8080/">http://localhost:8080</a></p><p><a href="http://localhost:8080/index">http://localhost:8080/index</a></p><p><a href="http://localhost:8080/level/1">http://localhost:8080/level/1</a></p><p><a href="http://localhost:8080/login">http://localhost:8080/login</a></p></blockquote><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211202.png" alt="image-20210702155923689" style="zoom: 50%;"><p>发现如论访问哪个路径都会跳转到login界面，这就是默认完成了认证功能。我们登录一下，用户名为user，密码在控制台为2c95c9e7-894b-40aa-abc0-6284a890e243。进入主页：</p><p>假设level1、levlel2、level3是三种权限，这里都可以访问。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211204.png" alt="image-20210702160004332" style="zoom:33%;"><p><strong>用户授权：不同的角色拥有不同的权限</strong></p><p>记住几个类：</p><ul><li><code>WebSecurityConfigurerAdapter</code>：自定义Security策略 （观察者模式）</li><li><code>AuthenticationManagerBuilder</code>：自定义认证策略（建造者模式）</li><li><code>@EnableWebSecurity</code>：开启WebSecurity模式 （@EnableXXXX 开启某个功能）</li></ul><p>官方文档</p><blockquote><p>参考官网：<a href="https://spring.io/projects/spring-security">https://spring.io/projects/spring-security</a></p><p>查看我们自己项目中的版本，找到对应的帮助文档：<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/">https://docs.spring.io/spring-security/site/docs/current/reference/html5/</a></p><p>文档中的16.4. Custom DSLs、16.5. Post Processing Configured Objects如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     http</span><br><span class="line">         .apply(customDsl())</span><br><span class="line">             .flag(<span class="keyword">true</span>)</span><br><span class="line">             .and()</span><br><span class="line">         ...;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> http</span><br><span class="line">     .authorizeRequests(authorize -&gt; authorize</span><br><span class="line">         .anyRequest().authenticated()</span><br><span class="line">         .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">             <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                     O fsi)</span> </span>&#123;</span><br><span class="line">                 fsi.setPublishAuthorizationSuccess(<span class="keyword">true</span>);</span><br><span class="line">                 <span class="keyword">return</span> fsi;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>配置Security代码如下</p><blockquote><p>1 建一个SecurityConfig类继承WebSecurityConfigurerAdapter接口</p><p>2 重写configure(HttpSecurity http)方法，采用链式编程设定授权的规则</p><p>3 重写configure(AuthenticationManagerBuilder auth)方法，采用链式编程设定角色、用户账号，（用户密码需要加密，不然会报错）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">//开启WebSecurity模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义 请求授权的规则</span></span><br><span class="line">        <span class="comment">// 首页所有人都可以访问，功能也只有对应有权限的人才能访问到</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启自动配置的登录功能</span></span><br><span class="line">        <span class="comment">// /login 请求来到登录页</span></span><br><span class="line">        <span class="comment">// /login?error 重定向到这里表示登录失败</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 认证，springboot 2.1.x 可以直接使用</span></span><br><span class="line">        <span class="comment">// 密码编码： PasswordEncoder</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这些数据正常情况应该中数据库中读，这里仅演示作用</span></span><br><span class="line">        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">                .withUser(<span class="string">&quot;kuangshen&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;root&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;guest&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-权限控制和注销"><a href="#10-2-权限控制和注销" class="headerlink" title="10.2 权限控制和注销"></a>10.2 权限控制和注销</h2><h3 id="实现注销功能"><a href="#实现注销功能" class="headerlink" title="实现注销功能"></a>实现注销功能</h3><blockquote><p>需求：开启注销功能，注销之后自动跳转到首页</p><p>1 开启自动配置的注销的功能</p><p>2 我们在前端，增加一个注销的按钮，<code>index.html </code>导航栏中</p><p>3 测试，登录成功后点击注销！</p></blockquote><p>1 configure(HttpSecurity http)方法中开启自动配置的注销的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启自动配置的注销的功能</span></span><br><span class="line"><span class="comment">//http.logout(); //注销成功返回登录页</span></span><br><span class="line">http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//注销成功来到首页</span></span><br></pre></td></tr></table></figure><p>2 前端，增加一个注销的按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注销--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;sign-out icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 注销</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 测试，登录成功后点击注销，发现注销完毕会跳转到index主页</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211209.png" alt="image-20210702172023370" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211212.png" alt="image-20210702172034965" style="zoom:67%;"><h3 id="实现显示该用户有权限的功能"><a href="#实现显示该用户有权限的功能" class="headerlink" title="实现显示该用户有权限的功能"></a>实现显示该用户有权限的功能</h3><blockquote><p>需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！</p><p>1 修改我们的前端页面：导入命名空间、修改导航栏增加认证判断</p><p>2 重启测试，登录后显示了用户信息和注销按钮</p><p>3 完成角色功能块认证的功能，只要是编写前端代码</p><p>​        <!--菜单根据用户的角色动态的实现--></p><p>4 最后的测试</p></blockquote><p>1 修改我们的前端页面：导入命名空间、修改导航栏增加认证判断</p><ul><li>导入命名空间</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>修改导航栏，增加认证判断</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果未登录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;!isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果已登录和注销按钮--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 重启测试，登录后显示了用户信息和注销按钮</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211216.png" alt="image-20200728213235625"></p><p>3 完成角色功能块认证的功能，只要是编写前端代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--菜单根据用户的角色动态的实现 vip1--&gt;</span></span><br><span class="line">sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;</span><br><span class="line"><span class="comment">&lt;!--菜单根据用户的角色动态的实现 vip2--&gt;</span></span><br><span class="line">sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;</span><br><span class="line"><span class="comment">&lt;!--菜单根据用户的角色动态的实现 vip3--&gt;</span></span><br><span class="line">sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>4 最后的测试：三个不同的用户对应着不同的视图</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211219.png" alt="image-20210702184407465" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211221.png" alt="image-20210702184333913" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211223.png" alt="image-20210702184252754" style="zoom:50%;"><h2 id="10-3-记住我功能"><a href="#10-3-记住我功能" class="headerlink" title="10.3 记住我功能"></a>10.3 记住我功能</h2><p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p><blockquote><p>1 configure(HttpSecurity http)方法中开启记住我功能</p><p>2 测试</p></blockquote><p>1 开启记住我功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启记住我功能: cookie,默认保存两周</span></span><br><span class="line">http.rememberMe();</span><br></pre></td></tr></table></figure><p>2启动项目测试一下 </p><ul><li><p>发现登录页多了一个记住我功能</p></li><li><p>我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211226.png" alt="image-20200728222312694" style="zoom:67%;"></li></ul><p><strong><font color="red">思考：如何实现的呢？其实非常简单</font></strong></p><p>我们可以查看浏览器的cookie</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211228.png" alt="image-20200728222706154"></p><p>我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211230.png" alt="image-20200728223559077"></p><blockquote><p>本来还讲了Shiro框架，和springScurity的功能差不多、先跳过了</p></blockquote><h1 id="11-Swagger"><a href="#11-Swagger" class="headerlink" title="11 Swagger"></a>11 Swagger</h1><blockquote><p>前后端分离带来的最大的问题：前后端团队的信息沟通。一般是后端提供API接口给前端、前端测试并且使用。</p><p>而Swagger号称世界上最流行的API框架，API文档能够和API定义程序同步更新</p></blockquote><h2 id="11-1-前后端的问题及解决"><a href="#11-1-前后端的问题及解决" class="headerlink" title="11.1 前后端的问题及解决"></a>11.1 前后端的问题及解决</h2><p><strong>前后端分离 Vue+SpringBoot</strong></p><ul><li>前端 -&gt; 前端控制层、视图层<ul><li>伪造后端数据，json。不需要后端，前端工程队依旧能够跑起来</li></ul></li><li>后端 -&gt; 后端控制层Controller、服务层Service、数据访问层Dao</li><li>前后端通过API进行交互、前后端相对独立且松耦合</li></ul><p><strong>前后端分离产生的问题</strong></p><ul><li>前后端集成联调，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><p><strong>解决方案</strong></p><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险；</li><li>早些年：指定word计划文档；</li><li>前后端分离：<ul><li>前端测试后端接口：postman</li><li>后端提供接口，<strong>需要实时更新最新的消息及改动</strong></li></ul></li></ul><h2 id="11-2-集成Swagger"><a href="#11-2-集成Swagger" class="headerlink" title="11.2 集成Swagger"></a>11.2 集成Swagger</h2><p><strong>Swagger的优点</strong></p><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <font color="red"><strong>API 文档 与API 定义同步更新</strong></font></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><p><strong>SpringBoot集成Swagger</strong></p><blockquote><p>1 新建SpringBoot-web项目，导入swagger2、swagger-ui依赖</p><p>2 编写HelloController，测试确保运行成功</p><p>3 编写SwaggerConfig配置类来配置 Swagger（只写个空白类）</p><p>4 访问测试，可以看到swagger原生的自定义的界面</p><p>5 配置Swagger信息部分的文档信息</p><p>6 重启项目，访问测试，看到了修改</p></blockquote><p>1 新建SpringBoot-web项目，导入swagger2、swagger-ui依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意：2.9.2版本之前，之后的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 编写SwaggerConfig配置类(只写个类，什么都不配，先跑起来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表明是一个配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//开启swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 访问测试， <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211233.png" alt="image-20200731132229265" style="zoom:67%;"><p>5 配置Swagger信息部分的文档信息</p><ul><li>Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger</li><li>可以通过apiInfo()属性配置文档信息</li><li>Docket 实例关联上 apiInfo()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表明是一个配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//开启swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文档信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;WK&quot;</span>, <span class="string">&quot;http://xxx.xxx.com/&quot;</span>, <span class="string">&quot;1111222@qq.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;Swagger学习_XX项目&quot;</span>, <span class="comment">// 标题</span></span><br><span class="line">                <span class="string">&quot;Swagger学习_狂神学习&quot;</span>, <span class="comment">// 描述</span></span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>, <span class="comment">// 版本</span></span><br><span class="line">                <span class="string">&quot;http://terms.service.url/&quot;</span>, <span class="comment">// 组织链接</span></span><br><span class="line">                contact, <span class="comment">// 联系人信息</span></span><br><span class="line">                <span class="string">&quot;Apach 2.0 许可&quot;</span>, <span class="comment">// 许可</span></span><br><span class="line">                <span class="string">&quot;http://xxx.xxx.com/&quot;</span>, <span class="comment">// 许可连接</span></span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;()<span class="comment">// 扩展</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 重启项目，访问测试，看到了修改</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211237.png" alt="image-20210702213833452" style="zoom:67%;"><h2 id="11-3-Swagger配置【重点】"><a href="#11-3-Swagger配置【重点】" class="headerlink" title="11.3 Swagger配置【重点】"></a>11.3 Swagger配置【重点】</h2><h3 id="1-配置扫描接口"><a href="#1-配置扫描接口" class="headerlink" title="1 配置扫描接口"></a>1 配置扫描接口</h3><blockquote><p>1 构建Docket时通过select()方法配置怎么扫描接口。</p><p>2 重启项目测试，controller下只有一个类，所以swagger界面只有一个类了</p><p>3 其他方式扫描接口</p><p>4 接口扫描过滤功能</p></blockquote><p>1 Docket时通过select()方法配置怎么扫描接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        <span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">//将controller下的接口扫描上</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.controller&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 重启项目测试 只看到一个hello Controller了</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211241.png" alt="image-20210702220614615" style="zoom:67%;"><p>3 其他方式扫描接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basePackage(<span class="keyword">final</span> String basePackage) <span class="comment">// 根据包路径扫描接口</span></span><br><span class="line">any() <span class="comment">// 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line">none() <span class="comment">// 不扫描接口</span></span><br><span class="line"><span class="comment">// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line">withMethodAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br><span class="line"><span class="comment">// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line">withClassAnnotation(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; annotation)</span><br></pre></td></tr></table></figure><p>4 还可以配置接口扫描过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">      .apiInfo(apiInfo())</span><br><span class="line">      .select()</span><br><span class="line">      .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.controller&quot;</span>))</span><br><span class="line">       <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/ss开头的接口</span></span><br><span class="line">      .paths(PathSelectors.ant(<span class="string">&quot;/ss/**&quot;</span>))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选的配置有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">any() <span class="comment">// 任何请求都扫描</span></span><br><span class="line">none() <span class="comment">// 任何请求都不扫描</span></span><br><span class="line">regex(<span class="keyword">final</span> String pathRegex) <span class="comment">// 通过正则表达式控制</span></span><br><span class="line">ant(<span class="keyword">final</span> String antPattern) <span class="comment">// 通过ant()控制</span></span><br><span class="line"><span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/ss开头的接口</span></span><br><span class="line">paths(PathSelectors.ant(<span class="string">&quot;/ss/**&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="2-配置Swagger开关"><a href="#2-配置Swagger开关" class="headerlink" title="2 配置Swagger开关"></a>2 配置Swagger开关</h3><p>通过enable()方法可以配置是否启用swagger。可以在不同的环境中选择是否启用swagger。</p><blockquote><p>1 通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p><p>2 动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示</p></blockquote><p>1 通过enable()方法配置是否启用swagger(伪代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        .enable(<span class="keyword">false</span>)</span><br><span class="line">        ....;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211245.png" alt="image-20210702221738702" style="zoom:67%;"><p>2 动态配置当项目处于dev环境时显示swagger，处于prod时不显示</p><ul><li>新建application-dev.properties、application-pro.properties，端口分别为8081、8082</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8082</span></span><br></pre></td></tr></table></figure><ul><li>通过enable()方法配置是否启用swagger</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//配置docket以配置Swagger具体参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">    Profiles of = Profiles.of(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断当前是否处于该环境</span></span><br><span class="line">    <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">    <span class="keyword">boolean</span> b = environment.acceptsProfiles(of);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        .enable(b)</span><br><span class="line">        <span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">//将controller下的接口扫描上</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.controller&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当启用dev时: spring.profiles.active=dev，访问<a href="http://localhost:8081/swagger-ui.html#/">http://localhost:8081/swagger-ui.html#/</a> 可</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211249.png" alt="image-20210702222655441" style="zoom:67%;"><ul><li>当启用pro时: spring.profiles.active=pro，访问<a href="http://localhost:8082/swagger-ui.html#/">http://localhost:8082/swagger-ui.html#/</a> 不可</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211253.png" alt="image-20210702222812577" style="zoom:67%;"><h3 id="3-配置API分组"><a href="#3-配置API分组" class="headerlink" title="3 配置API分组"></a>3 配置API分组</h3><blockquote><p>配置多个分组，写多个docket()即可  groupName(“XXXname”)方法</p><p>在SwaggerConfig类中增加几个docket()方法，如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组1</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分组2</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分组3</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;group3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到多了三个分组，并且三个分组的界面都是初设置的界面（说明各个分组是独立的）</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211256.png" alt="image-20210703151345557" style="zoom:67%;"><h3 id="4-实体配置"><a href="#4-实体配置" class="headerlink" title="4 实体配置"></a>4 实体配置</h3><blockquote><p>简单来说就是当接口返回的是一个实体类时，这个实体类会被扫描到Swagger，然后有两个注解可以为该实体类添加注释并在Swagger中显示：</p><p>@ApiModel为类添加注释 </p><p>@ApiModelProperty为类属性添加注释</p><p>所以显示了有什么用？</p></blockquote><p>1 写一个实体类User，并用两注解加注释</p><p>2 在HelloController类中写个user方法 返回User类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">...<span class="comment">//构造方法 getset方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自带的/error默认错误请求</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要我们的接口中，返回值中存在实体类，他就会被扫描到Swagger中</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;wukang&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211301.png" alt="image-20210703184855701" style="zoom:67%;"><h3 id="5-常用注解以及try-it-out-测试"><a href="#5-常用注解以及try-it-out-测试" class="headerlink" title="5 常用注解以及try it out 测试"></a>5 常用注解以及try it out 测试</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><blockquote><p>狂神这里讲的也不太清楚，我自己改进了几个接口的例子两个get、两个post，都是一个无参、一个有参</p><p>1 hello()方法，直接返回一个“hello”字符串</p><p>2 get(String s) 返回“hello，”+s的字符串、需要输入s</p><p>3 user()方法，返回一个{wukang,1}的User对象</p><p>4 post(User user)方法 返回一个user对象 、需要输入user</p></blockquote><p>Controllsr代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiOperation(&quot;hello测试_无参&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;get测试_有参&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello,&quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;user测试_无参&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;wukang&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;post测试_有参&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">post</span><span class="params">(<span class="meta">@ApiParam(&quot;用户&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211306.png" alt="image-20210703192335145" style="zoom:67%;"><ul><li>1 测试hello()方法，直接返回一个“hello”字符串</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211309.png" alt="image-20210703192507821" style="zoom:67%;"><ul><li>2 测试get(String s) 返回“hello，”+s的字符串、需要输入s</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211312.png" alt="image-20210703192606022" style="zoom:67%;"><ul><li>4 post(User user)方法 返回一个user对象 、需要输入user</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211317.png" alt="image-20210703192717935" style="zoom:67%;"><p>总结：</p><p>这就是Swagger的测试功能、有一说一也就这样，不过确实方便！</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p><h2 id="12-异步、定时、邮件任务"><a href="#12-异步、定时、邮件任务" class="headerlink" title="12 异步、定时、邮件任务"></a>12 异步、定时、邮件任务</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神SpringBoot教学视频学习笔记，包括SpringBoot运行原理、配置文件、自动配置原理、静态资源导入、管理系统实战项目、整合Mybatis、SpringSecurity、Swagger等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="SpringBoot" scheme="https://wukang555.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Vue_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/20/%E6%A1%86%E6%9E%B6_05_Vue_wukang/"/>
    <id>https://wukang555.github.io/2021/06/20/%E6%A1%86%E6%9E%B6_05_Vue_wukang/</id>
    <published>2021-06-20T14:55:00.000Z</published>
    <updated>2022-05-17T12:13:02.223Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Vue前端教学视频学习笔记，包括Vue基本语法、Vue双向绑定、Axios异步通信、Vue简单案例等内容</p><a id="more"></a><h1 id="1-前端知识体系"><a href="#1-前端知识体系" class="headerlink" title="1 前端知识体系"></a>1 前端知识体系</h1><h2 id="1-1-VUE概述"><a href="#1-1-VUE概述" class="headerlink" title="1.1 VUE概述"></a>1.1 VUE概述</h2><p>Vue (读音/vju/, 类似于view)是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。</p><p>Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库(如: vue-router: 跳转，vue-resource: 通信，vuex:管理)或既有项目整合。</p><p>官网：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></p><h2 id="1-2-前端三要素"><a href="#1-2-前端三要素" class="headerlink" title="1.2 前端三要素"></a>1.2 前端三要素</h2><ul><li>HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容</li><li>CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式。</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源码不需经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><h2 id="1-3-JavaScript框架"><a href="#1-3-JavaScript框架" class="headerlink" title="1.3 JavaScript框架"></a>1.3 JavaScript框架</h2><ul><li>JQuery：大家熟知的JavaScript库，优点就是简化了DOM操作，缺点就是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6，7，8；</li><li>Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了<strong>模块化开发</strong>的理念，与微软合作，采用了TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理</li><li>React：Facebook 出品，一款高性能的JS前端框架；特点是提出了新概念 【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言；</li><li><font color="red">Vue</font>：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和React(虚拟 DOM) 的优点；</li><li><font color="red">Axios</font>：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery 提供的AJAX 通信功能；</li></ul><p><strong>前端三大框架：Angular、React、Vue</strong></p><h2 id="1-4-前后端分离演变"><a href="#1-4-前后端分离演变" class="headerlink" title="1.4 前后端分离演变"></a>1.4 前后端分离演变</h2><ul><li><strong>1 后端为主的MVC时代（JSP时代）</strong></li></ul><p>优点：MVC是一个非常好的协作模式， 能够有效降低代码的耦合度从架构上能够让开发者明白代码应该写在哪里。</p><p>缺点：前端开发重度依赖开发环境，开发效率低。前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。</p><ul><li><strong>2 基于AJAX带来的SPA时代</strong></li></ul><p>SPA(Single Page Application) 单页面应用时代</p><p>优点： 前后端的分工非常清晰， 前后端的关键协作点是AJAX接口。</p><p>缺点：SPA应用大多以功能交互型为主，JavaScript代码过十万行很正常。大量JS代码的组织，与View层的绑定等，都不是容易的事情。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210554.png" alt="1595237457081" style="zoom: 67%;"><ul><li><strong>3 前端为主的MVC时代 （MVC、MVP、MVVM）</strong></li></ul><p>优点：<strong>前端开发的复杂度可控</strong>：前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本书的厚度去说明。</p><p>缺点：全异步， 对SEO不利。往往还需要服务端做同步渲染的降级方案。</p><ul><li><strong>4 Node JS带来的全栈时代</strong></li></ul><p>随着Node JS的兴起， JavaScript开始有能力运行在服务端。</p><h1 id="2-第一个Vue程序"><a href="#2-第一个Vue程序" class="headerlink" title="2 第一个Vue程序"></a>2 第一个Vue程序</h1><h2 id="2-1-什么是MVVM"><a href="#2-1-什么是MVVM" class="headerlink" title="2.1 什么是MVVM"></a>2.1 什么是MVVM</h2><p><strong>先看看MVC模型</strong></p><ul><li>model 负责控制业务操作、保存数据、修改数据等操作。包含Service、Dao的操作</li><li>View 视图层负责展示数据模型和提供用户操作的界面</li><li>Contrller 控制器用于接受用户的请求、并讲该请求调用具体的业务层去实现，获取结果后、进行视图的跳转</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210557.png" alt="1568424227281"></p><p><strong>再看看MVVM：</strong></p><p>MVVM 源自于经典的MVC (ModI-View-Controller) 模式。MVVM的核心是<strong>ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用</strong>，其作用如下:</p><ul><li>该层向上与视图层进行双向数据绑定</li><li>向下与Model层通过接口请求进行数据交互</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210600.png" alt="20200720222239842"></p><p>我的理解其实是 “多加”了一个ViewModel层，用来双向绑定View和Model层，而原来的Controller层被“封装”到了现在的Model层中，Model层现在负责处理后台的业务逻辑了。</p><p>==ViewModel层中可以做一些以前控制层做的事情，写一个业务的逻辑代码？并且不需要刷新页面就可以直接更新View视图？是这样么==</p><h2 id="2-2-为什么用MVVM模型"><a href="#2-2-为什么用MVVM模型" class="headerlink" title="2.2 为什么用MVVM模型"></a>2.2 为什么用MVVM模型</h2><p>MVVM模式和MVC模式一样，主要目的是分离视图(View)和模型(Model)。</p><ul><li><p>View：还是视图层， 也就是用户界面，用来展示数据和操作。</p></li><li><p>Model： 泛指后端进行的各种业务逻辑处理和数据操控。主要工作在于和前端约定统一的接口规则</p></li><li><p>ViewModel：是由前端开发人员组织生成和维护的视图数据层</p><ul><li> 前端开发者对从后端获取的Model数据进行转换处理， 做二次封装， 以生成符合View层使用预期的视图数据模型。</li><li> 视图状态和行为都封装在了View Model里。这样的封装使得View Model可以完整地去描述View层。由于实现了双向绑定， View Model的内容会实时展现在View层， 这是激动人心的，因为避免了操纵DOM来更新页面</li></ul></li></ul><p>总结：View层展现的不是<code>Model</code>层的数据， 而是<code>ViewModel</code>的数据， 由<code>ViewModel</code>负责与<code>Model</code>层交互， 这就<strong>完全解耦了View层和Model层， 这个解耦是至关重要的， 它是前后端分离方案实施的重要一环。</strong></p><h2 id="2-3-第一个Vue程序"><a href="#2-3-第一个Vue程序" class="headerlink" title="2.3 第一个Vue程序"></a>2.3 第一个Vue程序</h2><p><strong>Vue.js就是一个MVVM的实现者， 他的核心就是实现了DOM监听与数据绑定。 Vue.js用于连接视图和数据的中间件，作为实际的ViewModel而存在</strong></p><blockquote><p>1 引入Vue.js</p><p>2 编写view，并通过id将vue实例变量与view绑定</p></blockquote><ul><li>1 直接建一个html文件，引入Vue.js即可</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.压缩版的Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>   <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.完整版的Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">“https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js”</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2 编写view，并通过id将vue实例变量与view绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.导入Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag"> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.创建一个vue对象，通过Id:app与视图层绑定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*Model：数据*/</span></span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&quot;hello,vue!&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><p><code>el: &#39;#vue&#39;</code>：绑定元素的ID</p><p><code>data:&#123;message:&#39;Hello Vue!&#39;&#125;</code>：数据对象中有一个名为message的属性，并设置了初始值 Hello Vue！</p><ul><li>3 运行结果：</li></ul><p>可以在控制台直接输入vm.message来修改值， 中间是可以省略data的， 在这个操作中， 我并没有主动操作DOM， 就让页面的内容发生了变化， 这就是借助了Vue的数据绑定功能实现的； MV VM模式中要求View Model层就是使用观察者模式来实现数据的监听与绑定， 以做到数据与视图的快速响应。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210606.png" alt="image-20210625122055568" style="zoom: 50%;"><h1 id="3-Vue的基本语法"><a href="#3-Vue的基本语法" class="headerlink" title="3 Vue的基本语法"></a>3 Vue的基本语法</h1><blockquote><p>快速预览：</p><p>1 v-bind 绑定元素特性，将这个元素节点的title特性和Vue实例的message属性保持一致”。</p><p>2 v-if  v-else  v-else=if 判断语句</p><p>3 v-for 循环语句</p></blockquote><h2 id="3-1-v-bind-绑定元素特性"><a href="#3-1-v-bind-绑定元素特性" class="headerlink" title="3.1 v-bind 绑定元素特性"></a>3.1 v-bind 绑定元素特性</h2><p>vue中常用的属性绑定v-bind、第一种是完整语法，第二种是缩写方式。</p><p>示例一：将元素的title属性和vue实例的相关字段进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将这个元素节点的 title 属性和 Vue 实例的message 属性绑定到一起。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span>&gt;</span>DOM元素属性绑定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>DOM元素属性绑定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> demo1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&#x27;#demo&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            message:<span class="string">&#x27;aaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            msg:<span class="string">&#x27;bbb&#x27;</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例二：将其他的属性字段进行绑定，最常见的是对于样式的绑定，即class和style属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123;active:isActive,&#x27;text-danger&#x27;:hasError&#125;&quot;</span>&gt;</span>给class绑定一个对象，动态切换class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive,&#x27;textDanger&#x27;:!isActive&#125;&quot;</span>&gt;</span>给class绑定一个对象，动态切换class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>给class绑定一个对象，动态切换class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>     <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> demo1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&#x27;#demo&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            isActive:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            hasError:<span class="literal">true</span>,</span></span><br><span class="line">            classObj:&#123;</span><br><span class="line"><span class="javascript">                <span class="string">&#x27;textColor&#x27;</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                <span class="string">&#x27;textSize&#x27;</span>:<span class="literal">false</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210613.png" alt="image-20210625131012282" style="zoom:67%;"><h2 id="3-2-v-if-v-else-v-else-if-判断语句"><a href="#3-2-v-if-v-else-v-else-if-判断语句" class="headerlink" title="3.2 v-if  v-else  v-else=if 判断语句"></a>3.2 v-if  v-else  v-else=if 判断语句</h2><p>直接看代码吧</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">&quot;type===&#x27;A&#x27;&quot;</span>&gt;</span>type的值是A<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type===&#x27;B&#x27;&quot;</span>&gt;</span>type的值是B<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type===&#x27;C&#x27;&quot;</span>&gt;</span>type的值是C<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>type的值是其他<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.导入Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#demo&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*Model：数据*/</span></span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            type: <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210616.png" alt="image-20210625142236188" style="zoom:67%;"><h2 id="3-3-v-for"><a href="#3-3-v-for" class="headerlink" title="3.3 v-for"></a>3.3 v-for</h2><p>view视图层代码：</p><ul><li>注：<code>items</code>是数组，<code>item</code>是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in items&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.message&#125;&#125;---&#123;&#123;index&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--view层，模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in items&quot;</span>&gt;</span></span><br><span class="line">        元素和索引分别为：&#123;&#123;item.message&#125;&#125;,&#123;&#123;index&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.导入Vue.js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el:<span class="string">&quot;#demo&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// model 数据</span></span></span><br><span class="line">       data:&#123;</span><br><span class="line">           items:[</span><br><span class="line"><span class="javascript">               &#123;<span class="attr">message</span>:<span class="string">&#x27;AA&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">               &#123;<span class="attr">message</span>:<span class="string">&#x27;BB&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">               &#123;<span class="attr">message</span>:<span class="string">&#x27;CC&#x27;</span>&#125;,</span></span><br><span class="line">           ]</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210620.png" alt="image-20210625144129557"></p><ul><li>还可以在控制台追加元素：</li></ul><p>在控制台输入<code>vm.items.push(&#123;message：&#39;DD&#39;&#125;)</code>，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条<code>DD</code>.</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210623.png" alt="image-20210625144337948" style="zoom:67%;"><h2 id="3-4-v-on-事件绑定"><a href="#3-4-v-on-事件绑定" class="headerlink" title="3.4 v-on 事件绑定"></a>3.4 v-on 事件绑定</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>狂神说Java<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层 模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;sayHi&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            message: <span class="string">&quot;你点我干嘛？&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//方法必须绑定在Vue的Methods对象中，v-on:事件</span></span></span><br><span class="line"><span class="javascript">            sayHi: (<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="built_in">this</span>.message)</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210631.png" alt="image-20210625145712923" style="zoom:80%;"><h1 id="4-Vue双向绑定-v-model"><a href="#4-Vue双向绑定-v-model" class="headerlink" title="4 Vue双向绑定 v-model"></a>4 Vue双向绑定 <code>v-model</code></h1><p><strong>为什么要实现数据的双向绑定？</strong></p><p>在Vue.js 中，如果使用vuex ，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项,方便跟踪;局部性数据流使用双向，简单易操作。</p><p><strong>在表单中使用双向数据绑定</strong></p><p>你可以用v-model指令在表单 <input>、<textarea> 及</textarea><select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但v-model本质上不过是语法糖。它负责监听户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</select></p><p> 注意：v-model会忽略所有元素的value、checked、selected特性的初始值而总是将Vue实例的数据作为数据来源，你应该通过JavaScript在组件的data选项中声明。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--view层 模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    下拉框：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">disabled</span>&gt;</span>-请选择-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>value:&#123;&#123;selected&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入js--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            selected: <span class="string">&quot;&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210635.png" alt="image-20210625150723173"></p><h1 id="5-Axios异步通信"><a href="#5-Axios异步通信" class="headerlink" title="5 Axios异步通信"></a>5 Axios异步通信</h1><h2 id="5-1-什么是Axios"><a href="#5-1-什么是Axios" class="headerlink" title="5.1 什么是Axios"></a>5.1 什么是Axios</h2><p>  Axios是一个开源的可以用在浏览器端和<code>Node JS</code>的异步通信框架， 她的主要作用就是实现AJAX异步通信，这里就是替代jQuery的AJAX，其功能特点如下：</p><ul><li>从浏览器中创建<code>XMLHttpRequests</code></li><li>从node.js创建http请求</li><li>支持Promise API[JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御XSRF(跨站请求伪造)</li></ul><p>GitHub：<a href="https://github.com/axios/axios">https://github.com/axios/axios</a> </p><p>中文文档：<a href="http://www.axios-js.com/">http://www.axios-js.com/</a></p><p>​        由于<code>Vue.js</code>是一个视图层框架并且作者(尤雨溪) 严格准守SoC(关注度分离原则)所以<code>Vue.js</code>并不包含AJAX的通信功能， 为了解决通信问题， 作者并推荐使用<code>Axios</code>框架。少用jQuery， 因为它操作Dom太频繁!</p><h2 id="5-2-第一个Axios应用程序"><a href="#5-2-第一个Axios应用程序" class="headerlink" title="5.2 第一个Axios应用程序"></a>5.2 第一个Axios应用程序</h2><blockquote><p>1 先建一个保存JSON数据的文件data.json</p><p>2  引入vue的组件 和 axios的组件</p><p>3 使用data()函数和mounted()钩子函数，获取JSON格式的数据，保存在Vue的对象变量中</p><p>4 view视图层展示 获取到的变量</p></blockquote><ul><li>1 先建一个保存JSON数据的文件data.json</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;狂神说Java&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://blog.kuangstudy.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;isNonProfit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;street&quot;</span>: <span class="string">&quot;含光门&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;陕西西安&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;中国&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;links&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;bilibili&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://space.bilibili.com/95256449&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;狂神说Java&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://blog.kuangstudy.com&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;百度&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://www.baidu.com/&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 引入vue的组件 和 axios的组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入vue、axios的组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>3 使用data()函数和mounted()钩子函数，获取JSON格式的数据</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">&quot;#vue&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">//data()函数</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line">                info:&#123;</span><br><span class="line"><span class="javascript">                    name:<span class="literal">null</span>,</span></span><br><span class="line">                    address:&#123;</span><br><span class="line"><span class="javascript">                        country:<span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                        city:<span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">                        street:<span class="literal">null</span></span></span><br><span class="line">                    &#125;,</span><br><span class="line"><span class="javascript">                    url:<span class="literal">null</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;<span class="comment">//钩子函数</span></span></span><br><span class="line">            axios</span><br><span class="line"><span class="javascript">                .get(<span class="string">&#x27;data.json&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                .then(<span class="function"><span class="params">response</span>=&gt;</span>(<span class="built_in">this</span>.info=response.data));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>4 view视图层展示 获取到的变量</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue&quot;</span>  <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>地名：&#123;&#123;info.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>地址：&#123;&#123;info.address.country&#125;&#125;--&#123;&#123;info.address.city&#125;&#125;--&#123;&#123;info.address.street&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;info.url&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>&#123;&#123;info.url&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210641.png" alt="image-20210625154044593" style="zoom:67%;"><p><strong>说明：</strong></p><ol><li>在这里使用了v-bind将a:href的属性值与Vue实例中的数据进行绑定</li><li>使用axios框架的get方法请求AJAX并自动将数据封装进了Vue实例的数据对象中</li><li>我们在data中的数据结构必须和<code>Ajax</code>响应回来的数据格式匹配！</li></ol><h2 id="5-3-Vue的生命周期"><a href="#5-3-Vue的生命周期" class="headerlink" title="5.3 Vue的生命周期"></a>5.3 Vue的生命周期</h2><p>官方文档：<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">https://cn.vuejs.org/v2/guide/instance.html#生命周期图示</a></p><p>Vue实例有一个完整的生命周期，也就是从开始创建初女台化数据、编译模板、挂载DOM、渲染一更新一渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p>在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法，可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210644.png" alt="1595253373596" style="zoom:67%;"><h1 id="6-第一个vue-cli项目"><a href="#6-第一个vue-cli项目" class="headerlink" title="6 第一个vue-cli项目"></a>6 第一个vue-cli项目</h1><h2 id="6-1-vue-cli-环境"><a href="#6-1-vue-cli-环境" class="headerlink" title="6.1 vue-cli 环境"></a>6.1 vue-cli 环境</h2><p><strong>（简单来说就是类似我们后端的maven，新建vue项目的一个骨架）</strong></p><ul><li>vue-cli官方提供的一个脚手架，用于快速生成一个vue的项目模板</li><li>预先定义好的目录结构及基础代码，就好比咱们在创建Maven项目时可以选择创建一个骨架项目，这个估计项目就是脚手架，我们的开发更加的快速；</li></ul><blockquote><p>环境安装</p><p>1 安装nodejs</p><p>2 安装Node.js淘宝镜像加速器（cnpm）</p><p>3 安装vue-cli</p></blockquote><ul><li><strong>1 安装nodejs</strong></li></ul><p>Node.js：<a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a>   安装就是无脑的下一步就好，安装在自己的环境目录下</p><p>cmd下输入<code>node -v</code>，查看是否能够正确打印出版本号即可！</p><p>cmd下输入<code>npm -v</code>，查看是否能够正确打印出版本号即可！</p><ul><li><strong>2 安装Node.js淘宝镜像加速器（cnpm）</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -g 就是全局安装</span><br><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure><ul><li><strong>3 安装vue-cli</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm instal1 vue-cli-g</span><br><span class="line">#测试是否安装成功#</span><br><span class="line">vue list</span><br></pre></td></tr></table></figure><p>安装的位置默认:<code>C:\Users\administrator\AppData\Roaming\npm</code></p><h2 id="6-2-第一个vue-cli项目"><a href="#6-2-第一个vue-cli项目" class="headerlink" title="6.2 第一个vue-cli项目"></a>6.2 第一个vue-cli项目</h2><p>1 创建一个Vue项目，我们随便建立一个空的文件夹在电脑上，我这里在D盘下新建一个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Project\vue-study;</span><br></pre></td></tr></table></figure><p>2 创建一个基于webpack模板的vue应用程序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1、首先需要进入到对应的目录 cd D:\Project\vue-study</span></span><br><span class="line"><span class="comment">#2、这里的myvue是顶日名称，可以根据自己的需求起名</span></span><br><span class="line">vue init webpack myvue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一路都选择no即可；</span></span><br></pre></td></tr></table></figure><p> 3 初始化并运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myvue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p> 执行完成后,目录多了很多依赖，<a href="http://localhost:8080/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%88%E8%BF%90%E8%A1%8C%E5%AE%8C%E4%B9%8B%E5%90%8E%E7%94%A8ctrl+c%E5%85%B3%E9%97%AD%EF%BC%89">http://localhost:8080/运行结果如下（运行完之后用ctrl+c关闭）</a></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210653.png" alt="image-20210625164125927" style="zoom: 33%;"><h2 id="6-3-用IDEA打开-看看项目结构"><a href="#6-3-用IDEA打开-看看项目结构" class="headerlink" title="6.3 用IDEA打开 看看项目结构"></a>6.3 用IDEA打开 看看项目结构</h2><p>目录结构如下：src下写源码</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210656.png" alt="image-20210625164949201" style="zoom:50%;"><ul><li>主页面index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>myvue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>src下的main.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>components下的HelloWorld.vue，，这里我把删一点 只留一个图片和几个字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;吴康最帅&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;Welcome to Your Vue.js App&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210700.png" alt="image-20210625165607461" style="zoom:50%;"><h1 id="7-Webpack打包"><a href="#7-Webpack打包" class="headerlink" title="7 Webpack打包"></a>7 Webpack打包</h1><h2 id="7-1-Webpack的安装和配置"><a href="#7-1-Webpack的安装和配置" class="headerlink" title="7.1 Webpack的安装和配置"></a>7.1 Webpack的安装和配置</h2><p>WebPack 是一款<strong>模块加载器兼打包工具</strong>，说白了就是能将ES6的项目代码打包后、在ES5的浏览器上可以运行。</p><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure><p> 测试安装成功: 输入以下命令有版本号输出即为安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack -v</span><br><span class="line">webpack-cli -v</span><br></pre></td></tr></table></figure><p>配置：创建 <code>webpack.config.js</code>配置文件</p><ul><li>entry：入口文件， 指定Web Pack用哪个文件作为项目的入口</li><li>output：输出， 指定WebPack把处理完成的文件放置到指定路径</li><li>module：模块， 用于处理各种类型的文件</li><li>plugins：插件， 如：热更新、代码重用等</li><li>resolve：设置路径指向</li><li>watch：监听， 用于设置文件改动后直接打包</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry:<span class="string">&quot;&quot;</span>,</span><br><span class="line">output:&#123;</span><br><span class="line">path:<span class="string">&quot;&quot;</span>,</span><br><span class="line">filename:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">loaders:[</span><br><span class="line">&#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,;\loade:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins:&#123;&#125;,</span><br><span class="line">resolve:&#123;&#125;,</span><br><span class="line">watch:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  直接运行<code>webpack</code>命令打包</p><h2 id="7-2-使用webpack"><a href="#7-2-使用webpack" class="headerlink" title="7.2 使用webpack"></a>7.2 使用webpack</h2><p>首先是打包部分、将一个项目打包：</p><p>1 创建项目（创建一个空文件夹，用idea打开）</p><p>2 创建一个名为modules的目录，用于放置JS模块等资源文件</p><p>3 在modules下创建模块文件，如hello.js，用于编写JS模块相关代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴露一个方法</span></span><br><span class="line"><span class="built_in">exports</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;狂神说ES6&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.sayHi2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;狂神说ES6 2&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 在modules下创建一个名为main.js的入口文件，用于打包时设置entry属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//require 导入一个模块，就可以调用这个模块中的方法了</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line">hello.sayHi();</span><br><span class="line">hello.sayHi2();</span><br></pre></td></tr></table></figure><p>5 在项目目录下创建webpack.config.js配置文件，并使用webpack命令打包，命令就是webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">entry:<span class="string">&quot;./modules/main.js&quot;</span>,</span><br><span class="line">output:&#123;</span><br><span class="line">filename:<span class="string">&quot;./js/bundle.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包完我们发现 主目录生成了一个dist文件 生成的打包文件路径为/ dist/js/bundle.js</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210705.png" alt="image-20210626001521761" style="zoom: 67%;"><p>其次是运行打包好的js文件：</p><p>1 在主目录创建index.html 并导入bundle.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;dist/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2 直接运行这个html页面，得到我们在hello中写的两个方法</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210708.png" alt="image-20210626001711269" style="zoom:50%;"><p>完毕。</p><h1 id="8-vue-router路由"><a href="#8-vue-router路由" class="headerlink" title="8 vue-router路由"></a>8 vue-router路由</h1><p>vue.js专注于视图，所以连跳转的功能都没有，需要借助Vue Router来实现路径的跳转。</p><p>Vue Router是Vue.js官方的<strong>路由管理器</strong>（路径跳转）。它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌。</p><h2 id="8-1-安装"><a href="#8-1-安装" class="headerlink" title="8.1 安装"></a>8.1 安装</h2><p>打开命令行工具，进入你的项目目录，输入下面命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure><p>安装完之后去node_modules路径看看是否有vue-router信息 有的话则表明安装成功</p><p>如果在一个模块化工程中使用它，必须要通过Vue.use()明确地安装路由功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br></pre></td></tr></table></figure><h2 id="8-2-使用Vue-Router的项目"><a href="#8-2-使用Vue-Router的项目" class="headerlink" title="8.2 使用Vue Router的项目"></a>8.2 使用Vue Router的项目</h2><p>1 创建一个名为 hello-vue 的工程</p><p>2 安装依赖，我们需要安装 vue-router、element-ui、sass-loader 和node-sass 四个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 进入工程目录</span><br><span class="line">cd hello-vue</span><br><span class="line"># 安装 vue-router</span><br><span class="line">npm install vue-router --save-dev</span><br><span class="line"># 安装 element-ui</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 安装依赖</span><br><span class="line">npm install</span><br><span class="line"># 安装 SASS 加载器</span><br><span class="line">cnpm install sass-loader node-sass --save-dev</span><br><span class="line"># 启动测试</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>3 Npm命令解释</p><ul><li>npm install moduleName：安装模块到项目目录下</li><li>npm install -g moduleName：-g 的意思是将模块安装到全局，具体安装到磁盘的哪个位置，要看 npm config prefix的位置</li><li>npm install moduleName -save：–save的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖，-S为该命令的缩写</li><li>npm install moduleName -save-dev：–save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖，-D为该命令的缩写</li></ul><p>4 创建成功后用idea打开，并删除净东西 创建views和router文件夹用来存放视图和路由</p><p>5 在views创建Main.vue</p><p>6 在views中创建Login.vue视图组件</p><p>7 创建路由。在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件</p><p>8 在main.js中配置相关。 main.js是index.html调用的 所以前面注册的组件要在这里导入</p><p>​        <strong>一定不要忘记扫描路由配置并将其用到new Vue中</strong></p><p>9 在App.vue中配置显示视图</p><p>10 测试运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>各个步骤的文件：</p><ul><li>Main.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;首页&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>Login.vue（用的ElementUI中的代码）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-form ref&#x3D;&quot;loginForm&quot; :model&#x3D;&quot;form&quot; :rules&#x3D;&quot;rules&quot; label-width&#x3D;&quot;80px&quot; class&#x3D;&quot;login-box&quot;&gt;</span><br><span class="line">      &lt;h3 class&#x3D;&quot;login-title&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;账号&quot; prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入账号&quot; v-model&#x3D;&quot;form.username&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;请输入密码&quot; v-model&#x3D;&quot;form.password&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; v-on:click&#x3D;&quot;onSubmit(&#39;loginForm&#39;)&quot;&gt;登录&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;el-form-item&gt;</span><br><span class="line">    &lt;&#x2F;el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog</span><br><span class="line">      title&#x3D;&quot;温馨提示&quot;</span><br><span class="line">      :visible.sync&#x3D;&quot;dialogVisible&quot;</span><br><span class="line">      width&#x3D;&quot;30%&quot;</span><br><span class="line">      :before-close&#x3D;&quot;handleClose&quot;&gt;</span><br><span class="line">      &lt;span&gt;请输入账号和密码&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;dialogVisible &#x3D; false&quot;&gt;确 定&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;el-dialog&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &quot;Login&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        form: &#123;</span><br><span class="line">          username: &#39;&#39;,</span><br><span class="line">          password: &#39;&#39;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 表单验证，需要在 el-form-item 元素中增加 prop 属性</span><br><span class="line">        rules: &#123;</span><br><span class="line">          username: [</span><br><span class="line">            &#123;required: true, message: &#39;账号不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ],</span><br><span class="line">          password: [</span><br><span class="line">            &#123;required: true, message: &#39;密码不可为空&#39;, trigger: &#39;blur&#39;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对话框显示和隐藏</span><br><span class="line">        dialogVisible: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onSubmit(formName) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为表单绑定验证功能</span><br><span class="line">        this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用 vue-router 路由到指定页面，该方式称之为编程式导航</span><br><span class="line">            this.$router.push(&quot;&#x2F;main&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.dialogVisible &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .login-box &#123;</span><br><span class="line">    border: 1px solid #DCDFE6;</span><br><span class="line">    width: 350px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    padding: 35px 35px 15px 35px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    box-shadow: 0 0 25px #909399;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .login-title &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    margin: 0 auto 40px auto;</span><br><span class="line">    color: #303133;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>index.js：</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&quot;../views/Main&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&quot;../views/Login&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>main.js:</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">//扫描路由配置</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//导入elementUI</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span></span><br><span class="line"><span class="comment">//导入element css</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(router);</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),<span class="comment">//ElementUI规定这样使用</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;login&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210715.png" alt="在这里插入图片描述" style="zoom:80%;"><blockquote><p>测试：在浏览器打开 <a href="http://localhost:8080/#/login">http://localhost:8080/#/login</a><br>如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.0.2，需要退回到7.3.1<br>去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新cnpm install就可以了；</p></blockquote><h1 id="9-实站上手项目"><a href="#9-实站上手项目" class="headerlink" title="9 实站上手项目"></a>9 实站上手项目</h1><p>8.2就是一个简单的项目框架了…Vue先不看了。狂神讲的并不好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Vue前端教学视频学习笔记，包括Vue基本语法、Vue双向绑定、Axios异步通信、Vue简单案例等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="前端" scheme="https://wukang555.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://wukang555.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/15/%E6%A1%86%E6%9E%B6_04_SpringMVC_wukang/"/>
    <id>https://wukang555.github.io/2021/06/15/%E6%A1%86%E6%9E%B6_04_SpringMVC_wukang/</id>
    <published>2021-06-15T14:55:00.000Z</published>
    <updated>2022-05-17T11:51:41.167Z</updated>
    
    <content type="html"><![CDATA[<p>狂神SpringMVC教学视频学习笔记，包括回顾JavaWeb、SpringMVC原理、RestFul风格、JSON、整合SSM等内容</p><a id="more"></a><h1 id="0-JAVAWEB回顾"><a href="#0-JAVAWEB回顾" class="headerlink" title="0 JAVAWEB回顾"></a>0 JAVAWEB回顾</h1><p>首先回顾一下之前<code>JavaWeb</code>的学习笔记</p><p>一个网站的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--webapps ：Tomcat服务器的web目录</span><br><span class="line">-ROOT</span><br><span class="line">-kuangstudy ：网站的目录名</span><br><span class="line">- WEB-INF</span><br><span class="line">-classes : java程序</span><br><span class="line">-lib：web应用所依赖的jar包</span><br><span class="line">-html文件夹  内含各种html页面</span><br><span class="line">-web.xml ：网站配置文件</span><br><span class="line">- index.html 默认的首页</span><br><span class="line">- static  各种静态资源</span><br><span class="line">            -css</span><br><span class="line">            -js</span><br><span class="line">            -img</span><br><span class="line">         -.....</span><br></pre></td></tr></table></figure><p>HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p><ul><li>Http请求：get 、post</li><li>Http响应：响应状态码</li><li>浏览器输入url后回车到页面展示，经历的过程？</li></ul><p>Maven：项目架构管理工具</p><p>Tomcat服务器：是一个免费的开放源代码的Web 轻量级应用服务器</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet：把实现了Servlet接口的Java程序叫做Servlet，HttpServlet接口。</p><ul><li>1 编写一个普通类HelloServlet实现Servlet接口，这里我们直接继承HttpServlet</li><li>2 编写Servlet的映射，即在web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径</li><li>3 配置Tomcat，启动测试</li></ul><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210427.png" alt="1567913793252"></p><ul><li>ServletContext代表了当前的web应用，功能有：共享数据、获取初始化参数、请求转发、读取资源文件Properties，</li><li>HttpServletResponse响应，功能有输出消息、下载文件、验证码、重定向、登录重定向</li><li>HttpServletRequest请求，获得客户端的所有信息，获取参数、请求转发</li></ul><h2 id="Cookie、Session"><a href="#Cookie、Session" class="headerlink" title="Cookie、Session"></a>Cookie、Session</h2><p><strong>Cookie通过在客户端记录信息确定用户身份</strong></p><p>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。Cookie实际上是一小段的文本信息，储存在浏览器中。服务器还可以根据需要修改Cookie的内容。</p><p><strong>Session通过在服务器端记录信息确定用户身份</strong></p><p>Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><p>Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p><p><strong>cookie和session的区别</strong></p><ul><li><p>一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</p></li><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上.</p></li><li><p>session会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie，考虑到安全应当使用session。</p></li><li><p>单个cookie保存的数据不能超过4K，很e多浏览器都限制一个站点最多保存20个cookie</p></li></ul><h2 id="JSP-Java-Server-Pages"><a href="#JSP-Java-Server-Pages" class="headerlink" title="JSP: Java Server Pages"></a>JSP: Java Server Pages</h2><p>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</p><p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p><p>JSP最终也会被转换成为一个Java类！JSP 本质上就是一个Servlet</p><p>JSP语法，JSP9大内置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- PageContext    存东西</span><br><span class="line">- Request     存东西</span><br><span class="line">- Response</span><br><span class="line">- Session      存东西</span><br><span class="line">- Application   【SerlvetContext】   存东西</span><br><span class="line">- config    【SerlvetConfig】</span><br><span class="line">- out</span><br><span class="line">- page ，不用了解</span><br><span class="line">- exception</span><br></pre></td></tr></table></figure><p><strong>作用域的区别：</strong></p><p>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看就没用的！</p><p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p><p>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p><h2 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210430.png" alt="1568424227281"></p><p><strong>Model</strong></p><ul><li>业务处理 ：业务逻辑（Service）</li><li>数据持久层：CRUD   （Dao）</li></ul><p><strong>View</strong></p><ul><li>展示数据</li><li>提供链接发起Servlet请求 （a，form，img…）</li></ul><p><strong>Controller  （Servlet）</strong></p><ul><li><p>接收用户的请求 ：（req：请求参数、Session信息….）</p></li><li><p>交给业务层处理对应的代码 </p></li><li><p>控制视图的跳转  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库</span><br></pre></td></tr></table></figure><p>过滤器Filter、监听器</p><h1 id="1-回顾Servlet"><a href="#1-回顾Servlet" class="headerlink" title="1 回顾Servlet"></a>1 回顾Servlet</h1><p>首先搭建基本环境：建一个Maven项目作为父项目，导入公用的依赖，建子Maven普通项目、并添加框架支持web-app.</p><blockquote><p>Servlet开发的三个步骤如下：</p><ul><li>1 编写一个普通类XXServlet实现Servlet接口，这里我们直接继承HttpServlet</li><li>2 修改欢迎界面index.jsp（即首页）做成表单的格式 ；   编写视图界面hello.jsp</li><li>3 编写Servlet的映射，即在web.xml服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径</li><li>4 配置Tomcat，启动测试</li></ul></blockquote><ul><li>1  编写一个Servlet类，重写doGet和doPost方法用来处理用户的请求<ul><li>前端传过来的参数name为<code>method111</code>,存入字符method中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取前端参数</span></span><br><span class="line">        String method = req.getParameter(<span class="string">&quot;method111&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;add&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了add方法。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(method.equals(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            req.getSession().setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;执行了delete方法。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 调用业务层</span></span><br><span class="line">        <span class="comment">//3.视图转发 (或者重定向)</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/hello.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 修改欢迎界面index.jsp做成表单的格式 ；   编写视图界面hello.jsp<ul><li>index.jsp首页界面默认存在，body部分洗一个表单提交参数 name设为<code>method111</code>,,传参方式为<code>post</code></li><li>写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</li></ul></li></ul><p>index.jsp</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> <span class="attr">language</span>=<span class="string">&quot;java&quot;</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;method111&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hello.jsp</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> <span class="attr">language</span>=<span class="string">&quot;java&quot;</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>wuKang<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 获取<span class="attr">setvlst</span>中传递的<span class="attr">msg</span>?<span class="attr">--</span>%&gt;</span></span><br><span class="line">    $&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>3 在web.xml配置中编写Servlet的映射，用mapping指定url</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在web.xml中注册Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--超时，刷新--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>4 配置Tomcat，启动测试</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210437.png" alt="image-20210615154618690" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210439.png" alt="image-20210615154652051" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210442.png" alt="image-20210615154707389" style="zoom:67%;"><h1 id="2-初识Spring-MVC"><a href="#2-初识Spring-MVC" class="headerlink" title="2 初识Spring MVC"></a>2 初识Spring MVC</h1><p>先用一个springMCV的demo入门，然后一究其原理。</p><h2 id="2-1-第一个Spring-MVC程序"><a href="#2-1-第一个Spring-MVC程序" class="headerlink" title="2.1 第一个Spring MVC程序"></a>2.1 第一个Spring MVC程序</h2><blockquote><p>1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p><p>2、确定导入了SpringMVC 的依赖！</p><p>3、配置web.xml  ， 注册DispatcherServlet【写死的】</p><p>​        注册DispatcherServlet,并将其关联一个springmvc的配置文件:【servlet-name】-servlet.xml</p><p>​        设置DispatcherServlet，能匹配所有的请求</p><p>4、在resource目录下编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的</p><p>​    添加 处理映射器【写死的】</p><p>​    添加 处理器适配器【写死的】</p><p>​    添加 视图解析器【写死的】</p><p><strong>5、 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个 ModelAndView，装数据，封视图；</strong></p><p><strong>6、 将自己的类HelloController交给SpringIOC容器，注册bean</strong></p><p><strong>7、写要跳转的jsp页面hello.jsp，显示ModelandView存放的数据，以及我们的正常首页index.jsp；</strong></p><p>8、 配置tomcat,启动</p></blockquote><ul><li>3、配置web.xml  ， 注册DispatcherServlet【写死的】</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>4、在resource目录下编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml 【三个写死的】</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加 处理映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加 处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView</span></span><br><span class="line"><span class="comment">    1. 获取了ModelAndView的数据</span></span><br><span class="line"><span class="comment">    2. 解析ModelAndView的视图名字</span></span><br><span class="line"><span class="comment">    3. 拼接视图名字，找到对应的视图</span></span><br><span class="line"><span class="comment">    4. 将数据渲染到当前视图上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>5、 编写我们要操作业务HelloController，要么实现Controller接口，要么增加注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//封装对象，放在ModelAndView中。Model</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMVC_wukang!&quot;</span>);</span><br><span class="line">        <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;hello&quot;</span>); <span class="comment">//: /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6、 在springmvc的配置文件springmvc-servlet.xml中注册了一下类HelloController</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在spring中注册我们的HelloController--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>7、在WEB-INF包下建jsp包下写一个hello.jsp</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;wuKang&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- 获取setvlst中传递的msg?--%&gt;</span><br><span class="line">    $&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>8、配置Tomcat 并启动</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210447.png" alt="image-20210616154510544" style="zoom:67%;"><p>可能遇到的问题：访问出现404，排查步骤： 1. 查看控制台输出，看一下是不是缺少了什么jar包。 2. 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！3. 重启Tomcat 即可解决！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210450.png" alt="2342e76435475876" style="zoom: 33%;"><p><strong>总结</strong> </p><p>/hello没有在web.xml中配置也没有写Servlet，springmvc配置文件的处理映射器、处理器适配器等将去自动匹配可以处理这个/hello，url的Controller，然后对应的Controller返回一个ModelAndView，然后视图解析式帮我们拼接出来真正hello.jsp所在的位置，返回该页面。</p><p>也就是如果要有一个新的url： /hello2，，我们只需要在springmvc的配置文件中注册一下，然后再写一个具体的Controller类就好了。（不用再写Servlet了）</p><h2 id="2-2-SprincgMVC执行原理"><a href="#2-2-SprincgMVC执行原理" class="headerlink" title="2.2 SprincgMVC执行原理"></a>2.2 SprincgMVC执行原理</h2><p><strong>中心控制器DispatcherServlet</strong></p><p>SpringMVC的执行过程是围绕着<strong>DispatcherServlet</strong>的调度来设计的，称为中心控制器。SpringMVC框架也是以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，<strong>DispatcherServlet实际上就是一个具体的Servlet (它继承自HttpServlet 基类)，也就是说DispatcherServlet就是SpringMVC框架的中心Servlet。</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210453.png" alt="image-20210616171211973" style="zoom: 50%;"><p><strong>SprincgMVC的执行流程</strong></p><p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p><p>DispatcherServlet的作用是将请求分发到不同的处理器。不同的处理器处理并返回对应的结果给DispatcherServlet，最核心的三个大步骤如下：</p><ul><li>1 2 3 4步调用处理器映射HandlerMapping 和 解析控制器映射HandlerExecution<ul><li>其主要作用是根据url查找控制器，上面url被查找控制器Hander 为：hello。</li></ul></li><li>5 6 7 8步 就是调用我们找到的控制器Hander 让他调用Controller,获得视图和Model<ul><li>HandlerAdapter表示处理器适配器，让具体的Controller执行</li><li>Controller执行时调用dao层，获得具体的执行结果</li></ul></li><li>9 10 11 12步 可以说是视图渲染和呈现视图<ul><li>视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名</li><li>DispatcherServlett根据视图解析器解析的视图结果，调用具体的视图</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210501.png" alt="img"></p><p>具体的执行过程（贴过来吧）：上图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p><blockquote><ul><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。<strong>用户发出请求，DispatcherServlet接收请求并拦截请求。</strong>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello%EF%BC%8C%E4%B8%8Aurl%E8%A1%A8%E7%A4%BA%E4%B8%BA%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%BD%8D%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8localhost:8080%E4%B8%8A%E7%9A%84SpringMVC%E7%AB%99%E7%82%B9%E7%9A%84hello%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%82">http://localhost:8080/SpringMVC/hello，上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</a></p></li><li><p>HandlerMapping为处理器映射。<strong>DispatcherServlet调用HandlerMapping。HandlerMapping根据请求url查找Handler</strong>。</p></li><li><p><strong>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器</strong>，如上url被查找控制器为：hello</p></li><li><p><strong>HandlerExecution</strong>将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p></li><li><p><strong>Handler让具体的Controller执行</strong>Controller将具体的执行信息返回给HandlerAdapter,如<strong>ModelAndView</strong>。</p></li><li><p><strong>HandlerAdapter</strong>将视图逻辑名或模型传递给DispatcherServlet。</p></li><li><p><strong>DispatcherServlet</strong>调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p></li><li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p></li><li><p>最终视图呈现给用户。</p></li></ul></blockquote><h2 id="2-3-注解版的Spring-MVC程序"><a href="#2-3-注解版的Spring-MVC程序" class="headerlink" title="2.3 注解版的Spring MVC程序"></a>2.3 注解版的Spring MVC程序</h2><p>环境搭建好之后，只需要编写具体的Controller类（使用注解），编写视图页面hello.jsp，</p><blockquote><p>1 新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！</p><p>2 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们 在父依赖中已经引入了！此时加一个<code>&lt;build&gt;&lt;/build&gt;</code>避免资源过滤问题【写死的】</p><p>3 配置web.xml，注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1  映射路径为 / 【写死的】</p><p>4 添加Spring MVC配置文件springmvc-servlet.xml【写死的】</p><p>​        自动扫描包，让指定包下的注解生效,由IOC容器统一管理 </p><p>​        让Spring MVC不处理静态资源</p><p>​        支持mvc注解驱动</p><p>​         视图解析器 </p><p><strong>5 编写一个Java控制类：HelloController</strong></p><p>​        @Controller是为了让Spring IOC容器初始化时自动扫描到；</p><p>​        @RequestMapping是为了映射请求路径</p><p>​        方法中声明Model类型的参数是为了把Action中的数据带到视图中</p><p>​        方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。</p><p><strong>6 在WEB-INF/ jsp目录中创建hello.jsp</strong>，视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象</p><p>7 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！</p></blockquote><ul><li>2 在pom.xml文件引入相关的依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 配置web.xml，注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1  映射路径为 / </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4 在resource下添加Spring MVC配置文件springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5 编写一个Java控制类：HelloController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/HelloController&quot;)</span>  <span class="comment">//localhost:8080/HelloController/h1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/h1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//封装数据 向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Hello,SpringMVCAnnotation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">// 会被视图解析器处理 web-inf/jsp/hello.jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 在WEB-INF/ jsp目录中创建hello.jsp</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> <span class="attr">language</span>=<span class="string">&quot;java&quot;</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>wuKang222<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%--</span> 获取<span class="attr">setvlst</span>中传递的<span class="attr">msg</span>?<span class="attr">--</span>%&gt;</span></span><br><span class="line">    $&#123;msg&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>7 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210509.png" alt="image-20210616172225399" style="zoom:67%;"><p>如果还是访问出现404就在IDEA的项目发布中，添加lib依赖！然后重启Tomcat！</p><h2 id="2-4-注解介绍和RestFul风格"><a href="#2-4-注解介绍和RestFul风格" class="headerlink" title="2.4 注解介绍和RestFul风格"></a>2.4 注解介绍和RestFul风格</h2><p>@Controller和@RequestMapping</p><p>@Controller是为了让Spring IOC容器初始化时自动扫描到控制类；Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;nuc.ss.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/h1；</p><h3 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h3><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>举一个传参的栗子：<code>@RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;)</code></strong></p><p>需要使用 @PathVariable 注解，让方法参数的值对应绑定到一个URL模板变量上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/add/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> <span class="keyword">int</span> p2, Model model)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = p1+p2;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果为：&quot;</span>+result);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210513.png" alt="在这里插入图片描述"></p><ul><li>使用RestFul，访问 localhost:8080/add/1/2 ，返回的界面为“结果为：3”</li><li>如果不使用的话，以前的访问路径是 localhost:8080/add/a=1&amp;b=2</li></ul><p><strong>栗子2：使用method属性指定请求类型</strong></p><p>几个类似的组合注解，用于指定请求的方式。比如：<code>@GetMapping</code> 是一个组合注解 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p><ul><li>@GetMapping </li><li>@PostMapping </li><li>@PutMapping </li><li>@DeleteMapping</li><li>@PatchMapping</li></ul><p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 查询,GET</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 删除,DELETE</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;item 新增,POST</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;item 更新,PUT</span><br></pre></td></tr></table></figure><p>比如 查询和删除的url一样、新增和更新的url也一样，但指定的请求方式不一样，会走不同的方法。一般来说<strong>所有的地址栏请求默认都会是GET 类型的。</strong></p><h2 id="2-5、处理提交数据"><a href="#2-5、处理提交数据" class="headerlink" title="2.5、处理提交数据"></a>2.5、处理提交数据</h2><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?name=kuangshen">http://localhost:8080/hello?name=kuangshen</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : kuangshen</p><p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?username=kuangshen">http://localhost:8080/hello?username=kuangshen</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : kuangshen</p><p><strong>3、提交的是一个对象</strong></p><p>要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p><ol><li><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//get/set</span></span><br><span class="line">   <span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p></li><li><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>后台输出 : User { id=1, name=‘kuangshen’, age=15 }</p><p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p><h2 id="2-6、数据显示到前端"><a href="#2-6、数据显示到前端" class="headerlink" title="2.6、数据显示到前端"></a>2.6、数据显示到前端</h2><p><strong>第一种 : 通过ModelAndView</strong></p><p>我们前面一直都是如此 . 就不过多解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种 : 通过ModelMap</strong></p><p>ModelMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap modelMap)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   modelMap.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种 : 通过Model</strong></p><p>Model</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对比</strong></p><p>就对于新手而言简单来说使用区别就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；</span><br><span class="line">ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</span><br><span class="line">ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</span><br></pre></td></tr></table></figure><p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p><h2 id="2-7-处理乱码问题"><a href="#2-7-处理乱码问题" class="headerlink" title="2.7 处理乱码问题"></a>2.7 处理乱码问题</h2><p>处理办法，直接使用SpringMVC内置一个过滤器，直接在web.xml中注册即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springMVC内置过滤器防乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>举一个例子：</p><ul><li>在WEB-INF文件下面写一个form表单页面form.jsp</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;form_wukang&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/hello/h3&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;nameForm&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>HelloController中写一个获取表单数据，并再传给前端页面hello.jsp的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理提交的数据并显示到前端</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/hello/h3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test02</span><span class="params">(String nameForm,Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取表单提交的nameForm值 再传给前端</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg_wk&quot;</span>,nameForm);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hello.jsp前端页面</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title_wukang&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- 获取setvlst中传递的msg?--%&gt;</span><br><span class="line">    获取的参数为：$&#123;msg_wk&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>要注意的是form表单的action要和test02方法的路径一致，form表单的name要和test02的参数名一致；还有后台通过model传值给前端的msg_wk变量名也是要保证一致的。</p><ul><li>没有设置过滤器和设置了过滤器之后的结结果对比</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210521.png" alt="image-20210618103454834" style="zoom:80%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210523.png" alt="image-20210618103401530" style="zoom:80%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210526.png" alt="image-20210618103411683" style="zoom:67%;"><h1 id="3-JSON"><a href="#3-JSON" class="headerlink" title="3 JSON"></a>3 JSON</h1><h2 id="3-1-JSON介绍"><a href="#3-1-JSON介绍" class="headerlink" title="3.1 JSON介绍"></a>3.1 JSON介绍</h2><p><strong>前后端分离时代：</strong></p><ul><li><p>后端部署后端：提供接口、提供数据</p><p>​    ==<strong>JOSN就是用来在前后端之间传递数据的一种格式</strong>==</p></li><li><p>前端独立部署：拿到数据后，负责渲染后端的数据</p></li></ul><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。</p><p><strong>JS对象和JSON的格式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;; <span class="comment">//这是一个对象，注意键名也是可以使用引号包裹的</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>; <span class="comment">//这是一个 JSON 字符串，本质是一个字符串</span></span><br></pre></td></tr></table></figure><ul><li>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</li><li>任何JavaScript 支持的类型都可以很简单的通过 JSON 来表示，转换十分方便</li></ul><p><strong>JS对象和JSON的转换</strong></p><ul><li>JSON字符串转JavaScript 对象，使用 JSON.parse() 方法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript 对象转JSON字符串，使用 JSON.stringify() 方法：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-Controller类返回JSON对象"><a href="#3-2-Controller类返回JSON对象" class="headerlink" title="3.2 Controller类返回JSON对象"></a>3.2 Controller类返回JSON对象</h2><p>JSON一般存键值对比如复杂对象，所以建一个User实体类表示对象。然后还需要用到一个新注解<code>@ResponseBody</code>和一个新的对象<code>ObjectMapper </code>，并且一般要防止乱码问题（工具类？）。</p><p>可以使用的解析工具有Jackson、fastjson（阿里）等。这里使用Jackson。需要先导入Jackson的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>操作步骤如下所示</p><blockquote><p>1 搭建基础环境：导入依赖、 配置web.xml，配置springmvc-servlet.xml</p><p>2 建一个实体类 User （这里用lombok依赖会很方便），编写我们的测试Controller</p><p>3 springmvc的配置指定StringHttpMessageConverter转换配置,防止JSON乱码</p><p>4 启动Tomcat 测试</p></blockquote><ul><li>2建实体类User，编写我们的 JSONController</li></ul><p>先引入lombok依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span>  String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 JsonController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/json/j1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">json01</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        User user01 = <span class="keyword">new</span> User(<span class="string">&quot;风清扬&quot;</span>, <span class="number">18</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">        String sJson = mapper.writeValueAsString(user01);</span><br><span class="line">        <span class="keyword">return</span> sJson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3 springmvc-servlet.xml配置文件中指定StringHttpMessageConverter转换配置,防止JSON乱码</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--json乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置Tomcat 启动，未引入过滤器和引入过滤器的结果对比：</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210534.png" alt="image-20210618124745112" style="zoom:80%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210536.png" alt="image-20210618125450048" style="zoom:80%;"><p><strong>同样的，我们增加一个方法，测试将集合对象转换为JSON:</strong></p><blockquote><p>1 添加json02()方法</p><p>2 启动Tomcat测试</p></blockquote><ul><li> 添加json02()方法，转换对象为List集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json/j2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">json02</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="comment">//构造list对象集合</span></span><br><span class="line">    User user01 = <span class="keyword">new</span> User(<span class="string">&quot;风清扬1&quot;</span>, <span class="number">18</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">    User user02 = <span class="keyword">new</span> User(<span class="string">&quot;风清扬2&quot;</span>, <span class="number">19</span>, <span class="string">&quot;woman&quot;</span>);</span><br><span class="line">    User user03 = <span class="keyword">new</span> User(<span class="string">&quot;风清扬3&quot;</span>, <span class="number">20</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(user01); list.add(user02);list.add(user03);</span><br><span class="line">    <span class="comment">//将我们的list集合对象解析成为json格式</span></span><br><span class="line">    String sJson = mapper.writeValueAsString(list);</span><br><span class="line">    <span class="keyword">return</span> sJson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置Tomcat 启动，结果如下</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210539.png" alt="image-20210618130222392" style="zoom: 67%;"><p><strong>总结：</strong></p><ul><li><p>引入Jackson的依赖，使用Jackson包对转换JSON数据格式的支持</p></li><li><p>springmvc-servlet.xml配置文件中指定StringHttpMessageConverter转换配置,防止JSON乱码</p></li><li><p><code>ObjectMapper()</code>对象的<code>writeValueAsString()</code>方法可以用来将java对象转换为JSON字符串</p></li><li><p><code>@ResponseBody</code>注解会将String转成json格式返回；所以我们直接return一个字符串即可，十分方便</p></li><li><p><code>@RestController</code> = <code>@ResponseBody</code> +  <code>@Controller</code></p></li></ul><h2 id="3-3-输出时间对象"><a href="#3-3-输出时间对象" class="headerlink" title="3.3 输出时间对象"></a>3.3 输出时间对象</h2><p>这里就先不看了，思路就是写工具类，直接调用。</p><h1 id="4-整合SSM"><a href="#4-整合SSM" class="headerlink" title="4 整合SSM"></a>4 整合SSM</h1><p>终于到了结束SSM框架的时刻了，从1月份就开始想整框架、结果一直到6月底才搞完这最基础的框架、前路漫漫啊！整合SSM需要的基本知识</p><ul><li>MySQL数据库基本操作、建表，增删改查</li><li>Mybatis的使用，mybatis的配置实现接口，用来写sql语句</li><li>Spring的使用，利用Spring容器来创建和管理对象</li><li>SpringMVC的使用，利用注解传参、获取界面、渲染界面</li><li>简单的前端知识JavaScript，html， ccs</li></ul><p>整体流程如下：</p><ul><li><strong>基本框架的搭建</strong></li></ul><p>1、数据库建表，创建一个存放书籍数据的数据库表</p><p>2、创建maven项目，添加web支持，导入相关的依赖pom.xml，并设置资源过滤<code>&lt;build&gt;</code></p><p>3、建各层的包pojo实体类、dao持久层、service业务层、controller控制层</p><p>4、resource下建mybatis的配置文件mybatis-config.xml，，spring的配置文件applicationContext.xml</p><ul><li><strong>mybatis框架部分的编写</strong></li></ul><p>1、数据库配置文件 database.properties（其实也可以直接写在mybatis-config.xml里面）</p><p>2、IDEA关联数据库开启</p><p>3、编写MyBatis的核心配置文件mybatis-config.xml：</p><p>​        <!--仅配置别名即可+注册实现接口的XXmapper.xml--></p><p>4、编写实体类com.kuang.pojo.Books</p><p>5、编写Dao层的XXMapper接口，里面是各种增删改查的抽象方法</p><p>==6、编写接口对应的 XXMapper.xml 文件。(需要导入MyBatis的包namespace为接口类)==</p><p>7、编写Service层的接口XXService和实现类XXServiceImpl，实现类需要用set方法注入XXMapper</p><p>​        <!--本来单用mybatis是不需要写实现类的，但是为了使用spring管理，需要写实现类--></p><ul><li><strong>Spring框架部分的编写</strong></li></ul><p>1、编写Spring整合Mybatis的相关的配置文件： spring-dao.xml，dao.xml中绑定mybatis-config.xml</p><!--spring-dao.xml负责了原先mybatis负责的数据库连接，还要配置sqlSessionFActory对象，但基本都是写死的，最后需要导入到真正的spring配置文件中去--><p>2、Spring整合service层,写一个spring-service.xml的配置文件：即将Service注入为bean，注入连接池、配置事务管理器等</p><ul><li>SpringMVC框架部分的编写</li></ul><p>1、编写web应用的配置文件web.xml，里面加载spring的总配置文件，设置乱码过滤器等</p><p>2、编写springMVC的配置文件spring-mvc.xml：开启注解支持、设置视图解析器等</p><p>3、sping真正的配置文件applicationContext.xml，import导入其他的配置文件</p><ul><li><strong>配置搞定之后，编写Controller和视图层jsp</strong></li></ul><p>1、一个BookController类，下面有：查询全部书籍、添加书籍、修改书籍、删除书籍四个方法</p><p>2、对应的需要写：书籍列表页面 allbook.jsp、添加书籍页面addBook.jsp、修改书籍页面 updateBook.jsp、还有主页index.jsp页面</p><ul><li><strong>最后配置Tomcat，进行运行！</strong></li></ul><h1 id="5-Ajax"><a href="#5-Ajax" class="headerlink" title="5 Ajax"></a>5 Ajax</h1><h1 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6 拦截器"></a>6 拦截器</h1><h1 id="7-文件上传下载"><a href="#7-文件上传下载" class="headerlink" title="7 文件上传下载"></a>7 文件上传下载</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神SpringMVC教学视频学习笔记，包括回顾JavaWeb、SpringMVC原理、RestFul风格、JSON、整合SSM等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="SpringMVC" scheme="https://wukang555.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/10/%E6%A1%86%E6%9E%B6_03_Spring_wukang/"/>
    <id>https://wukang555.github.io/2021/06/10/%E6%A1%86%E6%9E%B6_03_Spring_wukang/</id>
    <published>2021-06-10T14:55:00.000Z</published>
    <updated>2022-05-17T11:51:03.707Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Spring教学视频学习笔记，包括IOC、依赖注入、自动装配、代理模式、AOP、整合Mybatiis等内容</p><a id="more"></a><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h2><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>@Autowired注解：自动装配</p><ul><li>默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</li><li>如果不能唯一自动装备属性，用<code>@Qualifier(value = &quot;xxx&quot;)</code>配合使用，指定一个唯一的bean注入使用。</li></ul><p>@Resource 注解：自动装配</p><ul><li>默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错。</li><li>@Resource(name = “xx”)    或者    @Resource</li></ul><p>设置作用域的注解：</p><ul><li><p>@Scope(“singleton”) //表示单例模式的注解</p></li><li><p>@Scope(“prototype”) //表示原型模式的注解</p></li></ul><p>几种声明实体类被Spring管理成为bean对象的注解：</p><ul><li>@Component //pojo层</li><li>@Service //dao层</li><li>@Service  //service层</li><li>@Controller  //contriller层</li></ul><p>重点 4 5 6，后面springboot全注解开发，动态代理、AOP</p><h2 id="1、Spring简介"><a href="#1、Spring简介" class="headerlink" title="1、Spring简介"></a>1、Spring简介</h2><h3 id="1-1-Spring概述"><a href="#1-1-Spring概述" class="headerlink" title="1.1 Spring概述"></a>1.1 Spring概述</h3><p><strong>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。</strong>如下优点：</p><ul><li>Spring是一个开源免费的框架 , 容器 . </li><li>Spring是一个轻量级的框架 , 非侵入式的 . </li><li>控制反转 IoC , 面向切面 Aop</li><li>对事物的支持 , 对框架的支持</li></ul><h3 id="1-2-Spring的组成"><a href="#1-2-Spring的组成" class="headerlink" title="1.2 Spring的组成"></a>1.2 Spring的组成</h3><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器 定义了创建、配置和管理 bean 的方式 ：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210132.png" alt="这里写图片描述"></p><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模 块的功能如下：</p><ul><li><p>*<em>核心容器(Spring Core)**：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用</em>控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开*。</p></li><li><p>*<em>Spring 上下文(Spring Context)**：Spring 上下文是一个</em>配置文件*，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务、EJB(企业Java Bean)、电子邮件、国际化、校验和调度功能。</p></li><li><p>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</p></li><li><p>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写 的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p></li><li><p>Spring ORM：Spring 框架插入了若干个 ORM 框架（对象关系映射），从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。</p></li><li><p>Spring Web 模块：Web 上下文模块 建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p></li><li><p>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP。</p></li></ul><h3 id="1-3-Spring的配置和官方文档"><a href="#1-3-Spring的配置和官方文档" class="headerlink" title="1.3 Spring的配置和官方文档"></a>1.3 Spring的配置和官方文档</h3><p>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-JDBC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>官方文档：</p><p>官网 : <a href="http://spring.io/">http://spring.io/</a> </p><p>官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p><p>GitHub : <a href="https://github.com/spring-projects">https://github.com/spring-projects</a></p><p>几个重点的内容：IOC的原理和创建对象方式、依赖注入、代理模式、AOP、整合Mybatis</p><p>以前学的javaWeb又不懂了、Dao接口、实现类、Service接口、实现类、myTest主程序….</p><h2 id="2、IOC-控制翻转"><a href="#2、IOC-控制翻转" class="headerlink" title="2、IOC 控制翻转"></a>2、IOC 控制翻转</h2><h3 id="2-1-将对象的创建交给程序而不是程序员"><a href="#2-1-将对象的创建交给程序而不是程序员" class="headerlink" title="2.1 将对象的创建交给程序而不是程序员"></a>2.1 将对象的创建交给程序而不是程序员</h3><p>JavaWeb应用的MVC的三层架构如下图所示，控制层Controller调用模型层的一个Service业务，再由然后业务层调用dao层，获取数据。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210138.png" alt="1598260645899-65a9720b-653c-4425-a6ff-a73fb58f7aa7"></p><h4 id="由Service层决定对象的创建"><a href="#由Service层决定对象的创建" class="headerlink" title="由Service层决定对象的创建"></a><strong>由Service层决定对象的创建</strong></h4><ol><li>先写一个UserDao接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>再去写Dao的实现类（这里有三个具体的实现类）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认获取用户的数据!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMysqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql 获取用户数据 ！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle 获取用户数据！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后去写UserService的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>最后写Service的实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最原始的写法，你想用那个dao的实现类你就new哪一个出来</span></span><br><span class="line">    <span class="comment">//如果需要调用别的实现类，必须修改这里的代码</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>测试一下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试类，就是直接调用service业务层，然后业务层调用dao层</span></span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，因为<strong>Service层的实现类</strong>调用Dao层创建的对象的实现是<code>new UserDaoImpl();</code>，所以将打印实现类1的输出语句：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210143.png" alt="image-20210605193330964"></p><p>如果此时<strong>换了一种Dao层的实现类</strong>，比如用实现类2或实现类3，就必须修改<strong>Service层的实现类</strong>中创建对象的方法<code>UserDao userDao = new UserDaoMysqlImpl();</code>,相应得到的输出语句为：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210145.png" alt="image-20210605193804581"></p><p>每一次业务需求发生变化、都需要程序员修改创建对象的代码，如果这个对象使用了很多次，那么每个地方都要修改，可维护性很差。</p><h4 id="在测试类中决定对象的创建"><a href="#在测试类中决定对象的创建" class="headerlink" title="在测试类中决定对象的创建"></a><strong>在测试类中决定对象的创建</strong></h4><p>修改Service实现类的代码，只写一个传递userDao类的set方法，而不具体的创建userDao对象</p><ol start="4"><li>增加一个set方法，用来传递到底要实现哪个具体的dao层实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只写一个传递userDao类的set方法，而不具体的创建userDao对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>重新写一个测试方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl2 userService = <span class="keyword">new</span> UserServiceImpl2();</span><br><span class="line">        <span class="comment">//再测试类中再创建具体的dao实现类...感觉还是有点耦合</span></span><br><span class="line">        userService.setUserDao(<span class="keyword">new</span> UserDaoImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的理解是：<strong>将本来要在service层决定创建哪个dao实现类对象的<code>new UserDaoImpl();</code>语句，搬到了测试方法中，在测试方法中你想用哪个实现类，你就new哪个实现类就好了，不必因为需求的变化而修改Service的实现类。</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210149.png" alt="image-20210605201235338" style="zoom: 67%;"><p>现在控制对象创建的是用户（测试类需要什么就是用户需求），而之前控制对象创建的是Service层（也就是程序员负责的代码。小狂神说这就是IOC的原型， 让程序员不再去管理对象的创建了 , 更多的去关注业务的实现。</p><h3 id="2-2-IOC本质"><a href="#2-2-IOC本质" class="headerlink" title="2.2 IOC本质"></a>2.2 IOC本质</h3><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法</strong>。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系 完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方.</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式</strong>。在Spring中<strong>实现控制反转的是IoC容器</strong>，其<strong>实现方法是依赖注入</strong>（Dependency Injection,DI）。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为 一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210156.png" alt="image-20210605201935443" style="zoom: 50%;"><h3 id="2-3-第一个Spring程序"><a href="#2-3-第一个Spring程序" class="headerlink" title="2.3 第一个Spring程序"></a>2.3 第一个Spring程序</h3><p>IOC控制反转说白了就是将对象的创建和管理交给<strong>”别人“</strong>而不是对象本身，这个别人是谁呢？就是Spring，，<strong>使用Spring来创建的对象，都称为Bean</strong></p><ol><li>新建一个maven子项目，在Java下新建com.kuang.pojo包和Hello实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;str=&#x27;&quot;</span> + str + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>这里采用xml配置文件的方式编写我们的spring文件 , 这里命名为beans.xml</p><ul><li>创建对象的语句变成了一对<code>&lt;bean&gt; &lt;/bean&gt;</code>的标签</li></ul><blockquote><!--使用Spring来创建对象，在Spring中这些对象都称为Bean类型 变量名  = new 类型();Hello hello = new Hello();id = 变量名class = new 的对象（类的包名+类名）；property 相当于给对象中的属性设置一个值！--><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello_1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;setTheValueOfhello_1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--使用Spring来创建对象，在Spring这些都称为Bean</span></span><br><span class="line"><span class="comment">        类型 变量名  = new 类型();</span></span><br><span class="line"><span class="comment">        Hello hello = new Hello();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        id = 变量名</span></span><br><span class="line"><span class="comment">        class = new 的对象；</span></span><br><span class="line"><span class="comment">        property 相当于给对象中的属性设置一个值！</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello_1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;setTheValueOfhello_1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>我们可以去进行测试了 .</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取Spring的上下文对象！</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//我们的对象现在都在Spring中的管理了，我们要使用，直接去里面取出来就可以！</span></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">&quot;hello_1&quot;</span>); <span class="comment">//&quot;hello_1&quot;是bean标签中的id</span></span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210204.png" alt="image-20210606143240258" style="zoom:80%;"><p><strong>思考</strong></p><ul><li><p>Hello 对象是谁创建的 ? 【 hello 对象是由Spring创建的 】</p></li><li><p>Hello 对象的属性是怎么设置的 ? 【hello 对象的属性是由Spring容器设置的 】 </p></li></ul><p>这个过程就叫控制反转 :</p><ul><li><p>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是 由Spring来创建的 </p></li><li><p>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</p></li></ul><p>依赖注入 : 就是利用set方法来进行注入的. </p><p>IOC是一种编程思想，由主动的编程变成被动的接收</p><p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 ：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210210.png" alt="image.png" style="zoom:80%;"><h3 id="2-4-用Spring的方式改写第一个UserDao的例子"><a href="#2-4-用Spring的方式改写第一个UserDao的例子" class="headerlink" title="2.4 用Spring的方式改写第一个UserDao的例子"></a>2.4 用Spring的方式改写第一个UserDao的例子</h3><p>步骤同样是如下：</p><ul><li><p>先写一个UserDao接口</p></li><li><p>再去写Dao的实现类（这里有三个具体的实现类）</p></li><li><p>然后去写UserService的接口</p></li><li><p>再写Service的实现类，需要增加一个set方法，用来传递到底要实现哪个dao层实现类</p></li><li><p>写bean.xml配置文件，负责对象的创建</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--使用Spring来创建dao层实现类的对象，三个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoMysqlImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoMysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoOracleImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--    默认方式  想调哪个就改或者增加几行配置文件就好了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl_wk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    Mysql方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceMysqlImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoMysqlImpl_wk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    Oracle方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceOracleImpl_wk&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoOracleImpl_wk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>写测试类，想调哪个直接再<code>getBean()</code>方法的参数中输入再bean.xml中的参数id就好了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ApplicationContext；拿到Spring的容器</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//容器在手，天下我有，需要什么，就直接get什么！</span></span><br><span class="line">        <span class="comment">//UserServiceImpl2 userServiceImpl = (UserServiceImpl2) context.getBean(&quot;ServiceImpl_wk&quot;);</span></span><br><span class="line">        UserServiceImpl2 userServiceImpl = (UserServiceImpl2) context.getBean(<span class="string">&quot;ServiceMysqlImpl_wk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userServiceImpl.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p><h3 id="2-5-IOC-创建对象的三种方式"><a href="#2-5-IOC-创建对象的三种方式" class="headerlink" title="2.5 IOC 创建对象的三种方式"></a>2.5 IOC 创建对象的三种方式</h3><p>实体类中，含有构造函数时，beans.xml 有三种方式编写来创建对象</p><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...等get set show方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式一：直接通过参数名（与类中的参数保持一致）来设置，多个参数写多个constructor</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第1种，直接通过参数名来设置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;秦疆1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：根据index参数下标设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第2种根据index参数下标设置 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式三：根据参数类型设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第3种根据参数类型设置 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</strong></p><h3 id="2-6-Spring-配置"><a href="#2-6-Spring-配置" class="headerlink" title="2.6 Spring 配置"></a>2.6 Spring 配置</h3><h4 id="1-别名-alias"><a href="#1-别名-alias" class="headerlink" title="1. 别名 alias"></a>1. 别名 alias</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"> //User user = (User) context.getBean(&quot;userNew&quot;);</span><br></pre></td></tr></table></figure><h4 id="2-bean的配置"><a href="#2-bean的配置" class="headerlink" title="2. bean的配置"></a>2. bean的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id： bean 的唯一标识符，也就相当于对象名</span></span><br><span class="line"><span class="comment">    class： bean 对象所对应的全限定名： 包名 + 类型</span></span><br><span class="line"><span class="comment">    name: 也就是起别名 而且name可以取多个别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;edu.cqupt.pojo.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2，u2,u3,u4&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shilin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> //User user = (User) context.getBean(&quot;user2&quot;);</span><br></pre></td></tr></table></figure><h4 id="3-import"><a href="#3-import" class="headerlink" title="3. import"></a>3. import</h4><p>import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans2.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans3.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、依赖注入"><a href="#3、依赖注入" class="headerlink" title="3、依赖注入"></a>3、依赖注入</h2><ul><li><p>依赖注入：通俗来讲就是对象的创建和初始化（赋值）</p></li><li><ul><li>依赖：bean对象的创建依赖于容器！</li><li>注入：bean对象的所有属性，有容器来注入！</li></ul></li></ul><h3 id="3-1-构造器注入"><a href="#3-1-构造器注入" class="headerlink" title="3.1 构造器注入"></a>3.1 构造器注入</h3><p>2.5节已经说了有参构造方法创建对象的三种方式 <code>constructor-arg</code></p><h3 id="3-2-Set方式注入【重点】"><a href="#3-2-Set方式注入【重点】" class="headerlink" title="3.2 Set方式注入【重点】"></a>3.2 Set方式注入【重点】</h3><p>环境搭建</p><ul><li>复杂类型 Addresss</li><li>真实测试对象 Student<ul><li><strong>需要写set方法！！</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Addresss addresss;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    ...gets/sets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Addresss</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ...gets/sets</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、常量注入 value</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 1、常量注入  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;法外狂徒张三&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、Bean注入： ref 注入bean中已经创建好的对象：addr</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;长沙&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2、Bean注入： ref 注入bean中已经创建好的对象：addr--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、数组注入： array</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数组注入： array--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>Java 程序设计<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>Python 从入门到精通<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>MYSQL 必知必会<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4、List 注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List 注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>编程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>听音乐<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电影<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5、Map 注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map 注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;学生卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234567&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123453232367&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3332434343434343&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6、Set 注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Set 注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>王者荣耀<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>7、Null 注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Null 注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>8、properties 注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--properties 注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;driver&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/mydb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        Student student1 = (Student) context.getBean(<span class="string">&quot;student_1&quot;</span>);</span><br><span class="line">        System.out.println(student1.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210226.png" alt="image-20210606162959183"></p><h3 id="3-3-拓展方式注入"><a href="#3-3-拓展方式注入" class="headerlink" title="3.3 拓展方式注入"></a>3.3 拓展方式注入</h3><p>先不看了….</p><h3 id="3-4-Bean-的作用域"><a href="#3-4-Bean-的作用域" class="headerlink" title="3.4 Bean 的作用域"></a>3.4 Bean 的作用域</h3><h4 id="bean-的作用域分类"><a href="#bean-的作用域分类" class="headerlink" title="bean 的作用域分类"></a>bean 的作用域分类</h4><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一</li></ul><h4 id="singleton-默认–单例模式）"><a href="#singleton-默认–单例模式）" class="headerlink" title="singleton (默认–单例模式）"></a><strong>singleton (默认–单例模式）</strong></h4><p>只有一个单例 bean 的共享实例被管理，并且所有对带有一个或多个 ID 与该 bean 定义匹配的 bean 的请求都会导致 Spring 容器返回一个特定的 bean 实例。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210234.png" alt="单身人士"></p><p>测试一下,发现<code>getBean(&quot;user1&quot;)</code>永远创建的是用一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    &lt;bean id =&quot;user1&quot; class=&quot;com.kuang.pojo.User &quot;&gt;</span></span><br><span class="line"><span class="comment">//        &lt;property name=&quot;name&quot; value=&quot;wukang&quot;/&gt;</span></span><br><span class="line"><span class="comment">//        &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;</span></span><br><span class="line"><span class="comment">//    &lt;/bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        User user1 = (User) context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        User user2 = (User) context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(user1.toString());</span><br><span class="line">        System.out.println(user2.toString());</span><br><span class="line">        System.out.println(user1.hashCode());</span><br><span class="line">        System.out.println(user2.hashCode());</span><br><span class="line">        System.out.println(user1==user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210239.png" alt="image-20210608170924060" style="zoom:67%;"><h4 id="prototypeton-原型模式）"><a href="#prototypeton-原型模式）" class="headerlink" title="prototypeton (原型模式）"></a><strong>prototypeton (原型模式）</strong></h4><p>每次从容器中get的时候，都会产生一个对象</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210242.png" alt="原型"></p><p>首先在配置文件的<code>&lt;bean&gt;</code>标签中，设置<code>scope=&quot;prototype&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> =<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User &quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wukang&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试一下,发现<code>getBean(&quot;user1&quot;)</code>创建的是不同的对象</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210246.png" alt="image-20210608171358323" style="zoom:67%;"><h2 id="4、自动装备和使用注解开发"><a href="#4、自动装备和使用注解开发" class="headerlink" title="4、自动装备和使用注解开发"></a>4、自动装备和使用注解开发</h2><h3 id="4-1-Bean-的自动装配"><a href="#4-1-Bean-的自动装配" class="headerlink" title="4.1 Bean 的自动装配"></a>4.1 Bean 的自动装配</h3><p><strong>在Spring中有三种装配的方式：</strong></p><ul><li>在xml中显式的装配（上面都是用的这种实现）</li><li>在java中显式的配置</li><li><strong>隐式的自动装配bean</strong>（很重要）：在配置文件的<code>&lt;bean&gt;</code>标签中，设置<code>autowire=&quot;&quot;</code>属性<ul><li>ByName 自动装配</li><li>ByType 自动装配</li></ul></li></ul><h4 id="1-Bean-自动装配的示例"><a href="#1-Bean-自动装配的示例" class="headerlink" title="1 Bean 自动装配的示例"></a>1 Bean 自动装配的示例</h4><p><strong>Bean 的自动装配指Spring会在上下文中自动寻找，并自动给bean装备属性。</strong>，用大白话来说就是：原本给一个复杂的对象赋值属性的时候，如果要调用已经存在的对象的话需要每个都写一个<code>&lt;property&gt;</code>标签来赋值。。如果采用自动装备的话则可以省略这些已有对象的调用。对比如下：</p><p>1、自己创建一个复杂对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.dog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.cat&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shi-lin&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自己创建的话、要手动写这两行代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、自动装备创建一个复杂对象1（这里采用<code>autowire=&quot;byName&quot;</code>的方式）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.dog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.cat&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shi-lin&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动装配 dog 和 cat  这里只能用dog和cat--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、自动装备创建一个复杂对象2（这里采用<code>autowire=&quot;byType&quot;</code>的方式）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.dog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.cat&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;edu.cqupt.pojo.People&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shi-lin&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动装配 dog1 和 cat1,  这里名字随便取、但是dog和cat类的对象需要唯一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-ByName-和-ByType-的区别："><a href="#2-ByName-和-ByType-的区别：" class="headerlink" title="2 ByName 和 ByType 的区别："></a>2 ByName 和 ByType 的区别：</h4><ul><li>byNmae 会自动在容器上下文中查找和自己对象set方法后面的值对应的id</li><li>byName需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值唯一</li><li>byType 会自动在容器上下文中查找和自己对象属性类型相同的bean</li><li>byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</li></ul><h4 id="3-注解实现自动装配"><a href="#3-注解实现自动装配" class="headerlink" title="3 注解实现自动装配"></a>3 注解实现自动装配</h4><p>xml配置文件需要引入支持注解</p><ul><li>导入约束。 contex约束 <code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code></li><li>配置注解的支持 <code>&lt;context:annotation-config/&gt;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里介绍两个注解：**@Autowired和@Resource **</p><p>@Autowired注解：自动装配</p><ul><li>默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</li><li>如果不能唯一自动装备属性，用<code>@Qualifier(value = &quot;xxx&quot;)</code>配合使用，指定一个唯一的bean注入使用。</li></ul><p>@Resource 注解：自动装配</p><ul><li>默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错。</li><li>@Resource(name = “xx”)    或者    @Resource</li></ul><p>自动装配注解使用示例：直接在属性上加上注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;cat1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;dog1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//其他方法 get()/set()/toString()...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解后自动装配，配置文件的代码将极度简洁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.People&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-使用注解开发"><a href="#4-2-使用注解开发" class="headerlink" title="4.2 使用注解开发"></a>4.2 使用注解开发</h3><h4 id="1-一个使用注解开发的简单实例"><a href="#1-一个使用注解开发的简单实例" class="headerlink" title="1 一个使用注解开发的简单实例"></a>1 一个使用注解开发的简单实例</h4><ul><li>引入注解的支持，在xml配置文件中导入contex约束，并配置注解的支持（注意使用注解还需要导入aop的依赖包）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>以@Component和@Value()注解为例，声明实体类被Spring管理，成为了一个bean</li></ul><p>a. 普通情况，不用注解、使用xml的配置来创建和管理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    正常使用xml的创建和注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wukang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b. 使用注解的情况，在实体类的属性上加注解、然后xml配置文件将极其简洁（就是直接不用写<code>&lt;bean&gt;</code>以及里面的内容了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;wukang&quot;)</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. 解释：</p><p>@<strong>Component</strong>: 组件等价于：<code>  &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;</code></p><p><strong>@Value(“wukang”)</strong> 等价于：<code>&lt;property name=&quot;name&quot; value=&quot;wukang&quot;/&gt;</code></p><h4 id="2-介绍几种注解【重要】"><a href="#2-介绍几种注解【重要】" class="headerlink" title="2 介绍几种注解【重要】"></a>2 介绍几种注解【重要】</h4><p>几种声明实体类被Spring管理成为bean对象的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//pojo层</span></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">//dao层</span></span><br><span class="line"><span class="meta">@Service</span>  <span class="comment">//service层</span></span><br><span class="line"><span class="meta">@Controller</span>  <span class="comment">//contriller层</span></span><br></pre></td></tr></table></figure><p>作用域的注解：</p><p>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//表示单例模式的注解</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">//表示原型模式的注解</span></span><br></pre></td></tr></table></figure><p>自动装配的注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired注解：自动装配【常用】</span><br><span class="line">- 默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在</span><br><span class="line">- 如果不能唯一自动装备属性，用`@Qualifier(value = &quot;xxx&quot;)`配合使用，指定一个唯一的bean注入使用。</span><br><span class="line"></span><br><span class="line">@Resource 注解：自动装配</span><br><span class="line">- 默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错。</span><br><span class="line">- @Resource(name = &quot;xx&quot;)    或者    @Resource</span><br></pre></td></tr></table></figure><h4 id="3-使用注解开发的小结"><a href="#3-使用注解开发的小结" class="headerlink" title="3 使用注解开发的小结"></a>3 使用注解开发的小结</h4><ul><li><p>xml配置 与 注解 两种方式的特点：</p></li><li><ul><li><p><strong>xml</strong>：更加万能，适用于任何场合、维护简单方便</p></li><li><p><strong>注解</strong>： 不是自己的类，使用不了，维护相对复杂</p></li></ul></li><li><p>两种方式的最佳实践</p></li><li><ul><li><p>xml用来管理Bean</p></li><li><p>注解只用于属性注入</p></li><li><p>在使用的过程中，<strong>只需要注意一个问题，必须让注解生效，开启注解支持</strong></p></li></ul></li></ul><h3 id="4-3-JavaConfig实现配置"><a href="#4-3-JavaConfig实现配置" class="headerlink" title="4.3 JavaConfig实现配置"></a>4.3 JavaConfig实现配置</h3><p>事实上也可以直接不用建bean.xml的配置文件，用一些纯java的类完全代替之….【现阶段了解、springboot中用的会比较多】</p><p>1 首先给实体类加上注解，使用注解开发的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 说明这个类被Spring接管了，注册到了容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Value(&quot;wukang&quot;)</span>   <span class="comment">// 属性注入值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写一个java类，带上<code>@Configuration</code>表明是配置类，然后类中的每一个方法加上<code>@Bean</code>注解，表明是一条bean的配置语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Configuration代表这就是一个配置类，集合我们beans.xml一样</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 注册一个bean，就相当于之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">// 这个方法的名字就相当于bean标签中的id属性，方法的返回值就相当bean标签的class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(); <span class="comment">//就是返回要注入到bean的对象！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、写测试类，用<code>AnnotationConfigApplicationContext</code>来new一个<code>ApplicationContext</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config1.class);</span><br><span class="line">        User userWuKang = (User) context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(userWuKang.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210300.png" alt="image-20210609153727171" style="zoom:67%;"><p>这里再介绍几个配套的注解</p><ul><li>@ComponentScan(“com.kuang.pojo”) //扫描类，加上之后可以直接点击跳转</li><li>@Import(Config2.class)   //可以整合多个配置类的java文件，，相当于合并多个bean.xml文件一样</li></ul><h2 id="5、代理模式"><a href="#5、代理模式" class="headerlink" title="5、代理模式"></a>5、代理模式</h2><h3 id="5-1-静态代理"><a href="#5-1-静态代理" class="headerlink" title="5.1 静态代理"></a>5.1 静态代理</h3><p>我觉得讲的我听不太懂、简单做亿点笔记，后面自己去看书。</p><p><strong>几个组成部分（以出租房子为例）</strong></p><ul><li><p>抽象角色： 一般会使用一个接口或者抽象类来实现（比如出租房子这件事）</p></li><li><p>真实角色：被代理的角色（这里指房东实现出租房子的接口）</p></li><li><p>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作（这里指中介、帮房东出租房子，也要实现出租房子的接口、但有自己的一些其他方法）</p></li><li><p>客户：访问代理对象的人 （这里表示要租房子的人）</p></li></ul><p><strong>静态代理模式的好处：</strong></p><ul><li><p>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</p></li><li><p>公共业务交给代理角色去实现，实现业务的分工</p></li><li><p>公共业务发生扩展时，方便集中管理</p></li></ul><p><strong>静态代理模式的缺点：</strong></p><ul><li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低。</li></ul><p>以一个AOP插入log功能的示例演示一下：</p><ul><li><p>代码</p></li><li><p><strong>UserService</strong>  抽象角色</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>UserServiceImpl</strong> 真实角色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**UserServiceProxy ** 代理角色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[DEBUG]:使用了&quot;</span> + msg + <span class="string">&quot;方法.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**Client **客户</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">       UserServiceProxy proxy = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">       proxy.setUserService(userService );</span><br><span class="line">       proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>聊聊AOP</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210306.png" alt="image.png" style="zoom:67%;"><h3 id="5-2-动态代理"><a href="#5-2-动态代理" class="headerlink" title="5.2 动态代理"></a>5.2 动态代理</h3><p>==<strong>最大的区别：动态代理的代理类是动态生成的，不是我们直接写好的  (具体是怎样?）</strong>==</p><ul><li><p>角色分析： 和静态代理角色一样</p></li><li><p>动态代理的代理类是动态生成的，不是我们直接写好的  (具体是怎样?）</p></li><li><p>动态代理分类：<strong>基于接口的动态代理、基于类的动态代理</strong></p></li><li><ul><li><strong>基于接口 — JDK 动态代理</strong>【我们用这个】</li><li><strong>基于类  — cglib\java 字节码实现【javasist】</strong></li></ul></li></ul><p>需要了解两个类【重要！！】</p><ul><li>Proxy： new出代理</li><li>InvocationHandler： 调用处理程序生成代理</li></ul><p>还是以为业务层增加log日志提示的例子为例，代码如下：</p><blockquote><p>1首先编写我们的业务接口和实现类和之前一样。</p><p>2 之前使用静态代理就要 “写死” 一个代理类<strong>UserServiceProxy **，里面的方法固定、增加的功能无法改变。</strong>使用动态代理的话、不必程序员写这个代理类了、而是自动生成代理类！！**</p><p>3最后测试：**Client **客户请求服务、代理对象提供服务</p></blockquote><ul><li><p><strong>UserService</strong>  抽象角色：还是一样一个接口，里面四个方法</p></li><li><p><strong>UserServiceImpl</strong> 真实角色：还是一样，实现四个方法</p></li><li><p>一个用来自动生成代理类的<strong>ProxhyInvocationHandler</strong>类、下面这个通用、基本算是工具类</p><ul><li>里面的getProxy()、invoke()方法基本都是写死的，</li><li>如果要代理多个方法用Object对象，如果只有一个方法就用对于的接口类就好了</li><li>添加的新功能直接写成实例方法、然后在invoke()方法里面调用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等会我们用这个类，自动生成代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInVocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;<span class="comment">// 生成得到代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态代理的本质，就是使用反射机制实现</span></span><br><span class="line">    <span class="comment">// 处理代理实例，并返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        log(method.getName());<span class="comment">//添加的新功能</span></span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给代理添加功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Debug]:执行了&quot;</span> + msg + <span class="string">&quot;方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**Client **客户请求服务、代理对象提供服务<ul><li>最关键的就是这个自动生成代理类对象、然后就可以调用真实被代理对象的方法了</li><li>UserService proxy = (UserService) pih.getProxy();     // 动态生成代理类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.cqupt.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真实角色</span></span><br><span class="line">        UserServiceImpl userService  = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        UserServiceImplTwo userServiceTwo  = <span class="keyword">new</span> UserServiceImplTwo();</span><br><span class="line">        <span class="comment">// 代理角色</span></span><br><span class="line">        ProxyInVocationHandler pih = <span class="keyword">new</span> ProxyInVocationHandler();</span><br><span class="line">        pih.setTarget(userService);<span class="comment">// 设置要代理对象</span></span><br><span class="line">        <span class="comment">//pih.setTarget(userServiceTwo);</span></span><br><span class="line">        UserService proxy = (UserService) pih.getProxy();     <span class="comment">// 动态生成代理类</span></span><br><span class="line">        proxy.add();</span><br><span class="line">        proxy.delete();</span><br><span class="line">        proxy.update();</span><br><span class="line">        proxy.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a>6、AOP</h2><p>AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间<strong>动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210325.png" alt="image.png"></p><h3 id="AOP-在Spring中的作用"><a href="#AOP-在Spring中的作用" class="headerlink" title="AOP 在Spring中的作用"></a>AOP 在Spring中的作用</h3><p><strong>提供声明式事务:允许用户自定义切面：</strong></p><ul><li><strong>横切关注点:</strong> 跨越应用程序多个模块的方法或功能.既是,与我们业务逻辑无关,但是我们需要关注的部分,就是横切关注点 .如<strong>日志,安全,缓存,事务</strong>等…</li><li><strong>切面（ASPECT）：</strong>横切关注点 被模块化 的特殊对象。即，它是一个<strong>类</strong>。</li><li><strong>通知（Advice）：</strong>切面必须要完成的工作。即，它</li><li>是类中的一个<strong>方法</strong>。</li><li><strong>目标（Target）：</strong>被通知对象。</li><li><strong>代理（Proxy）：</strong>向目标对象应用通知之后创建的对象。</li><li><strong>切入点（PointCut）：</strong>切面通知 执行的 “地点”的定义。</li><li><strong>连接点（JointPoint）：</strong>与切入点匹配的执行点。</li></ul>   <img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210330.png" alt="image.png" style="zoom:67%;"><p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p><p>​             <img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210333.png" alt="image.png" style="zoom:67%;"></p><h3 id="使用Spring-实现AOP"><a href="#使用Spring-实现AOP" class="headerlink" title="使用Spring 实现AOP"></a>使用Spring 实现AOP</h3><p>Aop 在 不改变原有代码的情况下 , 去增加新的功能。其实动态代理就可以实现AOP不改变代码增加新功能的需求、、但是Spring内部定义了一下三种实现AOP的三种方式</p><ul><li>方式一： 使用Spring的API接口</li><li>方式二： 使用自定义类实现AOP </li><li>方式三： 使用注解实现</li></ul><p><strong>使用Spring实现AOP织入，需要导入一个依赖包！</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-使用API接口实现AOP"><a href="#1-使用API接口实现AOP" class="headerlink" title="1 使用API接口实现AOP"></a>1 使用API接口实现AOP</h3><blockquote><p>1 首先编写我们的业务接口和实现类和之前一样。</p><p>2 添加新的功能，两个增强类，一个前置增强类Log实现MethodBeforeAdvice接口，一个后置增强类AfterLog实现AfterReturningAdvice接口</p><p>3 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p><p>4 测试</p></blockquote><ul><li><strong>UserService</strong>  抽象角色</li><li><strong>UserServiceImpl</strong> 真实角色</li><li>前置增强类Log实现MethodBeforeAdvice接口，重写before方法、添加新功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123; </span><br><span class="line">    <span class="comment">//method : 要执行的目标对象的方法 </span></span><br><span class="line">    <span class="comment">//objects : 被调用的方法的参数 </span></span><br><span class="line">    <span class="comment">//Object : 目标对象 </span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        System.out.println( o.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法被执行了&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置增强类AfterLog实现AfterReturningAdvice接口，重写afterReturning方法、添加新功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123; </span><br><span class="line">    <span class="comment">//returnValue 返回值 </span></span><br><span class="line">    <span class="comment">//method被调用的方法 </span></span><br><span class="line">    <span class="comment">//args 被调用的方法的对象的参数 </span></span><br><span class="line">    <span class="comment">//target 被调用的目标对象 </span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span> + target.getClass().getName()</span><br><span class="line">             +<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法,&quot;</span> +<span class="string">&quot;返回值：&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>spring的xml文件中注册 , 并实现aop切入实现 , 注意导入约束 .</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>); </span><br><span class="line">        UserService userService = (UserService)context.getBean(<span class="string">&quot;userService&quot;</span>); userService.search();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . </p><p><strong>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业</strong><br><strong>务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</strong></p><h3 id="2-使用自定义类实现AOP"><a href="#2-使用自定义类实现AOP" class="headerlink" title="2 使用自定义类实现AOP"></a>2 使用自定义类实现AOP</h3><blockquote><p>1 首先编写我们的业务接口和实现类和之前一样。</p><p>2 写我们自己定义的一个切入类，要新增的功能在方法里编写</p><p>3 最后去spring的文件中配置, 并实现aop切入实现 , 注意导入约束 .</p><p>4 测试</p></blockquote><ul><li><strong>UserService</strong>  抽象角色</li><li><strong>UserServiceImpl</strong> 真实角色</li><li>写我们自己定义的一个切入类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointcut</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后去spring的文件中配置, 并实现aop切入实现</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>); </span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>); userService.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用注解实现AOP"><a href="#3-使用注解实现AOP" class="headerlink" title="3 使用注解实现AOP"></a>3 使用注解实现AOP</h3><blockquote><p>1 首先编写我们的业务接口和实现类和之前一样。</p><p>2 编写一个注解实现的增强类</p><p>3 在Spring配置文件中，注册bean，并增加支持注解的配置</p><p>4 测试</p></blockquote><ul><li><strong>UserService</strong>  抽象角色</li><li><strong>UserServiceImpl</strong> 真实角色</li><li>编写一个注解实现的增强类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.diy;</span><br><span class="line"><span class="comment">//方式三：使用注解方式实现AOP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这个类是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====方法执行前======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====方法执行后======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点；</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        Signature signature = jp.getSignature();<span class="comment">//获得签名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;signature:&quot;</span>+signature);</span><br><span class="line"></span><br><span class="line">        Object proceed = jp.proceed();   <span class="comment">//执行方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Spring配置文件中，注册bean，并增加支持注解的配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--方式三--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointCut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.diy.AnnotationPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持！   JDK(默认 proxy-target-class=&quot;false&quot;)   cglib（proxy-target-class=&quot;true&quot;）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-整合-Mybatis"><a href="#7-整合-Mybatis" class="headerlink" title="7 整合 Mybatis"></a>7 整合 Mybatis</h2><p>整合Mybatis的步骤：</p><ul><li>1 导入依赖包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">junit</span><br><span class="line">mybatis</span><br><span class="line">mysql数据库</span><br><span class="line">spring</span><br><span class="line">aspectjweaver</span><br><span class="line">mybatis-spring</span><br></pre></td></tr></table></figure><ul><li>2 编写Spring配置文件</li><li>3 测试</li></ul><h3 id="7-1-回顾Mybatis"><a href="#7-1-回顾Mybatis" class="headerlink" title="7.1 回顾Mybatis"></a>7.1 回顾Mybatis</h3><blockquote><p>1 建表、导入依赖包：</p><p>2 resources下建一个mybaits-config.xml文件，Mybatis配置文件用于连接数据库</p><p>3 pojo包下写User实体类，Dao包下写一个Dao接口</p><p>4 接口实现类由原来的UserDaoImpl转变为一个 Mapper.xml配置文件</p><p>5 测试  //获得sqlSession对象   //调用配置文件，查询sql</p></blockquote><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>resources下建一个mybatis-config.xml文件、<strong>注意注册mapper.xml</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;526736&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每一个mapper.xml都需要再mybatis核心配置文件中注册--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>pojo包下写User实体类，Dao包下写一个Dao接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lombok插件牛逼</span></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个 Mapper.xml配置文件实现UserDao接口</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获得sqlSession对象</span></span><br><span class="line">        String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//调用配置文件，查询sql</span></span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210345.png" alt="image-20210614104827180" style="zoom: 67%;"><h3 id="7-2-整合实现方式一"><a href="#7-2-整合实现方式一" class="headerlink" title="7.2 整合实现方式一"></a>7.2 整合实现方式一</h3><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。整合需要导的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。<br>在 MyBatis-Spring 中，可使用 SqlSessionFactoryBean 来创建 SqlSessionFactory 。 要配置<br>这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可 以使用它无缝代替你代码中已经在使用的 SqlSession 。可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当拥有sqlSession对象之后，就可以为所欲为了</strong>。使用方法是实现抽象接口，在实现类中添加一个 SqlSession 属性，并写一个set()方法，方便注入。就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSession sqlSession)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sqlSession.getMapper...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将你的实现类注入真正的Spring配置文件中就可以正常使用了</p><p><strong>第一种整合方式的步骤：</strong></p><p>整合的前提是有Mybatis之前的一些文件，比如业务接口UserDao、还有该接口对应用来写SQL的xml文件Mapper.xml、实例类USer、Mybatis的配置文件mybatis-config.xml可有可无（一般保留用来注册别名），在此基础上开始整合：</p><blockquote><p>1  引入Spring配置文件 spring-dao.xml 这个配置文件专门用来，代理原先Mybaits中的一些配置：比如连接数据库、产生SqlSession对象等</p><p>​    a. 配置数据源替换mybaits的数据源</p><p>​    b. 配置SqlSessionFactory，关联MyBatis</p><p>​    c. 注册sqlSessionTemplate，关联sqlSessionFactory；</p><p>2 增加Dao接口的实现类；私有化sqlSessionTemplate</p><p>​    a. 用来产生mapper对象，进而调用Dao接口的方法</p><p>3 Spring真正的配置文件<strong>applicationContext.xml</strong>  （实际spring-dao.xml和这个xml、分开写好理解）</p><p>​    a. 将上面的spring-dao.xml组合进来</p><p>​    b. 将自己写的实现类，注入到Spring中</p><p>4 测试</p></blockquote><ul><li><strong>1 spring-dao.xml配置子文件</strong>： 配置数据源、配置SqlSessionFactory、注册sqlSessionTemplate</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DataSource: 使用Spring的数据源替换mybatis的配置 c3p0 dbcp druid</span></span><br><span class="line"><span class="comment">    我们使用Spring提供的jdbc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;526736&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定Mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/kuang/dao/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionTemplate:就是我们使用的sqlSession--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2 增加Dao接口的实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在原来我们的所有操作都使用SqlSession来执行，现在都使用SqlSessionTemplate;</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3 Spring真正的配置文件<strong>applicationContext.xml</strong>  将实现类UserDaoImpl，注入到Spring中</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 组合spring-dao.xml配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将实现类UserDaoImpl，注入到Spring中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyText02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        UserDao userMapper = (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.getUserList();</span><br><span class="line">        <span class="keyword">for</span>(User user:userList)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210351.png" alt="image-20210614150945168" style="zoom:67%;"><h3 id="7-3-整合实现方式二"><a href="#7-3-整合实现方式二" class="headerlink" title="7.3 整合实现方式二"></a>7.3 整合实现方式二</h3><p>本质还是第一种整合、方式更加简洁了。</p><p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不 需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p><blockquote><p>1 重写的类UserDaoImpl修改一下 继承SqlSessionDaoSupport类</p><p>2 修改bean的配置</p><p>3 测试</p></blockquote><ul><li>Dao接口的实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl2</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDao mapper = getSqlSession().getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring真正的配置文件<strong>applicationContext.xml</strong><ul><li>还是要spring-dao.xml文件来帮忙生成sqlSessionFactory对象</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    组合spring-dao.xml配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    注册UserDaoImpl2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest03</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        UserDao userMapper = (UserDao) context.getBean(<span class="string">&quot;userDao2&quot;</span>);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.getUserList();</span><br><span class="line">        <span class="keyword">for</span>(User user:userList)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210400.png" alt="image-20210614155908205" style="zoom:67%;"><p>总结 : 整合到spring中以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还 可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！</p><h2 id="8-声明式事务"><a href="#8-声明式事务" class="headerlink" title="8 声明式事务"></a>8 声明式事务</h2><h3 id="8-1-Spring事务简述"><a href="#8-1-Spring事务简述" class="headerlink" title="8.1 Spring事务简述"></a>8.1 Spring事务简述</h3><p>事务的ACID四个属性（熟背）。Spring支持编程式事务管理和声明式的事务管理。</p><p><strong>编程式事务管理：</strong></p><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><p><strong>声明式事务管理（更好用）：</strong></p><ul><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务 管理。</li></ul><p><strong>事务管理器 transactionManager</strong></p><ul><li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li><li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li></ul><p>使用Spring管理事务，注意头文件的约束导入 : tx</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>**spring事务传播特性:**事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这 个事务中，这是最常见的选择。 <strong>（默认）</strong></li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 </li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 </li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 </li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 </li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与</li><li>propagation_required类似的操作</li></ul><p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的 调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><h3 id="8-2-声明式事务的示例"><a href="#8-2-声明式事务的示例" class="headerlink" title="8.2 声明式事务的示例"></a>8.2 声明式事务的示例</h3><p>这里从导入依赖开始、完整的以第二种方式整合一遍Mybatis，并且设置一个以AOP切入方式的声明式事务！！！很牛逼</p><blockquote><p>1 导入Maven依赖包 junit、mybatis、mysql数据库、spring、aspectjweaver、mybatis-spring</p><p>2 数据库建表（省略）、并写一个和数据库对应的实体类User</p><p>3 Mybatis部分：Mapper接口、Mapper.xml中写SQL、写Mybatis的mybatis-config.xml配置文件</p><p>​         a 写一个UserMapper接口、里面查询、增加和删除的抽象方法</p><p>​         b 对应实现该接口方法的UserMapper.xml的SQL语句</p><p>​        c mybatis-config.xml中不用注册mapper了，写个<typeAliases>别名就好了，甚至可省略</typeAliases></p><p>4  编写Spring的辅助配置文件spring-dao.xml；在配置声明式事务，并结合AOP实现事务的织入</p><p>5 编写UserMapper的实现类UserMapperImpl</p><p>6 真正的Spring配置文件 applicationContext.xml</p><p>7 测试方法</p></blockquote><ul><li>1 导入Maven依赖包</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2 建表（省略）、并写一个和数据库对应的实体类User</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3 Mybatis部分：Mapper接口、Mapper.xml中写SQL、写Mybatis的mybatis-config.xml配置文件</li></ul><p>//UserMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//添加一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from mybatis.user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>4  编写Spring的辅助配置文件spring-dao.xml；在配置声明式事务，并结合AOP实现事务的织入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置  c3p0  dbcp  druid</span></span><br><span class="line"><span class="comment">    我们这里使用Spring提供的JDBC : org.springframework.jdbc.datasource</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;526736&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--绑定Mabatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/kuang/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SqlSessionTemplate:就是我们使用的sqlSession--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置声明式事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务通知；--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给那些方法配置事务--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务的传播特性：new  propagation= --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>5 编写UserMapper的实现类UserMapperImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="comment">//这个方法里面的所有功能组成了一个事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">8</span>, <span class="string">&quot;小王&quot;</span>, <span class="string">&quot;2131231&quot;</span>);</span><br><span class="line">        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(user);</span><br><span class="line">        mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>6 真正的Spring配置文件 applicationContext.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.mapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>7 测试方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        UserMapper userMapper = context.getBean(<span class="string">&quot;userMapper&quot;</span>, UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectUser();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210409.png" alt="image-20210614202243112" style="zoom:67%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Spring教学视频学习笔记，包括IOC、依赖注入、自动装配、代理模式、AOP、整合Mybatiis等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Spring" scheme="https://wukang555.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/02/%E6%A1%86%E6%9E%B6_02_Mybatis_wukang/"/>
    <id>https://wukang555.github.io/2021/06/02/%E6%A1%86%E6%9E%B6_02_Mybatis_wukang/</id>
    <published>2021-06-02T14:55:00.000Z</published>
    <updated>2022-05-17T11:50:07.874Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Mybatis教学视频学习笔记，仅实操重要部分，面向秋招学习，知识点</p><ul><li>mybaits实现的两种方式：xml文件和注解</li><li>映射器（mappers）实现的三种方式</li><li>参数的map映射、结果集的map映射</li><li>分页、动态SQL、mybatis的两级缓存的机制</li></ul><a id="more"></a><h2 id="Mybatis-狂神笔记"><a href="#Mybatis-狂神笔记" class="headerlink" title="Mybatis_狂神笔记"></a>Mybatis_狂神笔记</h2><blockquote><p>环境：JDK11.0.6、Mysql 5.7、maven 3.3.9、IDEA</p></blockquote><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210036.png" alt="1569633932712"></p><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>它支持定制化 SQL、存储过程以及高级映射。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li><li>MyBatis 本是<a href="https://baike.baidu.com/item/apache/6265">apache</a>的一个开源项目<a href="https://baike.baidu.com/item/iBatis">iBatis</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li><li>2013年11月迁移到Github。</li></ul><p>如何获得Mybatis？</p><ul><li><p>maven仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Github ： <a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p></li><li><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：<strong>断电即失</strong></li><li>数据库(Jdbc)，io文件持久化。</li><li>生活：冷藏. 罐头。</li></ul><p><strong>为什么需要需要持久化？</strong></p><ul><li><p>有一些对象，不能让他丢掉。</p></li><li><p>内存太贵了</p></li></ul><h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p>Dao层，Service层，Controller层….</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显。</li></ul><h3 id="1-4-为什么需要Mybatis？"><a href="#1-4-为什么需要Mybatis？" class="headerlink" title="1.4 为什么需要Mybatis？"></a>1.4 为什么需要Mybatis？</h3><ul><li>帮助程序猿将数据存入到数据库中。</li><li>方便</li><li>传统的JDBC代码太复杂了。简化。框架。自动化。</li><li>不用Mybatis也可以。更容易上手。 <strong>技术没有高低之分</strong></li><li>优点：<ul><li>简单易学</li><li>灵活</li><li>sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写<strong>动态sql</strong>。（动态sql是什么意思）</li></ul></li></ul><p><strong>最重要的一点：使用的人多！</strong></p><p>Spring   SpringMVC    SpringBoot</p><h2 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h2><p>思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！</p><h3 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h3><p>搭建数据库：打开SQLyog建表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `user`(</span><br><span class="line">  `id` INT(<span class="number">20</span>) NOT NULL PRIMARY KEY,</span><br><span class="line">  `name` VARCHAR(<span class="number">30</span>) DEFAULT NULL,</span><br><span class="line">  `pwd` VARCHAR(<span class="number">30</span>) DEFAULT NULL</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `user`(`id`,`name`,`pwd`) VALUES </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;狂神&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123890&#x27;</span>)</span><br></pre></td></tr></table></figure><p>新建项目</p><ol><li><p>新建一个普通的maven项目（父项目）</p></li><li><p>删除src目录</p></li><li><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2、创建一个模块-子项目"><a href="#2-2、创建一个模块-子项目" class="headerlink" title="2.2、创建一个模块(子项目)"></a>2.2、创建一个模块(子项目)</h3><ul><li><p>编写mybatis的核心配置文件：resources下建一个mybaits-config.xml文件</p></li><li><p>连接数据库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--configuration核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;526736&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为了从 XML 中构建 SqlSessionFactory类，，编写mybatis工具类</p><p>在Utils包下建MybatisUtils类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqlSessionFactory --&gt; sqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"><span class="comment">//提升作用域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Mybatis第一步：获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。</span></span><br><span class="line">    <span class="comment">// SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession  <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h3><ul><li><p>pojo包下写User实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的方法的话就要再写一个UserDao的实现类，用来配置和数据库的连接，现在用来mybaits之后就不需要了，用一个UserMapper.xml的配置文件代替就好了。（这里先暂时建在dao包下面）</p></li><li><p>接口实现类由原来的UserDaoImpl转变为一个 Mapper.xml配置文件.</p><p>namespace=绑定一个对应的Dao/Mapper接口；id就是抽象的方法名，相当于重写了那个抽象方法、这么理解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">       select * from mybatis.user</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h3><p>出现异常：（绑定异常！！）</p><p>org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.</p><p><strong>MapperRegistry是什么？</strong></p><p>核心配置文件中注册 mappers: <!-- 每一个mapper.xml都需要再mybatis核心配置文件中注册--></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每一个mapper.xml都需要再mybatis核心配置文件中注册--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是因为mapper.xml写在dao包下导致错误，，应该在子父项目的pom.xml里面都加上(如果还不行，就把xml里里面的中文注释给去掉)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>junit测试：再text的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：获得SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：getMapper</span></span><br><span class="line">    <span class="comment">//相当于调用dao包下面的UserDao类及其下的方法</span></span><br><span class="line">    UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>你们可以能会遇到的问题：</p><ol><li>配置文件没有注册</li><li>绑定接口错误。</li><li>方法名不对</li><li>返回类型不对</li><li>Maven导出资源问题</li></ol><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210046.png" alt="image-20210323195446143" style="zoom:67%;"><h2 id="3、CRUD（基础）"><a href="#3、CRUD（基础）" class="headerlink" title="3、CRUD（基础）"></a>3、CRUD（基础）</h2><h3 id="3-1、namespace"><a href="#3-1、namespace" class="headerlink" title="3.1、namespace"></a>3.1、namespace</h3><p>namespace中的包名要和 Dao/mapper 接口的包名一致！</p><h3 id="3-2、select"><a href="#3-2、select" class="headerlink" title="3.2、select"></a>3.2、select</h3><p>选择，查询语句;</p><ul><li>id : 就是对应的namespace中的方法名；</li><li>resultType：Sql语句执行的返回值！</li><li>parameterType ： 参数类型！</li></ul><ol><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据ID查询用户</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>编写对应的mapper.xml中的sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUserById&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">   </span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">   </span><br><span class="line">    User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">   </span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3、Insert"><a href="#3-3、Insert" class="headerlink" title="3.3、Insert"></a>3.3、Insert</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4、update"><a href="#3-4、update" class="headerlink" title="3.4、update"></a>3.4、update</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id = #&#123;id&#125; ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5、Delete"><a href="#3-5、Delete" class="headerlink" title="3.5、Delete"></a>3.5、Delete</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><strong>增删改需要提交事务！，也可以在配置文件中设置增删改自动提交事务</strong></li></ul><h3 id="3-6、分析错误"><a href="#3-6、分析错误" class="headerlink" title="3.6、分析错误"></a>3.6、分析错误</h3><ul><li>标签不要匹配错</li><li>resource 绑定mapper，需要使用路径！</li><li>程序配置文件必须符合规范！</li><li>NullPointerException，没有注册到资源!</li><li>输出的xml文件中存在中文乱码问题！</li><li>maven资源没有导出问题！</li></ul><h3 id="3-7、万能Map"><a href="#3-7、万能Map" class="headerlink" title="3.7、万能Map"></a>3.7、万能Map</h3><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//万能的Map</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象中的属性，可以直接取出来    传递map的key--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, pwd) values (#&#123;userid&#125;,#&#123;passWord&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void addUser2()&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Map<span class="tag">&lt;<span class="name">String,</span> <span class="attr">Object</span>&gt;</span> map = new HashMap<span class="tag">&lt;<span class="name">String,</span> <span class="attr">Object</span>&gt;</span>();</span><br><span class="line"></span><br><span class="line">    map.put(&quot;userid&quot;,5);</span><br><span class="line">    map.put(&quot;passWord&quot;,&quot;2222333&quot;);</span><br><span class="line"></span><br><span class="line">    mapper.addUser2(map);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可！    【parameterType=”map”】</p><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p><p>多个参数用Map，<strong>或者注解！</strong></p><h3 id="3-8、思考题"><a href="#3-8、思考题" class="headerlink" title="3.8、思考题"></a>3.8、思考题</h3><p>模糊查询怎么写？</p><ol><li><p>Java代码执行的时候，传递通配符 % %</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在sql拼接中使用通配符！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-9、结果集映射resultMap"><a href="#3-9、结果集映射resultMap" class="headerlink" title="3.9、结果集映射resultMap"></a>3.9、结果集映射resultMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id   name   pwd</span><br><span class="line">id   name   password</span><br></pre></td></tr></table></figure><p>在UserMapper.xml中单独写一个结果集的映射，就是返回的结果是一个map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--结果集映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--column数据库中的字段，property实体类中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素</li><li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li><li><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</li><li>如果世界总是这么简单就好了。</li></ul><h2 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h2><p>就是mybatis的核心配置文件：mybaits-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;526736&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）:可以直接写，也可以调用外部的db.properties属性配置文件</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）：如mybatis-plus</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）:每个 SqlSessionFactory 实例只能选择一种环境</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）：<span class="string">&#x27;每一个Mapper.XML都需要在Mybatis核心配置文件中注册!!!&#x27;</span> 有三种方式</span><br></pre></td></tr></table></figure><h3 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件；</p><p>方式一： 【我目前使用的这种，用来绑定mapper.xml文件，有路径 文件可以放在任意地方】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class文件绑定注册【文件需放在resources中，似乎更方便】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须同名！</li><li>接口和他的Mapper配置文件必须在同一个包下！</li></ul><h2 id="5、生命周期和作用域"><a href="#5、生命周期和作用域" class="headerlink" title="5、生命周期和作用域"></a>5、生命周期和作用域</h2><p>这里指的是SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession的作用域</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210055.png" alt="1569660737088" style="zoom: 50%;"><p><strong>SqlSessionFactoryBuilder：</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory：</strong></p><ul><li><p>类似数据库连接池</p></li><li><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong> </p></li><li><p>因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的仅创建一个SqlSessionFactory 的单例</p></li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求！</li><li>SqlSession 的实例的最佳的作用域是请求或方法作用域。</li><li>用完之后需要赶紧关闭，否则资源被占用！</li></ul><h2 id="6、分页"><a href="#6、分页" class="headerlink" title="6、分页"></a>6、分页</h2><p>有三种实现方式：sql、java对象、分页插件</p><h3 id="1、在sql语句层实现，使用Limit分页"><a href="#1、在sql语句层实现，使用Limit分页" class="headerlink" title="1、在sql语句层实现，使用Limit分页"></a>1、在sql语句层实现，使用Limit分页</h3><ul><li>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Mapper.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--//分页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from  mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;startIndex&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;pageSize&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList =  mapper.getUserByLimit(map);</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、在java代码层实现，使用RowBounds类分页"><a href="#2、在java代码层实现，使用RowBounds类分页" class="headerlink" title="2、在java代码层实现，使用RowBounds类分页"></a>2、在java代码层实现，使用RowBounds类分页</h3><p>是面向对象的思路，但是没有sql快，不学不学</p><ol><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页2</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByRowBounds</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByRowBounds&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from  mybatis.user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByRowBounds</span><span class="params">()</span></span>&#123;</span><br><span class="line">SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//RowBounds实现</span></span><br><span class="line">RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Java代码层面实现分页</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;com.kuang.dao.UserMapper.getUserByRowBounds&quot;</span>,<span class="keyword">null</span>,rowBounds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="7、使用注解开发"><a href="#7、使用注解开发" class="headerlink" title="7、使用注解开发"></a>7、使用注解开发</h2><h3 id="7-1-注解查询示例"><a href="#7-1-注解查询示例" class="headerlink" title="7.1 注解查询示例"></a>7.1 注解查询示例</h3><p>注解就是不在使用mapper.xml来实现接口类，而是用注解的方式来实现</p><p><strong>本质：反射机制实现   底层：动态代理！</strong></p><ol><li><p>注解在接口UserMapper上实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>需要再核心配置文件中绑定接口！（删掉原来mapper.xml的绑定）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试(与之前一样的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.getUsers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user:users)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>说白了，底层是反射，使用很方便、只用在接口中的抽象方法前面加一个<code>@Select(&quot;select * from user&quot;)</code>注解就可以了，但一般只能支持简单的查询。（所以我实习的时候还是用的xml那一套）</p><h3 id="7-2-使用注解的CRUD"><a href="#7-2-使用注解的CRUD" class="headerlink" title="7.2 使用注解的CRUD"></a>7.2 使用注解的CRUD</h3><p>编写接口，增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@Param(&quot;uid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>基本类型和String类型建议加上<code>@Param(&quot;uid&quot;)</code>，如有多个参数必须要加(引用类型不用)</li><li>@Param() 中设定的属性名一定义要和SQL语句中的参数名一样</li></ul><h3 id="7-3-区别"><a href="#7-3-区别" class="headerlink" title="7.3 #{}     ${} 区别"></a><strong>7.3 #{}     ${} 区别</strong></h3><ul><li><p>MyBatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ?，预编译 SQL，通过set()方法进行参数赋值。使用 #{} 可以有效地防止 SQL 注入。</p></li><li><p>在处理 ${} 时，会直接把${} 替换为参数值，存在 SQL 注入的风险</p></li><li><p>${}一般用入传入数据库对象，比如数据库表名；mybaties排序时使用order by 动态参数时需要注意，使用${}而不用#{}; (不太懂)</p></li></ul><h2 id="8-多对一处理、一对多处理"><a href="#8-多对一处理、一对多处理" class="headerlink" title="8 多对一处理、一对多处理"></a>8 多对一处理、一对多处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**MyBatis实现多对一，一对多有几种方式，怎么操作的？**</span><br><span class="line">有联合查询和嵌套查询。</span><br><span class="line">- 联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置多对一，一对多的类就可以完成</span><br><span class="line">- 嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ol><li>关联 - association   【多对一】</li><li>集合 - collection   【一对多】</li><li>javaType    &amp;   ofType<ol><li>JavaType  用来指定实体类中属性的类型</li><li>ofType  用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！</li></ol></li></ol><h2 id="9-动态SQL"><a href="#9-动态SQL" class="headerlink" title="9 动态SQL"></a>9 动态SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？**</span><br><span class="line"></span><br><span class="line">Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</span><br><span class="line"></span><br><span class="line">其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</span><br></pre></td></tr></table></figure><p><strong>动态SQL：就是指根据不同的条件生成不同的SQL语句</strong></p><p>==<strong>所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码</strong>==</p><p>==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了==</p><p>建议：</p><ul><li>现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！</li><li>(实习我做的东西基本上都是动态查询，就是sql语句里面有判断条件)</li></ul><p><strong>举例：使用foreach执行批量操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> </span><br><span class="line"></span><br><span class="line">  &lt;foreach item=<span class="string">&quot;id&quot;</span> collection=<span class="string">&quot;ids&quot;</span></span><br><span class="line">      <span class="keyword">open</span>=<span class="string">&quot;(&quot;</span> separator=<span class="string">&quot;or&quot;</span> <span class="keyword">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">        <span class="comment">#&#123;id&#125;</span></span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">or</span> <span class="keyword">id</span>=<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210104.png" alt="1569979229205"></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210109.png" alt="1569979339190"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3)</span></span><br><span class="line"><span class="comment">        我们现在传递一个万能的map ， 这map中可以存在一个集合！</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10、缓存"><a href="#10、缓存" class="headerlink" title="10、缓存"></a>10、缓存</h2><h3 id="10-1、缓存定义"><a href="#10-1、缓存定义" class="headerlink" title="10.1、缓存定义"></a>10.1、缓存定义</h3><ol><li><p>什么是缓存 [ Cache ]？</p><ul><li>存在内存中的临时数据。</li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li></ul></li><li><p>为什么使用缓存？</p><ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li></ul></li><li><p>什么样的数据能使用缓存？</p><ul><li>经常查询并且不经常改变的数据。【可以使用缓存】</li></ul></li></ol><h3 id="10-2、Mybatis缓存"><a href="#10-2、Mybatis缓存" class="headerlink" title="10.2、Mybatis缓存"></a>10.2、Mybatis缓存</h3><ul><li>MyBatis默认定义了两级缓存：<strong>一级缓存</strong>、<strong>二级缓存</strong>和<strong>可自定义的二级缓存</strong></li></ul><h4 id="一级缓存："><a href="#一级缓存：" class="headerlink" title="一级缓存："></a>一级缓存：</h4><ul><li><p><strong>默认开启一级缓存。SqlSession级别的缓存,存在于一次会话之间</strong></p></li><li><p>所有 select 语句的结果将会被缓存</p></li><li><p>执行insert、update 和 delete 语句会刷新缓存</p></li><li><p>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存（默认）。</p></li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存:"></a>二级缓存:</h4><ul><li>基于namespace级别的缓存，一个命名空间Mapper，对应一个二级缓存；（需要手动打开）</li><li>如果当前会话关闭了，这个会话对应的一级缓存就失效了；但是如果我们仍需要这个缓存数据，会话关闭时，我们将一级缓存中的数据被保存到二级缓存中；</li></ul><p>步骤：</p><ol><li><p>在mybatis-config.xml中显示的开启全局缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--显示的开启全局缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在要使用二级缓存的Mapper中开启，即mapper.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以自定义参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试：需要先序列化User类，User类实现Serializable接口就好了</p><blockquote><blockquote><p>问题:我们需要将实体类序列化！否则就会报错！Caused by:java.io.NotSerializableException:com.kuang.pojo.User</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    SqlSession sqlSession2 = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User user = mapper.getUserById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">    User user2 = mapper2.getUserById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="自定义缓存ehcache-（跳过）"><a href="#自定义缓存ehcache-（跳过）" class="headerlink" title="自定义缓存ehcache:（跳过）"></a>自定义缓存ehcache:（跳过）</h4><blockquote><p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存。停更很多年了16年…</p></blockquote><p>为了提高扩展性，MyBatis还定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。</p><h4 id="缓存查找原理"><a href="#缓存查找原理" class="headerlink" title="缓存查找原理"></a><strong>缓存查找原理</strong></h4><ul><li>查数据时，先看二级缓存中有没有</li><li>再看一级缓存中有没有</li><li>都没有再查询数据库</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112210115.png" alt="1569985541106"></p><p>Redis数据库来做缓存！  K-V键值对</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11 总结"></a>11 总结</h2><ul><li>mybaits实现的两种方式：xml文件和注解</li><li>练习两种方式的增删改查</li><li>映射器（mappers）实现有三种方式</li><li>参数的map映射、结果集的map映射、</li><li>分页、动态SQL</li><li>mybatis的两级缓存的机制</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Mybatis教学视频学习笔记，仅实操重要部分，面向秋招学习，知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mybaits实现的两种方式：xml文件和注解&lt;/li&gt;
&lt;li&gt;映射器（mappers）实现的三种方式&lt;/li&gt;
&lt;li&gt;参数的map映射、结果集的map映射&lt;/li&gt;
&lt;li&gt;分页、动态SQL、mybatis的两级缓存的机制&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Mybatis" scheme="https://wukang555.github.io/tags/Mybatis/"/>
    
  </entry>
  
</feed>
