<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落风的风</title>
  
  
  <link href="https://wukang555.github.io/atom.xml" rel="self"/>
  
  <link href="https://wukang555.github.io/"/>
  <updated>2022-05-19T02:13:17.077Z</updated>
  <id>https://wukang555.github.io/</id>
  
  <author>
    <name>Wu kang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git+hexo博客推送流程</title>
    <link href="https://wukang555.github.io/2022/05/19/1_push%E6%B5%81%E7%A8%8B/"/>
    <id>https://wukang555.github.io/2022/05/19/1_push%E6%B5%81%E7%A8%8B/</id>
    <published>2022-05-19T15:59:00.000Z</published>
    <updated>2022-05-19T02:13:17.077Z</updated>
    
    <content type="html"><![CDATA[<p>push流程的步骤总是记不住，hexo+Github上写博客每次都要手动加文件头，还是觉得不够优雅，以后转战typecho了。</p><a id="more"></a><h1 id="1-文件头格式"><a href="#1-文件头格式" class="headerlink" title="1 文件头格式"></a>1 文件头格式</h1><blockquote><p>md文件最前面的由 — 符号括起来的，叫做Front-matter，有些功能需要有对应的插件，这个设置才会生效。</p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">title: 多线程笔记（狂神） </span><br><span class="line">date: 2021/01/15 22:55:00</span><br><span class="line">comments: true</span><br><span class="line">top: fault</span><br><span class="line">no<span class="emphasis">_word_</span>count: fault</span><br><span class="line">reward: fault </span><br><span class="line">copyright: true </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> 狂神</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 线程</span><br><span class="line"><span class="bullet">-</span> 并发</span><br></pre></td></tr></table></figure><h1 id="2-push推送流程"><a href="#2-push推送流程" class="headerlink" title="2 push推送流程"></a>2 push推送流程</h1><ul><li>1 先在路径窗口输入cmd打开命令行窗口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd</span><br></pre></td></tr></table></figure><ul><li>2在本地部署 看一看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;hexo g&amp;hexo s      （ctrl+c退出）</span><br></pre></td></tr></table></figure><ul><li>3推到网络 搞定 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;hexo g&amp;hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;push流程的步骤总是记不住，hexo+Github上写博客每次都要手动加文件头，还是觉得不够优雅，以后转战typecho了。&lt;/p&gt;</summary>
    
    
    
    <category term="代码规范" scheme="https://wukang555.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="hexo" scheme="https://wukang555.github.io/tags/hexo/"/>
    
    <category term="博客" scheme="https://wukang555.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>代码规范_04_Git协同</title>
    <link href="https://wukang555.github.io/2022/05/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_04_Git%E5%8D%8F%E5%90%8C/"/>
    <id>https://wukang555.github.io/2022/05/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_04_Git%E5%8D%8F%E5%90%8C/</id>
    <published>2022-05-19T15:58:00.000Z</published>
    <updated>2022-05-19T02:16:43.479Z</updated>
    
    <content type="html"><![CDATA[<p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。Git是协同开发的最常用工具。</p><a id="more"></a><blockquote><p>理论部分主要是狂神git视频的笔记</p><p>第5节主要记录实习过程遇到的诸多git问题</p></blockquote><p>最常用的命令 没有之一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/wuzhikang #新建分支并切换到该分支</span><br><span class="line">git status</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><h1 id="1-什么是版本控制"><a href="#1-什么是版本控制" class="headerlink" title="1 什么是版本控制"></a>1 什么是版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。Git是最优秀的分布式版本控制系统，最初Linus Benedic Torvalds开发的目的是为了Linux内核系统的版本控制。</p><h1 id="2-Git的安装和基本命令"><a href="#2-Git的安装和基本命令" class="headerlink" title="2 Git的安装和基本命令"></a>2 Git的安装和基本命令</h1><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ul><li>下载地址淘宝镜像网站<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></li><li>我这里下载了一个Git-2.33.0-64-bit.exe的安装包。选择开发软件安装路径，然后无脑安装（查看器可以选择notepad++）。会自动帮你配置环境变量</li><li>配置账号名和邮箱，任意路径下点开git bush</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;wukang&quot;</span><br><span class="line">git config --global user.email &quot;67363085@qq.com&quot;</span><br><span class="line">git config --global --list #查看配置</span><br></pre></td></tr></table></figure><p>实际上git的配置都保存在本地</p><ul><li>Git\etc\gitconfig     # Git 安装目录下的 gitconfig   –system 系统级</li><li>C:\Users\Administrator\ .gitconfig   #只适用于当前登录用户的配置  –global 全局</li></ul><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd #切换目录</span><br><span class="line">cd [绝对路径] #切换至该绝对路径下</span><br><span class="line">cd /  #表示切换到根目录下</span><br><span class="line">cd ..  #表示返回上一级目录</span><br><span class="line"></span><br><span class="line">ls #查看当前下的目录、可能时最常用的命令</span><br><span class="line">ls -a #查看当前目录下的所有目录，包括隐藏</span><br><span class="line">ls -l #列出当前下目录的包含文件的属性与权限等等数据；(常用)</span><br><span class="line">ls -al #列出当前下目录的包含文件的属性与权限等等数据,包括隐藏</span><br><span class="line">ls / #查看根目录/下的目录</span><br><span class="line"></span><br><span class="line">pwd #显示目前所在的目录</span><br><span class="line">pwd -P # 如果是链接，要显示真实地址</span><br><span class="line"></span><br><span class="line">mkdir -p test2/test3/test4 # 用-p递归创建层级目录</span><br><span class="line">rmdir -p test2/test3/test4 #递归删除文件</span><br><span class="line"></span><br><span class="line">cp /root/install.sh /home #将install.sh 复制到home文件夹中</span><br><span class="line"></span><br><span class="line">clear #清屏</span><br><span class="line">exit #退出</span><br></pre></td></tr></table></figure><h1 id="3-Git基本理论（重要）"><a href="#3-Git基本理论（重要）" class="headerlink" title="3 Git基本理论（重要）"></a>3 Git基本理论（重要）</h1><h2 id="1-Git的工作区域"><a href="#1-Git的工作区域" class="headerlink" title="1 Git的工作区域"></a>1 Git的工作区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。远处有一个远程git仓库（Remote Directory）。状态变化最主要的几个操作分别是<strong>add、commit、push和pull、fetch</strong>。</p><img src="http://kmknkk.oss-cn-beijing.aliyuncs.com/image/git.jpg" alt="img" style="zoom: 80%;"><ul><li>Remote：远程仓库，就是git上面的所有已经上传过的代码，所有协同开发人员都可以随时获取（即pull或fetch）</li><li>Repository：资源库（我更喜欢叫本地库），就是你本地这个主机修改过的代码经过提交后的版本（未提交的不算）。也就是idea右下角点开分支目录，这些分支都是你本地的版本</li><li>Working Directory：工作目录，就是本地这个主机的未提交的代码的版本（就是我们工作的地方！！正在码代码的这个版本）</li><li>Index：暂存区，新修改或者新建的代码通过add后放入暂存区。但不重要（但在我都是add&amp;commit一起执行）</li></ul><h2 id="2-文件的几种状态"><a href="#2-文件的几种状态" class="headerlink" title="2 文件的几种状态"></a>2 文件的几种状态</h2><p>git管理的文件有几种状态：未跟踪（Untracked），已修改（modified）,已暂存（staged）,已提交(committed)</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220114092338.png" alt="image-20220114092338934" style="zoom:67%;"><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><p>查看文件的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看指定文件状态</span></span><br><span class="line">git status [filename]</span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有文件状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改文件状态</span></span><br><span class="line">git add .                        #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;消息内容bababa&quot;    #提交暂存区中的内容到本地仓库 -m 提交信息</span><br></pre></td></tr></table></figure><p>忽略文件：有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等。需要在主目录下建立”.gitignore”文件。此文件夹内适用如下规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">为注释</span></span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h1 id="4-Git的使用"><a href="#4-Git的使用" class="headerlink" title="4 Git的使用"></a>4 Git的使用</h1><h2 id="1-Git的基本使用"><a href="#1-Git的基本使用" class="headerlink" title="1 Git的基本使用"></a>1 Git的基本使用</h2><ul><li>1 先登录码云，然后为本地机器添加一个SSH公钥。码云上创建一个空项目作为远程仓库。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220114112613.png" alt="image-20220114112613923" style="zoom:67%;"><ul><li>2 将该项目克隆到本地，比如C:\IdeaProjects文件夹下。记得选择<strong>SSH链接</strong>的形式克隆</li><li>3 idea新建spring项目比如hello-01，将克隆<code>gitstudy</code>下所有文件复制进hello-01项目目录</li><li>4 观察学习idea中git的命令和按钮。<ul><li>右上角有update、commit和push</li><li>左下角有git图标，可以查看版本信息</li><li>Terminal标签窗口可以执行git命令</li><li>任意文件右键，有git命令选择</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令行常见操作</span></span><br><span class="line">git add .                       #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;本次提交了****&quot;    #提交暂存区中的内容到本地仓库 -m 提交信息</span><br><span class="line">git push                        #提交</span><br></pre></td></tr></table></figure><h2 id="2-Git常用命令"><a href="#2-Git常用命令" class="headerlink" title="2 Git常用命令"></a>2 Git常用命令</h2><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220114120159.png" alt="image-20220114120159076" style="zoom:67%;"><h3 id="git命令之branch"><a href="#git命令之branch" class="headerlink" title="git命令之branch"></a>git命令之branch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">切换至某分支</span></span><br><span class="line">git checkout [branch]                </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="git命令之add、commit、restore"><a href="#git命令之add、commit、restore" class="headerlink" title="git命令之add、commit、restore"></a>git命令之add、commit、restore</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区 </span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录 </span></span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区 </span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交 <span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将在工作空间但是不在暂存区的文件撤销更改,文件的修改将消失（丢失）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git restore &lt;file&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 作用是将暂存区的文件从暂存区撤出，但不会更改文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git restore --staged &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h3 id="git命令之checkout、reset"><a href="#git命令之checkout、reset" class="headerlink" title="git命令之checkout、reset"></a>git命令之checkout、reset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit <span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支 </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><h3 id="git命令之查看信息"><a href="#git命令之查看信息" class="headerlink" title="git命令之查看信息"></a>git命令之查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h2 id="3-Commit-message格式"><a href="#3-Commit-message格式" class="headerlink" title="3 Commit message格式"></a>3 Commit message格式</h2><blockquote><p>Git的核心是commit，所以写好commit信息极其重要。</p><p>方式一：提交信息只能有一行</p><p>git commit [fileName] -m “commit message”</p><p>方式二：使用vim编辑方式，提交现信息可以多行（推荐这种，可以按规范来）</p><p>git commit [fileName]</p></blockquote><p>Commit message规范如下：<strong>Header 第一行是必需的，Body 和 Footer 可以省略。</strong>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p><strong>（1）type</strong></p><p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>（2）scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>（3）subject</strong></p><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><ul><li>以动词开头，使用第一人称现在时</li><li>第一个字母小写，结尾不加句号（<code>.</code>）</li></ul><p><strong>（4）body</strong></p><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><p>有两个注意点。</p><ul><li><p>使用第一人称现在时</p></li><li><p>应该说明代码变动的动机，以及与以前行为的对比。</p></li></ul><p><strong>（5）Footer</strong></p><p>Footer 部分只用于两种情况：<strong>不兼容变动</strong>、<strong>关闭 Issue</strong></p><ul><li>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</li><li>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</li></ul><h3 id="Revert撤销commit"><a href="#Revert撤销commit" class="headerlink" title="Revert撤销commit"></a>Revert撤销commit</h3><p><strong>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#39;graphiteWidth&#39; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><h1 id="5-Git开发流程"><a href="#5-Git开发流程" class="headerlink" title="5 Git开发流程"></a>5 Git开发流程</h1><h2 id="5-1-Git-Flow"><a href="#5-1-Git-Flow" class="headerlink" title="5.1 Git Flow"></a>5.1 Git Flow</h2><blockquote><p>参考了<a href="https://blog.csdn.net/xingbaozhen1210/article/details/81386269">博文</a>，关于分支的介绍和主要的工作流程都介绍的很好</p></blockquote><p>Git官方给的流程：</p><img src="http://images2015.cnblogs.com/blog/524341/201701/524341-20170112192235150-1905124194.png" alt="img" style="zoom: 33%;"><p>由上图可知，GitFlow的常用分支有：master、develop、feature、release、hotfix。分支介绍如下：</p><p><strong>master</strong></p><ul><li>主分支 , 产品的功能全部实现后 , 最终在master分支对外发布</li><li>该分支为<strong>只读</strong>唯一分支 , 只能从其他分支(release/hotfix)合并 , 不能在此分支修改</li><li>另外所有在master分支的推送应该打标签做记录,方便追溯</li><li>例如release合并到master , 或hotfix合并到master</li></ul><p><strong>develop</strong></p><ul><li>主开发分支 , 基于master分支克隆</li><li>包含所有要发布到下一个release的代码</li><li>该分支为只读唯一分支 , 只能从其他分支合并</li><li>feature功能分支完成 , 合并到develop(不推送)</li><li>develop拉取release分支 , 提测</li><li>release/hotfix 分支上线完毕 , 合并到develop并推送</li></ul><p><strong>feature</strong></p><ul><li>功能开发分支 , 基于develop分支克隆 , 主要用于新需求新功能的开发</li><li>功能开发完毕后合到develop分支(未正式上线之前不推送到远程中央仓库!!!)</li><li>feature分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li></ul><p><strong>release</strong></p><ul><li>测试分支 , 基于feature分支合并到develop之后  , 从develop分支克隆</li><li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的BUG在本分支进行修复 , 修复完成上线后合并到develop/master分支并推送(完成功能) , 打Tag</li><li>属于临时分支 , 功能上线后可选删除</li></ul><p><strong>hotfix</strong></p><ul><li>补丁分支 , 基于master分支克隆 , 主要用于对线上的版本进行BUG修复</li><li>修复完毕后合并到develop/master分支并推送 , 打Tag</li><li>属于临时分支 , 补丁修复上线后可选删除</li><li>所有hotfix分支的修改会进入到下一个release</li></ul><p>公司的项目流程：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220217174754.png" alt="image-20220217174754792"></p><p>作为开发人员，我们公司的大致流程就是：</p><ul><li>1 master分支poll更新拉取最新的代码，新建分支fix或feature</li><li>2 本地开发并调试，完成后commit、pull、push，push完成后请求合并test分支，更新测试环境并进行测试</li><li>3 将分支代码merge合并到master分支，并上线</li></ul><h2 id="5-2-场景最佳实践"><a href="#5-2-场景最佳实践" class="headerlink" title="5.2 场景最佳实践"></a>5.2 场景最佳实践</h2><blockquote><p>此部分参考<a href="https://blog.csdn.net/weixin_39517199/article/details/110660836?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-8.pc_relevant_default&spm=1001.2101.3001.4242.5&utm_relevant_index=11">博客</a></p></blockquote><p><strong>先介绍一下最常用的3个Git指令！！</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status # 充分、及时了解当前的 git 状态可以避免一些误操作</span><br></pre></td></tr></table></figure><p>我通常在 <strong>写完代码后、做任何git操作前、做复杂的git操作的途中(比如 rebase、merge遇到冲突时)和 做完任何git操作后</strong>，都会使用 git status去查看当前的状态 —— 哪些文件还在工作区(还没 git add)、哪些文件还在暂存区(还没 git commit)或者 rebase、merge 的进展等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline # 打印出最近的commit messages，每条message只占一行，使界面更干净、美观。</span><br></pre></td></tr></table></figure><p>我通常会在 <strong>切换分支的前后，拉取线上分支的前后</strong> 使用git log –oneline，它能帮我根据 commit message 确认我当前的分支以及当前分支是否是最新的 (前提是每次 commit 时一定要认真填写 commit message)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit  # commit 是git 设计中的核心</span><br></pre></td></tr></table></figure><p>在日常开发工作中，我通常会在 <strong>写完一部分代码后，准备暂时休息前或确认某个功能/bug处理完成后</strong> 使用 <strong>git add</strong> 和 <strong>git commit</strong> 来保存代码到本地仓库。</p><p>记住：只要正确地 commit了，代码就几乎永远不会丢失。</p><h3 id="场景一：新任务-开发新特性-修bug"><a href="#场景一：新任务-开发新特性-修bug" class="headerlink" title="场景一：新任务(开发新特性 / 修bug)"></a>场景一：新任务(开发新特性 / 修bug)</h3><blockquote><p>一般的业务需求都是这个场景</p></blockquote><ul><li><p>1 <strong>git status</strong> 查看当前项目的状态，如果有未保存的修改，就保存和提交修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit [fileName] #使用vim方式提交message</span><br></pre></td></tr></table></figure></li><li><p>2 切换到开发主分支develop，并确认主分支是最新的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull origin develop</span><br></pre></td></tr></table></figure></li><li><p>3 创建新的开发分支feature/newFunctionWK，并在该分支上进行开发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/newFunctionWK</span><br></pre></td></tr></table></figure></li><li><p>4 开发过程如果当前任务比较复杂，代码量比较多，通常会多次使用 <strong>git add .</strong> 和 <strong>git commit</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit [fileName] #使用vim方式提交message</span><br><span class="line"><span class="meta">#</span><span class="bash">message需要按照规范写清楚，第一行为标题，空格行后写详细的备注</span></span><br></pre></td></tr></table></figure></li><li><p>5 代码开发结束，整理合并 commit message，代码步骤如下：</p><blockquote><p>前面说过多次 commit 是为了防止意外丢失代码，但是在推到远端之前，最好把一次开发的 commit 合并成一个，避免污染远端的 git commit message，</p></blockquote><ul><li>首先git status确保所有代码都提交了</li><li>然后git logl查看当前分支下最近所有的commit，比如最近我有两个关于fix：规范代码的提交</li><li>执行git rebase -i HEAD命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git log --oneline #oneline可加可不加</span><br><span class="line">git rebase -i HEAD~2 #合并本地最近两次的commit</span><br><span class="line"><span class="meta">#</span><span class="bash"> git rebase -i [startpoint] [endpoint] <span class="comment">#也可以指定两个commit的点如下</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git rebase -i 23cc2cabb387f4ba43b7b0daa4d0aa40847a7cc6 22e4245da8330644f865c5eb582fc857ed109685</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正常应该是在控制台vim编辑修改，但我这个会弹窗Nodepad++,如下图,要更新的代码如下</span></span><br><span class="line">git rebase --continue #再执行这个</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后继续编辑合并两条message,原图如下，要修改部分如下代码</span></span><br><span class="line"></span><br><span class="line">git log #查看日志，发现两条commit已经合并为1条</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220218151834.png" alt="image-20220218151826942"></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220218165247.png" alt="image-20220218165247203"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 22e4245 fix：代码规范</span><br><span class="line">squash 23cc2ca fix：代码规范</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220218165622.png" alt="image-20220218165622637"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fix：代码规范&amp;更新时可以指定初稿状态</span><br><span class="line"></span><br><span class="line">更优雅的判断新建文章和更新文章的判断</span><br><span class="line">添加更新文章时指定初稿状态仍然可以作为初稿的逻辑判断</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220218171348.png" alt="img"></p></li><li><p><strong>6 push本分支到远端仓库，然后上git上请求合并</strong></p><ul><li>这里为了避免冲突，一般还有其他的实施方案：</li><li>1 先切换到develop分支，poll拉最新的代码</li><li>2 然后在本地将feature/newFunctionWK分支合并到本地的develop分支，如果出现冲突就解决冲突</li><li>3 将本地的develop分支push到远端仓库（此时远端develop就是最新的已经合并的代码了）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景二：开发进行一半，需要远端主分支的最新代码"><a href="#场景二：开发进行一半，需要远端主分支的最新代码" class="headerlink" title="场景二：开发进行一半，需要远端主分支的最新代码"></a>场景二：开发进行一半，需要远端主分支的最新代码</h3><blockquote><p>背景：有些时候，你在本地开发某个功能，代码写到一半，某个同事将某些重要代码合进了**远端的主分支(如 develop 分支)**里。这些重要代码可能是可以极大提升本地开发效率，可能是加入了某些规范检查或者是跟你当前开发相关的代码 —— 总之需要你将那部分代码融入你当前的本地开发环境里。</p></blockquote><p>三个步骤如下：</p><ul><li><strong>git status</strong> 查看当前项目的状态，如果有未保存的修改，就<strong>git add .</strong> 和 <strong>git commit</strong> 保存下来</li><li><strong>git pull –rebase origin develop</strong> 使用这个指令将远端的主分支develop以 rebase 的形式 “合进”当前分支<ul><li>执行这条命令之前，需要保证没有文件处于modified状态</li><li>如果有文件处于modified而这个修改又不应该commit，比如application.yml，就先移除这个修改：git restore  <file></file></li></ul></li><li><strong>git log –oneline</strong> 查看当前分支下的 commit message 是否符合预期</li></ul><p>为什么用 –rebase 呢？</p><p>因为这么做，可以让git历史最干净、整洁 —— 所有本地开发的 commit 都会出现在远端主分支里的 commit 之后；并且可以避免额外引入一次 merge 的 commit(避免本地多执行一次merge)</p><h3 id="场景三：希望把某个分支中的-commit-对应的代码复制到当前分支"><a href="#场景三：希望把某个分支中的-commit-对应的代码复制到当前分支" class="headerlink" title="场景三：希望把某个分支中的 commit 对应的代码复制到当前分支"></a>场景三：希望把某个分支中的 commit 对应的代码复制到当前分支</h3><blockquote><p>有时我会创建一些实验性的分支，写一些实验性的代码，如果代码不可行，我可以直接废弃掉这个分支，返回原本的开发分支中；<strong>如果这些实验性代码可行，我会返回开发分支中，然后把实验性分支的那部分代码“复制”过来</strong></p></blockquote><p>具体操作如下：</p><ul><li><p><strong>git status</strong> 查看当前项目的状态，如果有未保存的修改，就<strong>git add .</strong> 和 <strong>git commit</strong> 保存下来</p></li><li><p>假设我们需要的是 feature/newFunctionWK 这个分支的某个 commit ，使用 <strong>git log –oneline feature/newFunctionWK</strong> 查看最近这个分支的所有 commit 记录</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220218180110.png" alt="img"></p></li><li><p>使用 <strong>git cherry-pick 50dd556</strong> 将这个 commit 对应的代码复制到当前分支</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit [fileName] #使用vim方式提交message</span><br><span class="line"></span><br><span class="line">git log --oneline feature/newFunctionWK #查询commit日志</span><br><span class="line"></span><br><span class="line">git cherry-pick 50dd556 #复制50dd556这个commit到当前分支</span><br></pre></td></tr></table></figure><h2 id="5-3-使用git的原则和可能的问题"><a href="#5-3-使用git的原则和可能的问题" class="headerlink" title="5.3 使用git的原则和可能的问题"></a>5.3 使用git的原则和可能的问题</h2><blockquote><p>1 check分支之前需要先下拉代码</p><p>2 如何解决merge代码冲突的问题</p><p>3 为什么出现merge代码不完整的问题</p></blockquote><h3 id="使用git的原则（习惯）"><a href="#使用git的原则（习惯）" class="headerlink" title="使用git的原则（习惯）"></a>使用git的原则（习惯）</h3><ol><li>永远记得 git st 和 git logl 来确认当前分支的状态</li><li>宁愿临时制造一些无用的 commit 来保证代码不会丢失，也不要轻信自己的记忆力</li><li>谨慎(最好能避免)使用 git stash ，极易造成代码丢失</li><li>认真对待、编写每次的 commit message —— 它们能在关键时刻救你一命</li><li>必要的时候可以创建一些临时的分支写实验性的代码，而不是依赖 git reset 撤销 commit —— 大多数人在 git reset 的时候容易犯错误</li></ol><h3 id="出现冲突如何解决（git-merge-conflict）"><a href="#出现冲突如何解决（git-merge-conflict）" class="headerlink" title="出现冲突如何解决（git merge conflict）"></a>出现冲突如何解决（git merge conflict）</h3><blockquote><p>参考博文<a href="https://blog.csdn.net/u012150179/article/details/14047183">https://blog.csdn.net/u012150179/article/details/14047183</a></p></blockquote><p>一个解决的方法就是push之前先poll</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。Git是协同开发的最常用工具。&lt;/p&gt;</summary>
    
    
    
    <category term="代码规范" scheme="https://wukang555.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Git" scheme="https://wukang555.github.io/tags/Git/"/>
    
    <category term="协同开发" scheme="https://wukang555.github.io/tags/%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>mysql语法&amp;练习</title>
    <link href="https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_01_mysql%E8%AF%AD%E6%B3%95&amp;%E7%BB%83%E4%B9%A0/"/>
    <id>https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_01_mysql%E8%AF%AD%E6%B3%95&amp;%E7%BB%83%E4%B9%A0/</id>
    <published>2022-05-19T15:55:00.000Z</published>
    <updated>2022-05-19T01:58:09.719Z</updated>
    
    <content type="html"><![CDATA[<p>基础SQL命令记录、以及一个简单的例子作为参考</p><a id="more"></a><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>SQL（Structured Query Language)：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>1 启动MySQL</p><ul><li>cmd打开运行窗口 键入,启动mysql服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><ul><li>打开SQLyog，连接数据库、进入本地数据库</li><li>创建一个数据库并使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mysqlWk; -- 直接点击建库更好、字符集选择utf-8 排序选择utf_general_ci</span><br><span class="line">USE mysqlWk; ##如果已有数据库 直接使用即可</span><br><span class="line">drop database if exists mysqlWk； ##删库跑路</span><br></pre></td></tr></table></figure><p>2 MySQL三种注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line">-- 注释</span><br><span class="line">&#x2F;* 注释1</span><br><span class="line">   注释2 *&#x2F;</span><br></pre></td></tr></table></figure><p>3 MySQL数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 整型&#x2F;字节数</span><br><span class="line">tinyint smallint mediumint int&#x2F;integer bigint</span><br><span class="line">1         2        3          4            8</span><br><span class="line"></span><br><span class="line"># 浮点数 D位存小数部分，剩下M-D部分存整数部分</span><br><span class="line">float(M,D) 4    double(M,D) 8</span><br><span class="line"></span><br><span class="line"># 字符型</span><br><span class="line">char  varchar 定长&#x2F;变长</span><br><span class="line">-- varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样。</span><br><span class="line">-- 但建议选择合适的 varchar长度，因为 order by排序时，计算的是可变的长度、会占用更多的内存</span><br><span class="line"></span><br><span class="line"># 时间和日期</span><br><span class="line">datetime 8 -- 与时区无关，存从1000年到9999年的日期和时间，精度s</span><br><span class="line">timestamp 4 -- 和时区有关,表示从 1970 年到 2038 年,使用效率更高</span><br></pre></td></tr></table></figure><h1 id="二、创建和修改表"><a href="#二、创建和修改表" class="headerlink" title="二、创建和修改表"></a>二、创建和修改表</h1><blockquote><p>这里所有的表名、属性都用 小写字母_ 的组合</p></blockquote><p>1 创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建 student_info 表</span><br><span class="line">create table student_info (</span><br><span class="line">s_id int primary key not null,</span><br><span class="line">s_name varchar(30) not null,</span><br><span class="line">s_gender int not null default 1,</span><br><span class="line">s_hometown varchar(50),</span><br><span class="line">s_tuition int</span><br><span class="line">);</span><br><span class="line"># 创建 student_subject 表</span><br><span class="line">create table student_subject(</span><br><span class="line">s_id int primary key not null,</span><br><span class="line">s_grade int not null default 60,</span><br><span class="line">sub_id int not null</span><br><span class="line">);</span><br><span class="line"># 创建 subject_info表</span><br><span class="line">create table subject_info(</span><br><span class="line">sub_id int primary key not null,</span><br><span class="line">sub_name varchar(20) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2 修改表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table student_info add age int; -- 添加列</span><br><span class="line">alter table student_info drop age int; -- 删除列</span><br><span class="line">drop table student_info; -- 删除表</span><br></pre></td></tr></table></figure><h1 id="三、增删改"><a href="#三、增删改" class="headerlink" title="三、增删改"></a>三、增删改</h1><p>1 插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">insert into student_info(s_id,s_name,s_gender,s_hometown,s_tuition) values(1,&#39;吴康&#39;,1,&#39;湖南长沙&#39;,8000);</span><br><span class="line">insert into student_info values(2,&#39;落风&#39;,1,&#39;湖北武汉&#39;,5000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(3,&#39;用户1&#39;,1,6000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(4,&#39;用户2&#39;,1,6000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(5,&#39;妹子1&#39;,2,8000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(6,&#39;妹子2&#39;,2,5000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(7,&#39;妹子3&#39;,2,4000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(8,&#39;妹子4&#39;,2,5000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(9,&#39;妹子5&#39;,2,9000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(10,&#39;妹子6&#39;,2,5000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(11,&#39;用户3&#39;,1,4000);</span><br><span class="line">insert into student_info(s_id,s_name,s_gender,s_tuition) values(12,&#39;用户4&#39;,1,5000);</span><br><span class="line"></span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(1,80,1);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(2,59,1);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(3,60,2);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(4,40,2);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(5,80,3);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(6,75,4);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(7,80,4);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(8,90,4);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(9,80,3);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(10,95,3);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(11,96,4);</span><br><span class="line">insert into student_subject(s_id,s_grade,sub_id) values(12,80,1);</span><br><span class="line"></span><br><span class="line">insert into subject_info(sub_id,sub_name) values(1, &#39;Math&#39;);</span><br><span class="line">insert into subject_info(sub_id,sub_name) values(2, &#39;English&#39;);</span><br><span class="line">insert into subject_info(sub_id,sub_name) values(3, &#39;Computer&#39;);</span><br><span class="line">insert into subject_info(sub_id,sub_name) values(4, &#39;News&#39;);</span><br><span class="line">insert into subject_info(sub_id,sub_name) values(5, &#39;civil enginering&#39;);</span><br></pre></td></tr></table></figure><p>2 更新数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update student_info set s_hometown &#x3D; &#39;湖北荆州&#39; where s_id &#x3D; 1;</span><br></pre></td></tr></table></figure><p>3 删除数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from subject_info where sun_id &#x3D; 5; -- 垃圾土木 毁我青春</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212702.png" alt="image-20210825010240565"></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212704.png" alt="image-20210825010257556"></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212706.png" alt="image-20210825010309056"></p><h1 id="四、查询语句"><a href="#四、查询语句" class="headerlink" title="四、查询语句"></a>四、查询语句</h1><blockquote><p><strong>书写顺序和执行顺序！！</strong>语法：<br>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br> group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨</p></blockquote><p><strong>1 limit i，j;  返回第i行开始的共j行数据</strong></p><ul><li>查询subject_info的前三行数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from subject_info limit 0,3;</span><br></pre></td></tr></table></figure><ul><li>查询student_info的4到7行数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info limit 3,4;</span><br></pre></td></tr></table></figure><p><strong>2 order by 排序:ASC升序（默认） DESC降序 【重要】</strong></p><ul><li>student_info表中按学费的降序排序，如果学费相同按id升序排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info order by s_tuition DESC, s_id ASC;</span><br></pre></td></tr></table></figure><p><strong>3 where 过滤：（= &gt; &lt; between is null and or in not）</strong></p><ul><li>查询s_tuition&gt;=8000并且s_gender=1的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info where s_tuition&gt;&#x3D;8000 and s_gender &#x3D; 1;</span><br></pre></td></tr></table></figure><ul><li>查询tuition在6000到8000范围内的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info where s_tuition between 6000 and 8000;</span><br></pre></td></tr></table></figure><ul><li>查询s_hometown不为null的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info where s_hometown is not null;</span><br></pre></td></tr></table></figure><p><strong>4 like通配符： %匹配任意数量的字符  _匹配一个字符   [ ]匹配括号内的元素</strong></p><ul><li>查询s_name是“用”开头的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student_info where s_name  like &#39;用%&#39;;</span><br></pre></td></tr></table></figure><p><strong>5 数学函数：count()求数量 max()最大值 sum()求和..等</strong></p><ul><li>查询学费=8000的人的数据 和数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_info WHERE s_tuition &#x3D; 8000; -- 显示两条数据</span><br><span class="line">select *,count(*) from student_info where s_tuition &#x3D; 8000; -- 只显示一条数据，count列&#x3D;2</span><br></pre></td></tr></table></figure><h1 id="五-子查询、分组和连接、分页"><a href="#五-子查询、分组和连接、分页" class="headerlink" title="五 子查询、分组和连接、分页"></a>五 子查询、分组和连接、分页</h1><blockquote><p>考虑到分组和连接比较重要，单独拿出一章来介绍和了解</p></blockquote><h2 id="5-1-子查询"><a href="#5-1-子查询" class="headerlink" title="5.1 子查询"></a>5.1 子查询</h2><p><strong>子查询中只能返回一个字段的数据。</strong></p><p>==1 可以将子查询的结果作为 WHRER 语句的过滤条件。这个懂==</p><ul><li>比如我要查出来sub_id=4的专业的所有学生姓名和家乡<ul><li>从student_subject中找到这个sub_id对应的学生s_id</li><li>然后从student_info表中根据这个s_id找到姓名和家乡</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s_name,s_hometown FROM student_info WHERE s_id IN</span><br><span class="line">(SELECT s_id FROM student_subject  WHERE sub_id &#x3D; 4</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果要进一步查具体某个专业，就要再嵌套一层子查询</p><ul><li>比如我要查出来sub_name=News专业的所有学生姓名和家乡<ul><li>要先从subject_info中找到News专业对应的sub_id</li><li>然后从student_subject中找到这个sub_id对应的学生s_id</li><li>最后从student_info表中根据这个s_id找到姓名和家乡</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s_name,s_hometown from student_info where s_id in</span><br><span class="line">(select s_id from student_subject where sub_id &#x3D; </span><br><span class="line"> ( select sub_id from subject_info where sub_name &#x3D; &#39;News&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>也就是说：我最后查得的数据，只能是一个表内的，子查询顶多给我做了一个筛选的功能。（不知道这个理解对不对）</strong></p><p>==2 子查询还有一个功能！！就是将子查询放在查询字段中时，会对每一行查询的结果都做一次子查询！！==</p><ul><li>比如我要查每个专业分别有几个同学<ul><li>我可以先写查某一个具体的专业有几个人</li><li>然后嵌套进查所有专业的语句中、实现差所有专业的人数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 查Math专业有几个人</span><br><span class="line">select count(*) nums from student_subject where sub_id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">## 查所有的专业</span><br><span class="line">select sub_name, sub_id from subject_info;</span><br><span class="line"></span><br><span class="line">## 嵌套子查询 每个抓专业有多少人 用where连接两个表</span><br><span class="line">select sub_name, sub_id,</span><br><span class="line">(select count(*) from student_subject where student_subject.sub_id&#x3D; subject_info.sub_id) nums</span><br><span class="line">from subject_info;</span><br></pre></td></tr></table></figure><h2 id="5-2-分组group-by"><a href="#5-2-分组group-by" class="headerlink" title="5.2 分组group by"></a>5.2 分组group by</h2><p><strong>1 group by理解</strong></p><p>我之前一直疑惑一个问题：<strong>group by 排完序之后到底变成了一个怎样的表？</strong></p><ul><li><p>==分组操作执行之后：每一行代表一个分组，每个分组只显示第一个数据==</p></li><li><p>可以用count(*) nums求每一个分组内元素的个数</p></li><li><p>还可以用HAVING nums&gt;6; 过滤分组中的字段</p></li><li><p>如果group by后面只有一个字段就是只按这一个字段的来分组，如果group by后面有多个字段，那需要这些字段都相同才是一个分组！！</p></li></ul><p>两个重要的要求：</p><ul><li><strong>除了count()等字段外，SELECT 语句中要查的每一字段都必须在 GROUP BY 子句中给出</strong><ul><li>关系数据库就是基于关系的，单元格中是不允许有多个值的，只对一个字段分组了，那么就只有该列不是重复的！！如果执行select * 就会报错！！</li><li>聚合函数比如count()、sum()、就是将一组内的多个数据计算输出一个数据</li></ul></li><li><strong>where要用在group之前，having要用在group之后</strong><ul><li>WHERE 过滤行数据，HAVING 过滤分组，行过滤应当先于分组过滤。</li></ul></li></ul><p><strong>2 group by练习</strong></p><ul><li>按s_tuition分组，学费相同的为一组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select s_tuition from student_info group by s_tuition;</span><br><span class="line">SELECT s_name,s_tuition,COUNT(*) nums FROM student_info GROUP BY s_tuition;</span><br></pre></td></tr></table></figure><ul><li>按s_gender分组，性别相同的为一组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s_gender from student_info group by s_gender;</span><br><span class="line">-- 我用的这个版本没有报错，显示了该分组第一行的所有数据。</span><br><span class="line">select * from student_info group by s_gender; </span><br><span class="line">select * ,count(*) nums from student_info group by s_gender; -- 显示数据个数</span><br></pre></td></tr></table></figure><h2 id="5-3-连接-join【重点】"><a href="#5-3-连接-join【重点】" class="headerlink" title="5.3 连接 join【重点】"></a>5.3 连接 join【重点】</h2><p>连接用于连接多个表，使用 <code>join</code> 关键字，并且条件语句使用 <code>on</code> ！！！连接一般可以用来替代子查询！！使用超级频繁</p><p>三种连接方式：内连接、左连接、右连接</p><ul><li>内连接：就是只有两个表都不为null的数据才能显示出来（取交集）inner join</li><li>左连接：以左表为主表（左边表的数据全显示）、右表中无对应数据的显示为null</li><li>右连接：以右表为主表（右边表的数据全显示）、左表中无对应数据的显示为null</li></ul><p>一般会一个就好了，就练习左连接吧</p><ul><li>查询所有学生的s_id、sub_id和sub_name，很显然要连接student_subject和表subjct_info</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.s_id,b.sub_id,c.sub_name from</span><br><span class="line">student_subject b left join subject_info c</span><br><span class="line">    on b.sub_id &#x3D; c.sub_id;</span><br></pre></td></tr></table></figure><ul><li>再看看把subject_info放在前面会怎么样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.s_id,b.sub_id,c.sub_name FROM</span><br><span class="line">subject_info c LEFT JOIN student_subject b</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id;</span><br><span class="line">-- 发现结果基本一样（因为都不为空）</span><br><span class="line">-- 只是数据的排序方式不一样（似乎是按副表的字段排序的）</span><br></pre></td></tr></table></figure><ul><li>我试一下吧三个表都连接起来看看!!</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#先连接bc两个表</span><br><span class="line">(select b.s_id, b.s_grade,b.sub_id,c.sub_name from</span><br><span class="line">student_subject b left join subject_info c</span><br><span class="line">on b.sub_id &#x3D; c.sub_id) bc</span><br><span class="line">#然后连接a表和bc表</span><br><span class="line">select a.s_id,a.s_name,a.s_gender,a.s_hometown,a.s_tuition,</span><br><span class="line">bc.s_grade,bc.sub_id,bc.sub_name from</span><br><span class="line">student_info a left join </span><br><span class="line">(select b.s_id, b.s_grade,b.sub_id,c.sub_name from</span><br><span class="line">student_subject b left join subject_info c</span><br><span class="line">on b.sub_id &#x3D; c.sub_id) bc</span><br><span class="line">on a.s_id&#x3D;bc.s_id;</span><br><span class="line">-- 居然还成功了</span><br></pre></td></tr></table></figure><h2 id="5-4-分页查询"><a href="#5-4-分页查询" class="headerlink" title="5.4 分页查询"></a>5.4 分页查询</h2><blockquote><p>参考文章<a href="https://www.cnblogs.com/endv/p/12275043.html">https://www.cnblogs.com/endv/p/12275043.html</a></p></blockquote><h1 id="六-终极查询练习"><a href="#六-终极查询练习" class="headerlink" title="六 终极查询练习"></a>六 终极查询练习</h1><blockquote><p>找男生人数最多的两个专业和人数！！</p></blockquote><p>其实就可以用我上面那个查出来的大表，先筛选出男生的行，然后以专业分组、计算数量排序然后取前两个就好</p><ul><li>1 先连接形成大表</li><li>2 where筛选出s_gender=1，所有的男生</li><li>3 用group by对sub_name分组，并求每个分组的数量count(*) nums</li><li>4 用order by对nums降序排列</li><li>5 limit 0,2找出前两行数据！！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.s_id,a.s_name,a.s_gender,a.s_hometown,a.s_tuition,</span><br><span class="line">bc.s_grade,bc.sub_id,bc.sub_name,COUNT(*) nums FROM</span><br><span class="line">student_info a LEFT JOIN </span><br><span class="line">(SELECT b.s_id, b.s_grade,b.sub_id,c.sub_name FROM</span><br><span class="line">student_subject b LEFT JOIN subject_info c</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id) bc</span><br><span class="line">ON a.s_id&#x3D;bc.s_id</span><br><span class="line">WHERE s_gender &#x3D; 1</span><br><span class="line">GROUP BY sub_name</span><br><span class="line">ORDER BY nums DESC</span><br><span class="line">LIMIT 0,2;</span><br><span class="line">-- 总感觉这么直接连接不太优雅</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212713.png" alt="image-20210827010908573"></p><h1 id="七-表的索引"><a href="#七-表的索引" class="headerlink" title="七 表的索引"></a>七 表的索引</h1><blockquote><p>数据量较大时，建立和使用提高效率。</p><p>本机创建千万级别的数据表单，用于测试</p></blockquote><h1 id="附录：所有sql语句"><a href="#附录：所有sql语句" class="headerlink" title="附录：所有sql语句"></a>附录：所有sql语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">## 创建student_info表并插入数据</span><br><span class="line">CREATE TABLE student_info (</span><br><span class="line">s_id INT PRIMARY KEY NOT NULL,</span><br><span class="line">s_name VARCHAR(30) NOT NULL,</span><br><span class="line">s_gender INT NOT NULL DEFAULT 1,</span><br><span class="line">s_hometown VARCHAR(50),</span><br><span class="line">s_tuition INT</span><br><span class="line">);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_hometown,s_tuition) VALUES(1,&#39;吴康&#39;,1,&#39;湖南长沙&#39;,8000);</span><br><span class="line">INSERT INTO student_info VALUES(2,&#39;落风&#39;,1,&#39;湖北武汉&#39;,5000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(3,&#39;用户1&#39;,1,6000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(4,&#39;用户2&#39;,1,6000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(5,&#39;妹子1&#39;,2,8000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(6,&#39;妹子2&#39;,2,5000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(7,&#39;妹子3&#39;,2,4000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(8,&#39;妹子4&#39;,2,5000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(9,&#39;妹子5&#39;,2,9000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(10,&#39;妹子6&#39;,2,5000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(11,&#39;用户3&#39;,1,4000);</span><br><span class="line">INSERT INTO student_info(s_id,s_name,s_gender,s_tuition) VALUES(12,&#39;用户4&#39;,1,5000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建 student_subject 表</span><br><span class="line">CREATE TABLE student_subject(</span><br><span class="line">s_id INT PRIMARY KEY NOT NULL,</span><br><span class="line">s_grade INT NOT NULL DEFAULT 60,</span><br><span class="line">sub_id INT NOT NULL</span><br><span class="line">);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(1,80,1);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(2,59,1);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(3,60,2);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(4,40,2);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(5,80,3);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(6,75,4);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(7,80,4);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(8,90,4);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(9,80,3);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(10,95,3);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(11,96,4);</span><br><span class="line">INSERT INTO student_subject(s_id,s_grade,sub_id) VALUES(12,80,1);</span><br><span class="line"></span><br><span class="line"># 创建 subject_info表</span><br><span class="line">CREATE TABLE subject_info(</span><br><span class="line">sub_id INT PRIMARY KEY NOT NULL,</span><br><span class="line">sub_name VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line">INSERT INTO subject_info(sub_id,sub_name) VALUES(1, &#39;Math&#39;);</span><br><span class="line">INSERT INTO subject_info(sub_id,sub_name) VALUES(2, &#39;English&#39;);</span><br><span class="line">INSERT INTO subject_info(sub_id,sub_name) VALUES(3, &#39;Computer&#39;);</span><br><span class="line">INSERT INTO subject_info(sub_id,sub_name) VALUES(4, &#39;News&#39;);</span><br><span class="line">INSERT INTO subject_info(sub_id,sub_name) VALUES(5, &#39;civil enginering&#39;);</span><br><span class="line"># 更新和删除</span><br><span class="line">UPDATE student_info SET s_hometown &#x3D; &#39;湖北荆州&#39; WHERE s_id &#x3D; 1;</span><br><span class="line">DELETE FROM subject_info WHERE sub_id &#x3D; 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## limit</span><br><span class="line">SELECT * FROM subject_info LIMIT 0,3;</span><br><span class="line">SELECT * FROM student_info LIMIT 3,4;</span><br><span class="line">## order by</span><br><span class="line">SELECT * FROM student_info ORDER BY s_tuition DESC, s_id ASC;</span><br><span class="line">## where</span><br><span class="line">SELECT * FROM student_info WHERE s_tuition&gt;&#x3D;8000 AND s_gender &#x3D; 1;</span><br><span class="line">SELECT * FROM student_info WHERE s_tuition BETWEEN 6000 AND 8000;</span><br><span class="line">SELECT * FROM student_info WHERE s_hometown  IS  NOT NULL;</span><br><span class="line">SELECT * FROM student_info WHERE s_name  LIKE &#39;用%&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student_info WHERE s_tuition &#x3D; 8000;</span><br><span class="line">SELECT *,COUNT(*) FROM student_info WHERE s_tuition &#x3D; 8000;</span><br><span class="line"></span><br><span class="line">## group by</span><br><span class="line">SELECT s_name,s_tuition,COUNT(*) nums FROM student_info GROUP BY s_tuition;</span><br><span class="line">SELECT s_gender FROM student_info GROUP BY s_gender;</span><br><span class="line">SELECT *  nums FROM student_info GROUP BY s_gender;</span><br><span class="line">SELECT * ,COUNT(*) nums FROM student_info GROUP BY s_gender;</span><br><span class="line"></span><br><span class="line">## 子查询</span><br><span class="line">SELECT s_name,s_hometown FROM student_info WHERE s_id IN</span><br><span class="line">(SELECT s_id FROM student_subject  WHERE sub_id &#x3D; 4</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) nums FROM student_subject WHERE sub_id &#x3D; 1;</span><br><span class="line">SELECT sub_name, sub_id FROM subject_info;</span><br><span class="line"></span><br><span class="line">SELECT sub_name, sub_id,</span><br><span class="line">(SELECT COUNT(*) FROM student_subject WHERE student_subject.sub_id&#x3D; subject_info.sub_id) nums</span><br><span class="line">FROM subject_info;</span><br><span class="line"></span><br><span class="line">## left join...on</span><br><span class="line">SELECT b.s_id,b.sub_id,c.sub_name FROM</span><br><span class="line">student_subject b LEFT JOIN subject_info c</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id;</span><br><span class="line"></span><br><span class="line">SELECT b.s_id,b.sub_id,c.sub_name FROM</span><br><span class="line">subject_info c  LEFT JOIN student_subject b</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id;</span><br><span class="line"></span><br><span class="line">SELECT a.s_id,a.s_name,a.s_gender,a.s_hometown,a.s_tuition,</span><br><span class="line">bc.s_grade,bc.sub_id,bc.sub_name FROM</span><br><span class="line">student_info a LEFT JOIN </span><br><span class="line">(SELECT b.s_id, b.s_grade,b.sub_id,c.sub_name FROM</span><br><span class="line">student_subject b LEFT JOIN subject_info c</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id) bc</span><br><span class="line">ON a.s_id&#x3D;bc.s_id;</span><br><span class="line"></span><br><span class="line">## 终极查询：找男生人数最多的两个专业和人数</span><br><span class="line">SELECT a.s_id,a.s_name,a.s_gender,a.s_hometown,a.s_tuition,</span><br><span class="line">bc.s_grade,bc.sub_id,bc.sub_name,COUNT(*) nums FROM</span><br><span class="line">student_info a LEFT JOIN </span><br><span class="line">(SELECT b.s_id, b.s_grade,b.sub_id,c.sub_name FROM</span><br><span class="line">student_subject b LEFT JOIN subject_info c</span><br><span class="line">ON b.sub_id &#x3D; c.sub_id) bc</span><br><span class="line">ON a.s_id&#x3D;bc.s_id</span><br><span class="line">WHERE s_gender &#x3D; 1</span><br><span class="line">GROUP BY sub_name</span><br><span class="line">ORDER BY nums DESC</span><br><span class="line">LIMIT 0,2;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;基础SQL命令记录、以及一个简单的例子作为参考&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://wukang555.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://wukang555.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点</title>
    <link href="https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_02_mysql%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_02_mysql%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-05-19T15:55:00.000Z</published>
    <updated>2022-05-19T01:59:35.059Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL知识点总结：索引、架构、锁、事物、隔离级别。</p><a id="more"></a><blockquote><p>[1] <a href="https://blog.csdn.net/a303549861/article/details/100302267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-19.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-19.control">参考了CSDN上一个大佬关于MySQL的面经总结</a></p><p>[2] <a href="http://www.cyc2018.xyz/#%E6%95%B0%E6%8D%AE%E5%BA%93">参考了cyc2018大佬主页</a></p><p>[3] <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95?id=%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95">参考了JavaGuide的数据库索引文章</a></p></blockquote><p>说实话现在只会背背事务及隔离级别、各种锁的面经，但数据库底层的实现仍然是一无所知，<code>Innodb</code>引擎那本书也还没看到重点部分，权且先用大佬通俗的文章先理解一下，三个重点：</p><ul><li>索引</li><li>MySQL的基础架构 一条sql语句的执行过程</li><li>锁</li><li>事务和隔离级别</li><li>不同存储引擎的区别（面经）</li></ul><h1 id="1-索引"><a href="#1-索引" class="headerlink" title="1 索引"></a>1 索引</h1><h2 id="1-1-索引的定义、使用场景"><a href="#1-1-索引的定义、使用场景" class="headerlink" title="1.1 索引的定义、使用场景"></a>1.1 索引的定义、使用场景</h2><p><strong>什么是索引？</strong></p><p>索引，是数据库管理系统中一个排好序的数据结构，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。</p><p>MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。</p><p>（where后面出现的列都是索引么？索引跟主键有什么区别和关系）</p><p> <strong>索引有什么好处？</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li></ul><p><strong>索引有什么坏处？</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><p><strong>索引的使用场景？</strong></p><ul><li>1、对非常小的表，大部分情况下全表扫描效率更高。</li><li>2、对中大型表，索引非常有效。</li><li>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</li></ul><p><strong>表的两种切分方式：</strong></p><ul><li><p>水平切分Sharding ：它是将同一个表中的记录拆分到多个结构相同的表中。</p><ul><li>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</li></ul></li><li><p>垂直切分：垂直切分是将一张表按列切分成多个表</p><ul><li><p>通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p></li><li><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p></li></ul></li></ul><blockquote><p>实际场景下，MySQL 分区表很少使用，原因可以看看 <a href="https://blog.csdn.net/admin1973/article/details/55504018">《互联网公司为啥不使用 MySQL 分区表？》</a> 文章。</p><p>对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p></blockquote><h2 id="1-2-索引按应用层次分类"><a href="#1-2-索引按应用层次分类" class="headerlink" title="1.2 索引按应用层次分类"></a>1.2 索引按应用层次分类</h2><p>索引，都是实现在存储引擎层的。根据应用层次分为六种类型：</p><p>1、普通索引：最基本的索引，允许重复和为null。</p><p>2、唯一索引：与普通索引类似，允许为空，但具有唯一性约束。（主键索引是特殊的唯一索引，不允许有空值。）</p><p>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</p><p>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</p><p>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</p><blockquote><p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。</p></blockquote><p>具体的使用，可以看看 <a href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/">《服务端指南 数据存储篇 | MySQL（03） 如何设计索引》</a> 。</p><p>==有一个问题：外键索引究竟是什么？前缀索引又是什么？最左匹配是什么？==</p><h2 id="1-3-索引的底层实现（数据结构）"><a href="#1-3-索引的底层实现（数据结构）" class="headerlink" title="1.3 索引的底层实现（数据结构）"></a>1.3 索引的底层实现（数据结构）</h2><p>索引根据存储结构来分，索引分为 <strong>BTree索引（B-Tree或B+Tree索引），Hash索引</strong>，full-index全文索引，R-Tree索引。</p><p><strong>Hash索引</strong> ：哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据。</p><p><strong>B-Tree索引</strong>：B树的数据结构，数据分布在各个节点之上</p><p><strong>B+Tree索引</strong>：B+树的数据结构，所有数据分布在叶子节点上、非终端节点看成是索引部分</p><blockquote><p>回头看看大话数据结构的B树去了</p></blockquote><h3 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212727.png" alt="img"></p><p>既然哈希表查找这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong>有两点</p><ul><li>1 Hash 冲突问题（hash冲突不是主要的问题），hash冲突可以通过链地址法、再散列函数法等方法解决</li><li>2 Hash 索引不支持顺序和范围查询（最大的缺点），比如下面的的范围查找</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br><span class="line"># Hash 索引是根据 hash 算法来定位的，范围查找时难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?</span><br></pre></td></tr></table></figure><h3 id="两种B树索引的区别"><a href="#两种B树索引的区别" class="headerlink" title="两种B树索引的区别"></a>两种B树索引的区别</h3><ul><li>B+树的检索更为稳定<ul><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul></li><li>B+树的叶子结点包含全部关键字信息更适合于顺序检索，范围检索<ul><li>1要排序遍历的话，直接从左到右遍历叶子节点</li><li>2 适合带范围的查找：先从根节点出发找到最小值的位置，但后定位到叶子节点中，一直遍历找直到找到最大值</li></ul></li></ul><h2 id="1-4-索引存储位置的分类"><a href="#1-4-索引存储位置的分类" class="headerlink" title="1.4 索引存储位置的分类"></a>1.4 索引存储位置的分类</h2><p><strong>索引按索引表存放的位置分为聚集索引和非聚集索引</strong></p><h3 id="1-4-1-聚集索引"><a href="#1-4-1-聚集索引" class="headerlink" title="1.4.1 聚集索引"></a>1.4.1 聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。==主键索引属于聚集索引==。</strong></p><p>聚集索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的<strong>数据</strong>。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212732.png" alt="img" style="zoom: 50%;"><p>聚集索引的优点：</p><ul><li>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</li></ul><p>聚集索引的缺点：</p><ul><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h3 id="1-4-2-非聚集索引"><a href="#1-4-2-非聚集索引" class="headerlink" title="1.4.2 非聚集索引"></a>1.4.2 非聚集索引</h3><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong> 唯一索引，普通索引，前缀索引等索引都属于二级索引（辅助索引），二级索引属于非聚集索引。</p><p>二级索引的叶子节点存放的是主键，一般查到主键后再回表查数据。(大部分是，也不绝对)</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212737.png" alt="img" style="zoom:50%;"><p>非聚集索引的优点：</p><ul><li><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</li></ul><p>非聚集索引的缺点：</p><ul><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><h3 id="1-4-3-非聚集索引一定要回表查询？"><a href="#1-4-3-非聚集索引一定要回表查询？" class="headerlink" title="1.4.3 非聚集索引一定要回表查询？"></a>1.4.3 非聚集索引一定要回表查询？</h3><p><strong>非聚集索引不一定回表查询。</strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么非聚集索引也可以一次得到所需的字段，无需回表查询</p><blockquote><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name&#x3D;&#39;guang19&#39;;</span><br></pre></td></tr></table></figure><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p></blockquote><h2 id="1-5-创建索引的注意事项"><a href="#1-5-创建索引的注意事项" class="headerlink" title="1.5 创建索引的注意事项"></a>1.5 创建索引的注意事项</h2><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><p><strong>4.注意避免冗余索引</strong> 。</p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h1 id="2-MySQL的基础架构"><a href="#2-MySQL的基础架构" class="headerlink" title="2 MySQL的基础架构"></a>2 MySQL的基础架构</h1><blockquote><p>本节完全参考了<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84">一条SQL语句是如何执行的</a>文章，作者：木木匠</p></blockquote><p>本篇文章会分析下一个 SQL语句在 MySQL 中的执行流程，但在分析之前需要先了解 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解SQL语句的执行过程。</p><h2 id="2-1-MySQL-基本架构概览"><a href="#2-1-MySQL-基本架构概览" class="headerlink" title="2.1 MySQL 基本架构概览"></a>2.1 MySQL 基本架构概览</h2><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p><ul><li><strong>连接器：</strong>身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong>按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器：</strong>执行语句，然后从存储引擎返回数据。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212741" alt="img" style="zoom: 50%;"><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li></ul><h2 id="2-2-查询语句分析"><a href="#2-2-查询语句分析" class="headerlink" title="2.2 查询语句分析"></a>2.2 查询语句分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_student A where A.age&#x3D;&#39;18&#39; and A.name&#x3D;&#39; 张三 &#39;;</span><br></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ul><li><p>1 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>2 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>3 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>4 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h2 id="2-3-更新语句分析"><a href="#2-3-更新语句分析" class="headerlink" title="2.3 更新语句分析"></a>2.3 更新语句分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_student A set A.age&#x3D;&#39;19&#39; where A.name&#x3D;&#39; 张三 &#39;;</span><br></pre></td></tr></table></figure><p>其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>1 先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li><li>2 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>3 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>4 更新完成。</li></ul><blockquote><p>redo log 是 InnoDB 引擎特有的，因此InooDB也有了crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p></blockquote><p>redo log的两阶段提交的方式是为了保证一致性！！，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li></ul><h1 id="3-数据库的锁"><a href="#3-数据库的锁" class="headerlink" title="3 数据库的锁"></a>3 数据库的锁</h1><blockquote><p>完全参考了木木匠的开源项目中的文章<a href="https://github.com/javagrowing/JGrowing/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%EF%BC%9F.md"><strong>为什么开发人员必须要了解数据库锁？</strong></a></p></blockquote><p>锁在数据库中其功能之一也是用来实现事务隔离性。而隔离性是为了解决脏读、不可重复读、和幻读几类问题。事务的隔离性这里就先不讲了。直接看InnoDB中有哪些锁吧</p><h2 id="3-1-InnoDB锁的类型"><a href="#3-1-InnoDB锁的类型" class="headerlink" title="3.1 InnoDB锁的类型"></a>3.1 InnoDB锁的类型</h2><p>小明首先了解一下Mysql中常见的锁类型有哪些:</p><h3 id="2-3-1-S-or-X-（行锁）"><a href="#2-3-1-S-or-X-（行锁）" class="headerlink" title="2.3.1 S or X （行锁）"></a>2.3.1 S or X （行锁）</h3><p>在InnoDb中实现了两个标准的行级锁，可以简单的看为两个读写锁:</p><ul><li>S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。</li><li>X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了。</li></ul><blockquote><p>兼容性:是指事务A获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。</p></blockquote><p>纵轴是代表已有的锁，横轴是代表尝试获取的锁。只有读锁和读锁同时兼容</p><table><thead><tr><th align="center">已有锁\ 尝试锁</th><th>X</th><th>S</th></tr></thead><tbody><tr><td align="center"><strong>X</strong></td><td>冲突</td><td>冲突</td></tr><tr><td align="center"><strong>S</strong></td><td>冲突</td><td>兼容</td></tr></tbody></table><h3 id="2-3-2-IS-or-IX（意向锁-表锁）"><a href="#2-3-2-IS-or-IX（意向锁-表锁）" class="headerlink" title="2.3.2 IS or IX（意向锁\表锁）"></a>2.3.2 IS or IX（意向锁\表锁）</h3><p>意向锁在InnoDB中是表级锁,和他的名字一样他是用来表达一个事务想要获取什么。其实就是先为表锁打一个标记！！意向锁分为:</p><ul><li>意向共享锁 IS:表达一个事务想要获取一张表中某几行的共享锁。</li><li>意向排他锁 IX:表达一个事务想要获取一张表中某几行的排他锁。</li></ul><p>这个锁有什么用呢？为什么需要这个锁呢？ 首先说一下如果没有这个锁，如果要给这个表加上表锁，一般的做法是去遍历每一行看看他是否有行锁，这样的话效率太低，而我们有意向锁，只需要判断是否有意向锁即可，不需要再去一行行的去扫描。</p><p><strong>因此 IS 和 IX 的作用就是在上表级锁的时候，可以快速判断是否可以上锁，而不需要遍历表中的所有记录。</strong></p><p>在InnoDB中由于支持的是行级的锁，因此InnboDB锁的兼容性可以扩展如下：</p><table><thead><tr><th>.</th><th>IX</th><th>IS</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>IX</td><td>兼容</td><td>兼容</td><td>冲突</td><td>冲突</td></tr><tr><td>IS</td><td>兼容</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>S</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr></tbody></table><h3 id="2-3-3-自增长锁（还是有点没看懂）"><a href="#2-3-3-自增长锁（还是有点没看懂）" class="headerlink" title="2.3.3 自增长锁（还是有点没看懂）"></a>2.3.3 自增长锁（还是有点没看懂）</h3><p>自增长锁是一种特殊的表锁机制，<strong>提升并发插入性能</strong>。对于这个锁有几个特点:</p><ul><li>在sql执行完就释放锁，并不是事务执行完。</li><li>对于Insert…select大数据量插入会影响插入性能，因为会阻塞另外一个事务执行。</li><li>自增算法可以配置。</li></ul><p>在MySQL5.1.2版本之后，有了很多优化，可以根据不同的模式来进行调整自增加锁的方式。小明看到了这里打开了自己的MySQL发现是5.7之后，于是便输入了下面的语句,获取到当前锁的模式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_autoinc_lock_mode&#39;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_autoinc_lock_mode | 2     |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在MySQL中innodb_autoinc_lock_mode有3种配置模式：0、1、2，分别对应”传统模式”, “连续模式”, “交错模式”。</p><ul><li><p>0 传统模式:也就是我们最上面的使用表锁。</p></li><li><p>1 连续模式:对于插入的时候可以确定行数的使用互斥量，对于不能确定行数的使用表锁的模式。</p></li><li><p>2 交错模式:所有的都使用互斥量，为什么叫交错模式呢，有可能在批量插入时自增值不是连续的，当然一般来说如果不看重自增值连续一般选择这个模式，性能是最好的。</p></li></ul><h2 id="3-2-InnoDB锁算法"><a href="#3-2-InnoDB锁算法" class="headerlink" title="3.2 InnoDB锁算法"></a>3.2 InnoDB锁算法</h2><h3 id="2-4-1-记录锁-Record-Lock"><a href="#2-4-1-记录锁-Record-Lock" class="headerlink" title="2.4.1 记录锁(Record-Lock)"></a>2.4.1 记录锁(Record-Lock)</h3><p>记录锁是锁住记录的，这里要说明的是这里<strong>锁住的是索引记录，而不是我们真正的数据记录。</strong></p><ul><li>如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住.</li><li>如果没有表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁。</li><li>如果要锁的列没有索引，则会进行全表记录加锁。</li></ul><h3 id="2-4-2-间隙锁（gap锁）"><a href="#2-4-2-间隙锁（gap锁）" class="headerlink" title="2.4.2 间隙锁（gap锁）"></a>2.4.2 间隙锁（gap锁）</h3><p>间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫gap锁，gap锁之间不会相互阻塞，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。</p><p><strong>要给此时还未存在的记录加锁怎么办？加间隙锁！！防止幻读！！</strong></p><blockquote><p>如下图：有两个间隙锁，相互之间不阻塞。但对间隙之中的元素起保护作用</p></blockquote><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212748" alt="img" style="zoom: 50%;"><h3 id="3-2-3-next-key锁"><a href="#3-2-3-next-key锁" class="headerlink" title="3.2.3 next-key锁"></a>3.2.3 next-key锁</h3><p>这个锁本质是记录锁加上gap锁。在RR隔离级别下(InnoDB默认)，Innodb对于行的扫描锁定都是使用此算法，但是如果查询扫描中有唯一索引会退化成只使用记录锁。为什么呢? 因为唯一索引能确定行数，而其他索引不能确定行数，有可能在其他事务中会再次添加这个索引的数据会造成幻读。</p><h3 id="3-2-4-插入意向锁"><a href="#3-2-4-插入意向锁" class="headerlink" title="3.2.4 插入意向锁"></a>3.2.4 插入意向锁</h3><p>插入意向锁是在插入数据的时候产生的。 如果持有插入意向锁。在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个<strong>记录索引</strong>包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p><p>某个间隙被锁住之后，可以插入一个”插入意向锁“，表示在等待这个间隙被释放。</p><blockquote><p>这里要说明的是如果有间隙锁了，插入意向锁会被阻塞。</p></blockquote><h2 id="3-3-加锁实验"><a href="#3-3-加锁实验" class="headerlink" title="3.3 加锁实验"></a>3.3 加锁实验</h2><p>因为事务之间是隔离的，可以通过两个事务来研究不同锁之间的冲突。</p><p><strong>1 事务A查询（使用普通索引），事务B对不同行数据做插入操作</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212751" alt="img" style="zoom:50%;"><p>发现在事务A中给555加了Next-key锁，事务B插入的时候会首先进行插入意向锁的插入，于是得出下面结论:可以看见事务B由于间隙锁和插入意向锁的冲突，导致了阻塞。</p><p><strong>2 事务A查询（使用唯一索引），事务B对不同行数据做插入操作</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212754" alt="img" style="zoom:50%;"><p>发现事务B并没有发生阻塞，，因为唯一索引会降级记录锁，这么做的理由是:非唯一索引加next-key锁由于不能确定明确的行数有可能其他事务在你查询的过程中，再次添加这个索引的数据，导致隔离性遭到破坏，也就是幻读。唯一索引由于明确了唯一的数据行，所以不需要添加间隙锁解决幻读。</p><p><strong>3 事务A查询（没有使用索引），事务B对不同行数据做插入操作</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212757" alt="img" style="zoom:50%;"><p>小明一看哎哟我去，这个咋回事呢，咋不管是用实验1非间隙锁范围的数据，还是用间隙锁里面的数据都不行，难道是加了表锁吗？</p><p>的确，如果用没有索引的数据，其会对所有聚簇索引上都加上next-key锁。</p><p>所以大家平常开发的时候如果对查询条件没有索引的，一定进行一致性读，也就是加锁读，会导致全表加上索引，会导致其他事务全部阻塞，数据库基本会处于不可用状态。</p><h2 id="3-4-解决项目中的死锁问题"><a href="#3-4-解决项目中的死锁问题" class="headerlink" title="3.4 解决项目中的死锁问题"></a>3.4 解决项目中的死锁问题</h2><blockquote><p>undo较小的事务是啥？（就是回滚不重要的事务呗）</p></blockquote><p>死锁:是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。说明有等待才会有死锁，解决死锁可以通过去掉等待，比如回滚事务。</p><p>解决死锁的两个办法:</p><ol><li>等待超时:当某一个事务等待超时之后回滚该事务，另外一个事务就可以执行了，但是这样做效率较低，会出现等待时间，还有个问题是如果这个事务所占的权重较大，已经更新了很多数据了，但是被回滚了，就会导致资源浪费。</li><li>等待图(wait-for-graph): 等待图用来描述事务之间的等待关系，当这个图如果出现回路如下:就出现回滚，通常来说InnoDB会选择回滚权重较小的事务，也就是undo较小的事务。</li></ol><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212801" alt="img" style="zoom: 50%;"><h1 id="4-事务和隔离级别"><a href="#4-事务和隔离级别" class="headerlink" title="4 事务和隔离级别"></a>4 事务和隔离级别</h1><blockquote><p>这里先用我之前幕布上的笔记</p></blockquote><h2 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p><strong>事务的ACID特性</strong></p><ul><li>原子性：一个事务中的操作要么都发生（全部提交成功），要么都不发生（全部回滚）。</li><li>一致性：数据库<strong>在事务执行前后</strong>都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li><li>隔离性： 多个事务并发访问时，事务之间是隔离的。就是说一个事务所做的修改在<strong>最终提交以前</strong>，对其它事务是不可见的。</li><li>持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中。即使系统崩溃，事务执行的结果也不会丢失。<ul><li>系统发生崩溃可以通过<strong>重做日志（Redo Log）</strong>进行恢复，与<strong>回滚日志记录数据的逻辑修改</strong>不同，重做日志记录的是数据页的物理修改。</li><li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时<strong>反向执行这些修改操作</strong>即可。</li></ul></li></ul><p><strong>ACID特性之间的关系</strong></p><ul><li><p>只有满足一致性，事务的执行结果才是正确的。</p></li><li><p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</p></li><li><p>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</p></li><li><p>事务满足持久化是为了能应对系统崩溃的情况。</p></li></ul><p><strong>总结：如何满足ACID特性</strong></p><ul><li><p>数据库管理系统采用<strong>日志</strong>来保证事务的原子性、持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p></li><li><p>数据库管理系统采用<strong>锁机制</strong>来实现事务的隔离性。当多个事务同时更新数 据库中相同的数据时，只允许持有锁的事务能更新该数据</p></li><li><p>原子性和隔离性满足之后保证了一致性：即保证执行结果正确；持久性用来应对系统的崩溃</p></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212804.jpg" alt="img" style="zoom: 67%;"><h2 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2 事务日志"></a>4.2 事务日志</h2><blockquote><p>二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入。</p></blockquote><p>MYSQL自带的日志有bin二进制日志、查询日志、慢查询日志</p><ul><li><strong>bin log日志 记录所有更改数据的语句，可用于数据复制。</strong></li><li><strong>错误日志（error log）记录MySQL服务进程mysqld在启动/关闭或运行过程中遇到的错误信息</strong></li><li>普通查询日志（general query log）：记录建立的客户端连接和执行的语句。</li><li>慢查询日志（slow query log）：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询。</li></ul><p>所谓的<strong>事务日志</strong>是指InnoDB引擎的redo log重做日志和undo log回滚日志。 <strong>redo用来保证事务的持久性，通过记录物理修改来恢复数据。 undo保证事务的原子、用来回滚行记录到某个特定的版本。</strong></p><h3 id="4-2-1-redo日志"><a href="#4-2-1-redo日志" class="headerlink" title="4.2.1 redo日志"></a>4.2.1 redo日志</h3><blockquote><p>我这里只需要理解redo是什么就好了，至于如何实现和底层原理、我还不懂</p><p>参考了<a href="https://blog.csdn.net/No_Game_No_Life_/article/details/106718599">这篇文章</a></p></blockquote><p><strong>redo log通常是物理日志，记录的是也得物理修改操作。</strong></p><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p><p><strong>mysql数据库同步数据到磁盘的过程！！</strong></p><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。而buffer pool是在内存里的，如果还没来的同步的时候宕机或断电了，就会导致丢失部分已提交事务的修改信息。</p><p>所以引入了redo log来记录已成功提交事务的修改信息，宕机之后，系统重启后读取redo log恢复最新数据。虽然redo log也有内存buffer缓冲的部分，如果要严格保证数据不丢失，就要在事务提交前做一次磁盘写入，但是这种IO操作相比于buffer pool这种以页（16kb）为管理单位的随机写入，它做的是几个字节的顺序写入，效率要高得多。<strong>（就是说虽然redo也是需要从内存写入磁盘，但它是顺序写入、比直接同步事务要快得多）</strong></p><p>比如下面的操作，从银行卡账户转账到理财账户表：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212808.png" alt="在这里插入图片描述" style="zoom:80%;"><p><strong>redo buffer比 buffer pool快，但redo buffer就不可能丢失事务么？</strong></p><p>当一条 SQL 更新完 Buffer Pool 中的缓存页后，将<strong>修改先写入redo log buffer 的缓存</strong>中，<strong>然后</strong>在某一个合适的时间点，将这条 <strong>redo log buffer中的修改刷入到磁盘redo log</strong>中。(其中还涉及到redo log buffer 内部是划分为许多 redo log block，每次刷新的是redo log block。这里不再详细表述了)</p><p>合适的时间点：</p><p>这个合适的时间点究竟是什么时候呢？</p><ul><li><p>MySQL 正常关闭的时候；</p></li><li><p>MySQL 的后台线程每隔一段时间定时的将 redo log buffer 刷入到磁盘，默认是每隔 1s 刷一次；</p></li><li><p>当 redo log buffer 中的日志写入量超过 redo log buffer 内存的一半时，即超过 8MB 时，会触发 redo log buffer 的刷盘；</p></li><li><p><strong>当事务提交时，根据配置的参数 innodb_flush_log_at_trx_commit 来决定是否刷盘。</strong></p><ul><li>如果innodb_flush_log_at_trx_commit 参数配置为 0，表示事务提交时，不进行 redo log buffer 的刷盘操作；</li><li>如果配置为 1，表示事务提交时，会将此时事务所对应的 redo log 所在的 redo log block 从内存写入到磁盘，同时调用 fysnc，确保数据落入到磁盘；</li><li>如果配置为 2，表示只是将日志写入到操作系统的缓存，而不进行 fysnc 操作。（进程在向磁盘写入数据时，是先将数据写入到操作系统的缓存中：os cache，再调用 fsync 方法，才会将数据从 os cache 中刷新到磁盘上</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212811.png" alt="img"></p><blockquote><p>实际上要严格保证数据不丢失，必须得保证 innodb_flush_log_at_trx_commit 配置为 1。</p><p>innodb_flush_log_at_trx_commit为0，表示事务提交时不需要写入重做日志，而是由master thread来定期完成。<br>innodb_flush_log_at_trx_commit为2，表示事务提交时将重做日志写入重做日志缓存中。这个情况下，MySQL发生宕机但是操作系统没有宕机的情况下，重做是仍然可以进行的</p></blockquote><p><strong>下面介绍将日志同步到磁盘中的最佳实践：两阶段提交！!</strong></p><blockquote><p>如何通过日志实现持久性？</p><p>一言以蔽之：即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的文件中进行持久化。（包括redo log file和undo log file）。持久化又是一个需要经过系统调用的过程。</p><p>因为MySQL是工作在用户空间的，MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，所以必须经过系统调用fsync()操作，才能完成。</p></blockquote><p>更新数据、写入日志的过程：</p><ol><li>MySQL Server 层的执行器调用 InnoDB 存储引擎的数据更新接口；</li><li>存储引擎更新 Buffer Pool 中的缓存页，</li><li>同时存储引擎记录一条 redo log 到 redo log buffer 中，并将该条 redo log 的状态标记为 prepare 状态；</li><li>接着存储引擎告诉执行器，可以提交事务了。执行器接到通知后，会写 binlog 日志，然后提交事务；</li><li>存储引擎接到提交事务的通知后，将 redo log 的日志状态标记为 commit 状态；</li><li>接着根据 innodb_flush_log_at_commit 参数的配置，决定是否将 redo log buffer 中的日志刷入到磁盘。</li></ol><p>将 redo log 日志标记为 prepare 状态和 commit 状态，这种做法称之为两阶段事务提交，它能保证事务在提交后，数据不丢失。为什么呢？redo log 在进行数据重做时，只有读到了 commit 标识，才会认为这条 redo log 日志是完整的，才会进行数据重做，否则会认为这个 redo log 日志不完整，不会进行数据重做。</p><h3 id="4-2-2-undo日志"><a href="#4-2-2-undo日志" class="headerlink" title="4.2.2 undo日志"></a>4.2.2 undo日志</h3><p><strong>undo 称为回滚日志，是一种逻辑日志，是为了保证事务的原子性。</strong></p><ul><li><p>undo log主要记录的是数据的逻辑变化，因此只是将数据库逻辑地恢复到原 来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p></li><li><p>当 InnoDB存储引擎回滚时，它实际上做的是与先前相反的丁作。对于每个INSERT, InnoDB存储引擎会完成一个DELETE; 对于每个 DELETE, InnoDB存储引擎会执行一个INSERT; 对于每个UPDATE, InnoDB存储引擎会执行一个相反的UPDATE, 将修改前的行放回去。</p></li></ul><p><strong>比如一个插入的更新操作：</strong></p><p>用户执行了一个INSERT 10W条记录的事务，这个事务会导致分配新的段，即表空间会增大。在用户执行ROLLBACK时，会将插入的事务进行回滚（即对插入的行进行全部的删除操作），但是表空间的大小事实上还是变大了，只是数据还是那些数据。</p><h3 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h3><p>既然生产环境一般建议将 innodb_flush_log_at_trx_commit 设置为 1，也就是说每次更新数据时，redo log写入磁盘也要发生一次磁盘IO，为什么无直接将数据的修改写入磁盘中，何必引入 redo log 这一机制呢？</p><ul><li>首先 redo log 日志的刷盘时将修改追加到文件末尾，虽然也是一次磁盘 IO，但是这是顺序写操作（<strong>不需要移动磁头</strong>）；而对于直接将数据更新到磁盘，这个操作发生的是随机写操作（<strong>需要移动磁头做寻址</strong>）。</li><li>从另一方面来讲，通常一次更新操作，我们往往只会涉及到修改几个字节的数据，而如果因为仅仅修改几个字节的数据，就将整个数据页写入到磁盘（无论是磁盘还是 buffer pool，他们管理数据的单位都是以页为单位），这个代价未免也太了（每个数据页默认是 16KB），而一条 redo log 日志的大小可能就只有几个字节，因此每次磁盘 IO 写入的数据量更小，那么耗时也会更短。</li></ul><p><strong>redo日志和bin日志的区别！！</strong>？</p><h2 id="4-3-事务并发控制带来的问题"><a href="#4-3-事务并发控制带来的问题" class="headerlink" title="4.3 事务并发控制带来的问题"></a>4.3 事务并发控制带来的问题</h2><ul><li>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题，主要有以下四种：<ul><li><strong>丢失更新</strong>：两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务的更新。</li><li><strong>脏读</strong>： 脏读意味着一个事务T2读取了另一个事务T1未提交的数据，（当T1撤销了这次修改、那么T2读的就是脏数据）</li><li><strong>不可重复读</strong>：同一个事务中，多次读取到的数据不一致（原因是其他事务T2进来对本事务T1的一个数据做了修改、导致T1两次读取结果不一样）</li><li><strong>幻读</strong>：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据（T2想要读取T1的数据，但是T2读取数据之后，T1又对该数据进行了更新导致T2读取的是更新之前的数据）</li></ul></li><li>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。<ul><li>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。</li><li>数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</li></ul></li></ul><h2 id="4-4-事务的隔离级别"><a href="#4-4-事务的隔离级别" class="headerlink" title="4.4 事务的隔离级别"></a>4.4 事务的隔离级别</h2><p>数据库事务的隔离级别有4个，由低到高依次为 <strong>读未提交、读已提交、可重复读、序列化</strong></p><ul><li>读未提交： 如果一个事务已经 开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。<strong>避免了丢失更新</strong>，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。<ul><li>不允许同时写，避免了丢失更新，有脏读</li></ul></li><li>读已提交： 读取数据的事务允许其 他事务继续访问该行数据（写），但是未提交的写事务将会禁止其他事务访问该行。<strong>避免了脏读</strong>，但是却可能出现不可重复读。事务A事先读 取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。<strong>（一般默认的隔离级别）</strong><ul><li>未提交的写禁止其他事物访问，避免了脏读</li></ul></li><li>可重复读：无论是否有其他事务对数据做了修改，一个事务在启动和提交之间读到数据始终是一致的。通常是，读取数据的事务将 会禁止写事务（但允许读事务），写事务则禁止任何其他事务。。这样避免 了<strong>不可重复读和脏读</strong>，但是有时可能出现幻读。<ul><li>只能同时并发读，避免不可重复读，有幻读</li></ul></li><li>序列化：要求事务序列化 执行，事务只能一个接着一个地执行，不能并发执行。序列化是最高的事务隔离级 别，同时代价也最高。。不仅可以<strong>避免脏读、不可重复读，还避免了幻读</strong>。</li></ul><h2 id="4-5-多版本并发控制MVCC"><a href="#4-5-多版本并发控制MVCC" class="headerlink" title="4.5 多版本并发控制MVCC"></a>4.5 多版本并发控制MVCC</h2><blockquote><p>[1] 此小节参考了 <strong>yes的练级攻略</strong> 的文章<a href="https://mp.weixin.qq.com/s/401CeXbEK27pX9dFOOHDnA">关于MySQL的酸与MVCC和面试官小战三十回合</a> 文章幽默有趣、讲的比较深入又十分易懂</p></blockquote><h3 id="4-5-1-什么是MVCC"><a href="#4-5-1-什么是MVCC" class="headerlink" title="4.5.1 什么是MVCC?"></a>4.5.1 什么是MVCC?</h3><p>多版本并发控制（Multi-Version  Concurrency Control ）。指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。</p><p>这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞，写操作可以继续写，无非就是多加了一个版本，历史版本记录可供已经启动的事务读取。</p><p>（为保持简短，简化了SQL语句，下文也同样简化）</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212817" alt="图片" style="zoom: 80%;"><h3 id="4-5-2-MVCC有什么用？"><a href="#4-5-2-MVCC有什么用？" class="headerlink" title="4.5.2 MVCC有什么用？"></a>4.5.2 MVCC有什么用？</h3><p>MVCC 主要可以提高了事务的并发度，提升数据库的性能。</p><p>如果是读未提交的话，直接读最新版本的数据就行了，压根就不需要保存以前的版本。可串行化隔离级别事务都串行执行了，所以也不需要多版本，<strong>因此 MVCC 是用来实现读已提交和可重复读的。</strong></p><ul><li><p>对于<strong>读已提交</strong>：规定只有在写事务只有提交之后，才可以读，不然可能会出现脏读的问题。但是如果有MVCC保存多版本的数据的话、如果A事务在修改时，另一个事务B仍然可以读取旧版本的数据。这样读写就不会阻塞了，提高了事务的并发度。（如果没有的话事务B就会阻塞）</p></li><li><p>对于<strong>可重复读</strong>，MVCC可以和gap间隙锁来防止幻读。（没有MVCC在RR隔离级别下可能出现幻读）</p></li></ul><h3 id="4-5-3-MVCC的实现原理？"><a href="#4-5-3-MVCC的实现原理？" class="headerlink" title="4.5.3 MVCC的实现原理？"></a>4.5.3 MVCC的实现原理？</h3><p>MVCC其实没有存多个版本的数据，索引上对应的记录只有一个版本，但是利用undo日志可以获得之前版本的数据，类似通过undo日志、形成了一个版本链，看起来是多个版本！！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212820" alt="图片" style="zoom: 67%;"><p>举个栗子：三条命令：</p><p>1 一个事务ID为1的事务执行 <code>insert （1，XX）</code>语句执行，并提交</p><p>2 一个事务ID为5的事务执行 <code>update NO where id 1</code> 语句执行，并提交</p><p>3 一个事务ID为11 的事务执行 <code>update Yes where id 1</code> 这个语句，并提交</p><p>最后id=1的这行数据字段分别为（1，Yes)，同时还有 trx_id （当前事务ID）和 roll_pointer(指向undo日志的指针) 这两个隐藏字段。其版本链如下：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212823" alt="图片" style="zoom:67%;"><p>多个版本链还涉及到一个重要的问题，就是当前版本的数据应该对哪些事务可见?</p><blockquote><p>一个原则就是 未提交的数据是不可见的，已提交还未修改的数据是可见的。</p><p>可见版本的判断是从最新版本开始沿着版本链逐渐寻找老的版本，如果遇到符合条件的版本就返回。（因为事务的id是随开始事务的时间而递增的）</p></blockquote><p><strong>readView 用来判断哪个版本对当前事务可见的</strong>，其判断涉及到四个字段值：</p><ul><li>creator_trx_id，当前事务ID。</li><li>m_ids，生成 readView 时还活跃的事务ID集合，也就是已经启动但是还未提交的事务ID列表。</li><li>min_trx_id，当前活跃ID之中的最小值。</li><li>max_trx_id，生成 readView 时 InnoDB 将分配给下一个事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务ID越大）</li></ul><p><strong>判断条件如下：</strong></p><ul><li>如果当前数据版本的 trx_id ==  creator_trx_id 说明修改这条数据的事务就是当前事务，所以可见。</li><li>如果当前数据版本的 trx_id &lt; min_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候已提交，所以可见。</li><li>如果当前数据版本的 trx_id 在 m_ids 中，说明修改这条数据的事务此时还未提交，所以不可见。（还活跃的事务，即未提交，所以不可见）</li><li>如果当前数据版本的 trx_id &gt;= max_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候还未启动，所以不可见(结合事务ID递增来看)。</li></ul><h3 id="4-5-4-可重复读下的MVCC"><a href="#4-5-4-可重复读下的MVCC" class="headerlink" title="4.5.4 可重复读下的MVCC"></a>4.5.4 可重复读下的MVCC</h3><blockquote><p>其实需要先讲一下：读已提交隔离级别下的MVCC，比较简单，一笔带过：</p><p>总是读取到最近的一个已提交的数据，如果两次读取中，有另一个事务提交了，那么第二次读取将会读取到新提交的数据。存在<strong>不可重复读</strong>的并发问题。</p></blockquote><p>读已提交每次查询都会重新生成一个新的 readView ，而可重复读在第一次生成  readView 之后的所有查询都共用同一个 readView 。</p><p>也就是说可重复读只会在第一次 select 时候生成一个 readView ，所以一个事务里面不论有几次 select ，其实看到的都是同一个 readView 。</p><p>因为两次查询用的是同一个readView ，所以不管新事务有没有提交，仍认为它没有提交，查到的还是那个老版本的数据！！所以是可重复读的！！</p><p> undolog 算是热点资源，多个事务会争抢 undolog 。所以为了提高 undolog 的写入性能，每个事务都有属于自己的 undolog 页面链表</p><h1 id="5-其他知识点"><a href="#5-其他知识点" class="headerlink" title="5 其他知识点"></a>5 其他知识点</h1><h2 id="5-1-不同存储引擎的区别"><a href="#5-1-不同存储引擎的区别" class="headerlink" title="5.1 不同存储引擎的区别"></a>5.1 不同存储引擎的区别</h2><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，MySQL 5.5 版本后默认的存储引擎为 InnoDB。</p><p>InnoDB 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p><strong>InnoDB 和MyISAM 的对比</strong></p><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。（InnoDB 有redo日志！！）</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><h2 id="5-2-关系型数据库和非关系型数据库的区别"><a href="#5-2-关系型数据库和非关系型数据库的区别" class="headerlink" title="5.2 关系型数据库和非关系型数据库的区别"></a>5.2 关系型数据库和非关系型数据库的区别</h2><ul><li><p>关系型数据库：</p><ul><li><p>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</p></li><li><p>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</p></li><li><p>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</p></li></ul></li><li><p>非关系型数据库</p><ul><li><p>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</p></li><li><p>面向高性能并发读写的key-value数据库</p></li><li><p>面向可扩展性的分布式数据库</p></li></ul></li></ul><p>数据的持久存储，尤其是海量数据的持久存储，使用的更多的还是关系数据库</p><h2 id="5-3-复合索引的最左前缀原则"><a href="#5-3-复合索引的最左前缀原则" class="headerlink" title="5.3 复合索引的最左前缀原则"></a>5.3 复合索引的最左前缀原则</h2><blockquote><p>最左前缀法则：带头大哥不能死、中间兄弟不能断；如果是全值匹配查询时，顺序无所谓；</p><p>参考了神文<a href="https://blog.csdn.net/sinat_41917109/article/details/88944290">Mysql最左匹配原则</a> 写的真是太好了</p></blockquote><p>索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212828.png" alt="img" style="zoom:67%;"><p>也就是说：索引a的值是有序的，而只有在a相等的情况下b才是有序的。如果单独查b，只能全表找b，没办法二分索引找到b。</p><p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p><p><strong>1 全值匹配查询时–用到了索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line">select * from table_name where b &#x3D; &#39;2&#39; and a &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line">select * from table_name where c &#x3D; &#39;3&#39; and b &#x3D; &#39;2&#39; and a &#x3D; &#39;1&#39; </span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>2 匹配左边的列时—只有从第一个开始才能用到索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 如果都从最左边开始连续匹配，用到了索引</span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39;  </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39; and c &#x3D; &#39;3&#39;</span><br><span class="line"># 这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 </span><br><span class="line">select * from table_name where  b &#x3D; &#39;2&#39; </span><br><span class="line">select * from table_name where  c &#x3D; &#39;3&#39;</span><br><span class="line">select * from table_name where  b &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line"># 如果不连续时，只用到了a列的索引，b列和c列都没有用到 </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br></pre></td></tr></table></figure><p> <strong>3 匹配列前缀</strong>：如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where a like &#39;As%&#39;; &#x2F;&#x2F;前缀都是排好序的，走索引查询</span><br><span class="line">select * from table_name where  a like &#39;%As&#39;&#x2F;&#x2F;全表查询</span><br><span class="line">select * from table_name where  a like &#39;%As%&#39;&#x2F;&#x2F;全表查询</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL知识点总结：索引、架构、锁、事物、隔离级别。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://wukang555.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://wukang555.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>阿里java规范（泰山版）</title>
    <link href="https://wukang555.github.io/2022/05/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_01_%E9%98%BF%E9%87%8Cjava%E8%A7%84%E8%8C%83/"/>
    <id>https://wukang555.github.io/2022/05/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_01_%E9%98%BF%E9%87%8Cjava%E8%A7%84%E8%8C%83/</id>
    <published>2022-05-19T14:55:00.000Z</published>
    <updated>2022-05-19T01:55:34.743Z</updated>
    
    <content type="html"><![CDATA[<p>手册中编程规约、异常日志、安全规约、MySQL数据库、工程结构几个章节都是目前作为初级开发人员切实要用并且一定要了解的！！</p><a id="more"></a><blockquote><p>[1] 完全借鉴 Java开发手册（泰山版）</p><p>试图挑一些最普遍最强制并且我已经犯过的错误</p></blockquote><h1 id="1-编程规约"><a href="#1-编程规约" class="headerlink" title="1 编程规约"></a>1 编程规约</h1><h2 id="1-1-命名风格"><a href="#1-1-命名风格" class="headerlink" title="1.1  命名风格"></a>1.1  命名风格</h2><ol><li><p>【强制】<strong>所有编程相关的命名严禁使用拼音与英文混合的方式</strong>。注意，纯拼音命名方式更要避免采用。</p><ul><li>理解：命名就最好用英文或英文简写或者国际通用的拼音</li></ul></li><li><p>【强制】<strong>常量命名全部大写，单词间用下划线隔开</strong>，力求语义表达完整清楚，不要嫌名字长。</p><ul><li>理解：常量唯一，所以命名也必须唯一，长一点好</li></ul></li><li><p>【强制】<strong>抽象类命名使用 Abstract 或 Base 开头</strong>；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p><ul><li>我之前竟然一无所知…阔怕</li></ul></li><li><p>【强制】包名统一使用单数小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p></li><li><p>.【强制】杜绝完全不规范的缩写，避免望文不知义。</p><ul><li>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</li><li>理解：能不简写就不要简写。多练练敲字，速度提起来，名字长也能敲，还能练英语</li></ul></li><li><p>【参考】各层命名规约：</p><ul><li><p>Service/DAO 层方法命名规约</p><p>1） 获取单个对象的方法用 get 做前缀。</p><p>2） 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。 </p><p>3） 获取统计值的方法用 count 做前缀。 </p><p>4） 插入的方法用 save/insert 做前缀。</p><p>5） 删除的方法用 remove/delete 做前缀。</p><p>6） 修改的方法用 update 做前缀。</p></li><li><p>领域模型命名规约</p><p>1） 数据对象：xxxDO，xxx 即为数据表名。</p><p>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p><p>3） 展示对象：xxxVO，xxx 一般为网页名称。</p><p>4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 </p></li></ul></li></ol><h2 id="1-2-常量定义"><a href="#1-2-常量定义" class="headerlink" title="1.2 常量定义"></a>1.2 常量定义</h2><ol><li><p>【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p><ul><li>理解：这个我真的用过…就是说只要是常量 你都要先定义（字符串，某个数值）</li></ul></li><li><p>【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><ul><li><p>说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。</p></li><li><p>正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</p></li><li><p>理解：常量类的使用，我自己涉及的少，但是项目必备的</p></li></ul></li><li><p>【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p><ul><li>说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节</li><li>这么没看太懂哦，enum平时基本没用过，但是规范代码好像用的挺多的</li></ul></li></ol><h2 id="1-3-代码格式"><a href="#1-3-代码格式" class="headerlink" title="1.3 代码格式"></a>1.3 代码格式</h2><ol><li>【强制】左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空格；而左大括号前需要加空格。详见第 5 条下方正例提示。<ul><li>正例：if (a == b)</li><li>还有一条就是大括号 {} 前后必须加空格或者换行</li></ul></li><li>【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。<ul><li>很常见的点，但之前没注意</li></ul></li><li>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<ul><li>说明：包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</li></ul></li><li>【强制】注释的双斜线与注释内容之间有且仅有一个空格。</li><li>【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</li><li>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。</li></ol><h2 id="1-4-OOP规约"><a href="#1-4-OOP规约" class="headerlink" title="1.4 OOP规约"></a>1.4 OOP规约</h2><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p><ul><li>理解：一定要利用静态变量/方法的特性！静态的都需要用类名来访问</li></ul></li><li><p>【强制】不能使用过时的类或方法。</p><ul><li>接口提供方既然明确是过时接口，那么有义务同时提供新的接口；</li><li>作为调用方来说，有义务去考证过时方法的新实现是什么。</li></ul></li><li><p>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><ul><li>正例：”test”.equals(object);</li><li>反例：object.equals(“test”);</li></ul></li><li><p>【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p><ul><li>说明：虽然说 Integer var = ? 在-128 至 127 之间的赋值对象会复用，但还是推荐用equals方法进行判断</li></ul></li><li><p>【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals来判断。</p><ul><li>要么指定一个误差范围比如1e-6f来比较大小</li><li>要么用BigDecimal类型来比较大小</li></ul></li><li><p>【强制】禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为BigDecimal 对象。</p><ul><li><p>说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p></li><li><p>正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p></li></ul></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：</p><ul><li><p>【强制】所有的 POJO 类属性必须使用包装数据类型。</p></li><li><p>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</p></li><li><p>【推荐】所有的局部变量使用基本数据类型。</p></li><li><p>理解：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险(空指针异常)。</p></li><li><p>理解：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或</p><p>者入库检查，都由使用者来保证。</p></li></ul></li><li><p>【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</p><ul><li>理解：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题</li></ul></li><li><p>【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter方法</p><ul><li>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；</li><li>而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。</li></ul></li><li><p>【推荐】类成员与方法访问控制从严：</p><ul><li>如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private</li><li>工具类不允许有 public 或 default 构造方法。</li><li> 类 static 成员变量如果仅在本类使用，必须是 private。 </li><li>若是 static 成员变量，考虑是否为 final。</li><li>类成员方法只供类内部调用，必须是 private</li><li>类成员方法只对继承类公开，那么限制为 protected。</li><li>类非 static 成员变量并且与子类共享，必须是 protected</li><li>类非 static 成员变量并且仅在本类使用，必须是 private。</li><li>说明：过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</li></ul></li></ol><h2 id="1-5-日期时间"><a href="#1-5-日期时间" class="headerlink" title="1.5 日期时间"></a>1.5 日期时间</h2><ol><li>【强制】日期格式化时，传入 pattern 中表示年份统一使用小写的 y。<ul><li>正例：表示日期和时间的格式如下所示：new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”)</li></ul></li><li>【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是 new Date().getTime()。</li><li>【强制】不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。 <ul><li>int daysOfThisYear = LocalDate.now().lengthOfYear();</li></ul></li><li>【推荐】使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份month 取值在 0-11 之间。</li></ol><h2 id="1-6-集合处理"><a href="#1-6-集合处理" class="headerlink" title="1.6 集合处理"></a>1.6 集合处理</h2><ol><li><p>【强制】判断所有集合内部的元素是否为空，使用 isEmpty()方法，而不是 size()==0 的方式。</p><ul><li>说明：前者的时间复杂度为 O(1)，而且可读性更好。</li></ul></li><li><p>【强制】使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出 UnsupportedOperationException 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。</p><ul><li><p>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</p></li><li><p>说明：使用 toArray 带参方法，数组空间大小的 length</p><p>1） 等于 0，动态创建与 size 相同的数组，性能最好。</p><p>2） 大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</p><p>3） 等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</p><p>4） 大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。</p></li></ul></li><li><p>14.【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</p></li><li><p>【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p><ul><li>keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用Map.forEach 方法。</li></ul></li></ol><h2 id="1-7-并发处理"><a href="#1-7-并发处理" class="headerlink" title="1.7 并发处理"></a>1.7 并发处理</h2><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><ul><li>说明：资源驱动类、工具类、单例工厂类都需要注意。</li></ul></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯</p></li><li><p>. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p></li><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></li><li><p>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p></li><li><p>【强制】必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p></li></ol><ul><li>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、 B、C，否则可能出现死锁。</li></ul><ol start="9"><li>【强制】在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</li></ol><ul><li><p>说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p></li><li><p>说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。</p></li><li><p>说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</p></li></ul><ol start="10"><li>【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</li></ol><p>11.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p><ul><li>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次</li></ul><p>12.【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p><h2 id="1-8-控制语句"><a href="#1-8-控制语句" class="headerlink" title="1.8 控制语句"></a>1.8 控制语句</h2><p>\1. 【强制】在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default语句并且放在最后，即使它什么代码也没有。</p><p>\2. 【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断。</p><p><strong>\3. 【强制】在 if/else/for/while/do 语句中必须使用大括号。</strong></p><ul><li>说明：即使只有一行代码，禁止不采用大括号的编码方式：if (condition) statements; </li></ul><p>\4. 【强制】三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。</p><ul><li>null拆箱就会有NPE异常</li></ul><p>\5. 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</p><p>\9. 【推荐】不要在其它表达式（尤其是条件表达式）中，插入赋值语句。</p><ul><li>说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。</li></ul><h2 id="1-9-注释规约"><a href="#1-9-注释规约" class="headerlink" title="1.9 注释规约"></a>1.9 注释规约</h2><p>\1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用 // xxx 方式。</p><ul><li>在 IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</li></ul><p>\2. 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</p><ul><li>说明：对子类的实现要求，或者调用注意事项，请一并说明。</li></ul><p>\3. 【强制】所有的类都必须添加创建者和创建日期。</p><ul><li>说明：在设置模板时，注意 IDEA 的@author 为<code>$&#123;USER&#125;</code>，而 eclipse 的@author 为<code>$&#123;user&#125;</code>，大小写有区别，而日期的设置统一为 yyyy/MM/dd 的格式。</li></ul><p>\4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。</p><p>==\5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。==</p><p>1.10 其他</p><p>看不太懂</p><h1 id="5-MySQL数据库"><a href="#5-MySQL数据库" class="headerlink" title="5 MySQL数据库"></a>5 MySQL数据库</h1><h2 id="5-1-建表规约"><a href="#5-1-建表规约" class="headerlink" title="5.1 建表规约"></a>5.1 建表规约</h2><p>\1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</p><ul><li><p>说明：任何字段如果为非负数，必须是 unsigned。</p></li><li><p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultMap>设置从 is_xxx 到Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</resultMap></p></li><li><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li></ul><p>\2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li><p>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p></li><li><p>正例：aliyun_admin，rdc_config，level3_name</p></li></ul><p>\3. 【强制】表名不使用复数名词。</p><ul><li>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</li></ul><p>\5. 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p><ul><li>说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</li></ul><p>\6. 【强制】小数类型为 decimal，禁止使用 float 和 double。</p><ul><li>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</li></ul><p>\7. 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p><ul><li>问题：几乎相等是什么意思，就还是可以存在不相等的情况？</li></ul><p>\8. 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><ul><li>公司的文章表就是单独定义了一个text表，用来存放文本的数据</li></ul><p>\9. 【强制】表必备三字段：id, gmt_create, gmt_modified。</p><ul><li><p>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create, gmt_modified的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</p></li><li><p>格林尼治标准时间 Greenwich mean time (GMT)</p></li></ul><p>13.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><ul><li><p>1） 不是频繁修改的字段。</p></li><li><p>2） 不是唯一索引的字段。</p></li><li><p> 3） 不是 varchar 超长字段，更不能是 text 字段。</p></li><li><p> 正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。</p></li></ul><p>14.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p><ul><li>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</li></ul><h2 id="5-2-索引规约"><a href="#5-2-索引规约" class="headerlink" title="5.2 索引规约"></a>5.2 索引规约</h2><p>\2. 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p><ul><li><p>说明：即使双表 join 也要注意表索引、SQL 性能。</p></li><li><p>原因： 这个规则 超过三张表禁止join ,由于数据量太大的时候，mysql根本查询不出来，导致阿里出了这样一个规定。(其实如果表数据量少，10张表也不成问题,你自己可以试试)而我们公司支付系统朝着大规模高并发目标设计的，所以，遵循这个规定。</p></li><li><p>解决：如果查询确实需要join更多的表，可以把更多逻辑放到应用层（进行拼接处理）。而在业务层面来讲，只写简单sql。</p></li></ul><p>==\3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。==</p><ul><li>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</li></ul><p>==\4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。==</p><ul><li>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</li></ul><p>\9. 【推荐】建组合索引的时候，区分度最高的在最左边。</p><ul><li><p>正例：如果 where a=? and b=?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p></li><li><p>说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。</p></li></ul><h2 id="5-3-SQL语句"><a href="#5-3-SQL语句" class="headerlink" title="5.3 SQL语句"></a>5.3 SQL语句</h2><p>\1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><ul><li>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li></ul><p>\2. 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p><p>\3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。</p><ul><li>正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column), 0) FROM table;</li></ul><p>\4. 【强制】使用 ISNULL()来判断是否为 NULL 值。说明：NULL 与任何值的直接比较都为 NULL。 </p><ul><li><p>1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 </p></li><li><p>2） NULL=NULL 的返回结果是 NULL，而不是 true。 </p></li><li><p>3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。</p></li><li><p>反例：在 SQL 语句中，如果在 null 前换行，影响可读性。select * from table where column1 is null and column3 is not null; 而<code>ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析，<code>ISNULL(column)</code>执行效率更快一些</p></li></ul><p>\5. 【强制】代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p><ul><li>分页查询举个例子看看？公司推ES数据的时候数据量太大用的就是分页查询<ul><li>为什么没有limit也可以分页，运行次数一不一样，出来的页面就不一样？</li><li>用到了mybatis-plus</li></ul></li><li>如何实现count==0时直接返回？</li></ul><p>\6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><ul><li>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</li></ul><p>\8. 【强制】数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p><ul><li>这点好像很难做到啊，随便删一条数据都要先查一下看有没有？</li></ul><p>\9. 【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</p><ul><li><p>说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p></li><li><p>正例：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;</p></li></ul><p>10.【推荐】SQL 语句中表的别名前加 as，并且以 t1、t2、t3、…的顺序依次命名。</p><ul><li><p>说明：1）别名可以是表的简称，或者是根据表出现的顺序，以 t1、t2、t3 的方式命名。2）别名前加 as使别名更容易识别。</p></li><li><p>正例：select t1.name from table_first as t1, table_second as t2 where t1.id=t2.id;</p></li></ul><p>11.【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p><ul><li>示例：in常用于where表达式中，其作用是查询某个范围内的数据。</li><li>用法：select * from table where stu_name in (value1,value2,value3,…)</li><li>in后面可以使记录集、字符串、数组等</li></ul><h2 id="5-4-ORM映射"><a href="#5-4-ORM映射" class="headerlink" title="5.4 ORM映射"></a>5.4 ORM映射</h2><blockquote><p>（Object Relational Mapping对象关系映射）</p></blockquote><p>\1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p><ul><li>说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字段增加网络消耗，尤其是 text 类型的字段。</li></ul><p>\2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p><ul><li>说明：参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。</li><li>疑问：mybatis-plus注解方式写sql时，如何处理结果集映射</li></ul><p>\3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。</resultMap></resultMap></p><ul><li>说明：配置映射关系，使字段与 DO 类解耦，方便维护。</li></ul><p>\4. 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p><ul><li>具体情况还是需要区别使用，之前面经有整理</li></ul><p>==\5. 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。==</p><p>\6. 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</p><ul><li>反例：某同学为避免写一个&lt;resultMap&gt;，直接使用 HashTable 来接收数据库返回结果，结果出现日常是把 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。</li></ul><p>\7. 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p><ul><li>意思应该是要在service层程序员手动更新吧</li></ul><p>\8. 【推荐】不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p><ul><li>我之前做的功能updateArticle好像就有点这个问题</li></ul><p>\9. 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p><h1 id="6-工程结构"><a href="#6-工程结构" class="headerlink" title="6 工程结构"></a>6 工程结构</h1><h2 id="6-1-应用分层"><a href="#6-1-应用分层" class="headerlink" title="6.1 应用分层"></a>6.1 应用分层</h2><p>\1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220223145631.png" alt="image-20220223145624048" style="zoom:80%;"><ul><li><p>开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。 </p><ul><li>可以理解为Controller</li></ul></li><li><p>终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。 </p><ul><li>可以理解为前端界面？</li></ul></li><li><p>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 </p><ul><li>前后端都有参数校验，前端在页面上，后端一般就在Controller里边吧</li><li>这里可以理解为SpringMVC负责的内容？</li></ul></li><li><p>Service 层：相对具体的业务逻辑服务层。 </p></li><li><p>Manager 层：通用业务处理层，它有如下特征：</p><ul><li>1） 对第三方平台封装的层，预处理返回结果及转化异常信息。 </li><li>2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。 </li><li>3） 与 DAO 层交互，对多个 DAO 的组合复用。 </li><li>（实际项目中暂时不太了解这一层）</li></ul></li><li><p>DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OB 等进行数据交互。 </p></li><li><p>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</p></li></ul><p>\2. 【参考】（分层异常处理规约）</p><ul><li>在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。</li><li>在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。</li><li>Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。</li><li>Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。</li><li>开放接口层要将异常处理成错误码和错误信息方式返回。</li></ul><p>\3. 【参考】分层领域模型规约：</p><ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 （entity,pojo）</li><li>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。 </li><li>BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。 </li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。 </li><li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li></ul><p><strong>分层模型详细介绍</strong></p><blockquote><p>参考了<a href="https://segmentfault.com/a/1190000021701718">https://segmentfault.com/a/1190000021701718</a></p></blockquote><ul><li><p>DTO (Data Transger Object) 为数据传输对象，通常将底层的数据聚合传给外部系统，它通常用作 Service 和 Manager 层向上层返回的对象。需要注意的是：如果作为分布式服务的参数或返回对象，通常要实现序列化接口。</p></li><li><p>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。 </p></li><li><p>Param 为查询参数对象，适用于各层，通常用作接受前端参数对象。（与Query对应）</p></li><li><p>BO (Bussiness Object) 即业务对象。该对象中通常包含业务逻辑。此对象在实际使用中有不同的理解，有的团队采用领域驱动设计，BO 含有属性和方法（具体可参考领域驱动设计的相关图书）；有的团队将 BO 当做 Service 返回给上层的 “专用 DTO” 使用；而有的团队则当做 Service 层内保存中间信息数据的 “DTO” 或者上下文对象来使用（本文采用这种理解）。比如 BO 中可以保存中间状态，放一些逻辑等，这些并不适合放在 DTO。</p></li><li><p>VO (View Object) 为视图对象，通常作为控制层通过 JSON 返回给前端然后前端渲染或者加载页面模板在后端进行填充。</p></li><li><p>AO (Application Object) 应用对象。通常用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为 AO，如读取用户属性传给前端，用户在前端编辑了用户属性后传回后端。这种用法将 AO 用作 Param 和 VO 或 Param 和 DTO 的组合。</p></li></ul><p>查询视图：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220223160729.png" alt="2783533085-5e3d28879e23a" style="zoom: 50%;"><p>返回试图：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20220223160750.png" alt="2172307841-5e3d285cad5c0" style="zoom:50%;"><p>为什么要使用Param类和Query类来处理传递参数对象和数据查询对象？</p><ul><li><p>Param类和Query类都用来传递参数。查询参数一般使用 Query，删除参数一般使用 Param。Param 和 Query 的出现是为了避免使用 Map 作为接收参数的对象。</p></li><li><p>如果我们不使用 Query 对象而是 Map 对象来封装 DAO 的参数，设置和获取的 key 很可能因为粗心导致设置和获取时的 key 不一致而出现 BUG。</p></li><li><p> 如果我们不愿意定义 Param 对象，使用 Map 来接收前端的参数，获取时如果采用 JSON 反序列化，则可能出现反序列化类型丢失问题。</p></li><li><p>结论：前端传参过来最后用一个XxxParam对象或者用一个XxxQuery对象封装起来（都不推荐用map类来传输）那mybatis中所谓的参数映射的意义是什么？</p></li></ul><h2 id="6-3-服务器"><a href="#6-3-服务器" class="headerlink" title="6.3 服务器"></a>6.3 服务器</h2><p>\1. 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><ul><li>说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</li><li>正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout = 30</li></ul><p>\3. 【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM场景时输出 dump 信息。</p><ul><li>说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</li></ul><p>\4. 【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</p><ul><li>后面仔细看看，现在不明白</li></ul><p>\5. 【参考】服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL Broker 生成，否 则因线上采用 HTTPS 协议而导致浏览器提示“不安全“。此外，还会带来 URL 维护不一致的问题。</p><ul><li>平时访问一下网站就会出现这样的情况</li></ul><h1 id="7-设计规约"><a href="#7-设计规约" class="headerlink" title="7 设计规约"></a>7 设计规约</h1><blockquote><p>架构层面的理解</p><p>设计模式方面的知识用到的颇多、、</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;手册中编程规约、异常日志、安全规约、MySQL数据库、工程结构几个章节都是目前作为初级开发人员切实要用并且一定要了解的！！&lt;/p&gt;</summary>
    
    
    
    <category term="代码规范" scheme="https://wukang555.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="阿里巴巴" scheme="https://wukang555.github.io/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
    <category term="Java" scheme="https://wukang555.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>背包问题-力扣题解</title>
    <link href="https://wukang555.github.io/2021/11/20/%E7%AE%97%E6%B3%95_09_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://wukang555.github.io/2021/11/20/%E7%AE%97%E6%B3%95_09_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2021-11-20T14:55:00.000Z</published>
    <updated>2022-05-17T12:23:40.338Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划之背包问题。</p><a id="more"></a><blockquote><p>讲解背包问题最经典的当属《背包九讲》，之前看了前面一点点，现在又忘了，所以还是的写笔记</p><p>面试需要，不做太深入的了解。这里仅学习零一背包、完全背包和多重背包问题</p><p>[1] 参考了<a href="https://github.com/tianyicui/pack">背包九讲</a>  背包九讲就是讲背包的永远滴神</p></blockquote><h1 id="1-背包问题介绍"><a href="#1-背包问题介绍" class="headerlink" title="1 背包问题介绍"></a>1 背包问题介绍</h1><h2 id="1-1-背包问题的基本描述和分类"><a href="#1-1-背包问题的基本描述和分类" class="headerlink" title="1.1 背包问题的基本描述和分类"></a>1.1 背包问题的基本描述和分类</h2><blockquote><p>背包问题的基本描述：有N件物品和一个最多能装重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。</p></blockquote><ul><li>01背包：每种物品仅有一件，可以选择放或不放。求解将哪些物品装入背包可使价值总和最大。</li><li>完全背包：每种物品都有无限件可用，求解将哪些物品装入背包可使价值总和最大。</li><li>多重背包：每件物品的数量由nums[i]表示，求解价值总和最大的装法。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213518.png" alt="416.分割等和子集1" style="zoom:80%;"><h2 id="1-2-背包问题的基本解法（01背包为例）"><a href="#1-2-背包问题的基本解法（01背包为例）" class="headerlink" title="1.2 背包问题的基本解法（01背包为例）"></a>1.2 背包问题的基本解法（01背包为例）</h2><blockquote><p>就是动态规划，但不同问题，遍历计算的顺序大不相同。</p><p>动态规划的三大要点：1状态  2确定初始化和重点 3列出状态转移方程</p></blockquote><p><strong>为什么要用动态规划？</strong></p><p>一个物品存在选择或者不选择两种情况，暴力解法就是2^n种选择。显然需要用动态规划保存状态来降低时间复杂度。</p><p><strong>基础的01背包案例：背包容量为n、一共有m个物品，物品重量数组W[1:m]，价值数组V[1:m]</strong></p><ul><li>状态<code>dp[i][j]</code>表示从前<code>i</code>个的物品种任意取，放进容量为<code>j</code>的背包，能获得的最大价值总和</li><li>初始化状态和终点<ul><li> <code>dp[i][0]=0</code>（容量为0的背包取出的价值为0）<code>dp[0][j]=0</code> （没有任何物品取出价值为0）</li><li><code>dp[i][j]=dp[i-1][j]</code>（因为多一个物品一定比少一个物品获得可能的结果更大，所以可以用上一个状态表示初始值）</li><li>终点：<code>dp[m][n]</code> 一共有m个物品，背包容量为n</li></ul></li><li>状态转移方程<ul><li>若(j-W[i-1]&gt;0),就表示W[i-1]元素可以作为填充背包的一部分，即</li><li><code>dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-W[i-1]]+V[i-1]);</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack01</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] W, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i][j]表示将前i个元素的组合、装入容量为j的背包 能获得的最大价值</span></span><br><span class="line">    <span class="comment">//显然dp[i][j]的值一定大于等于dp[i-1][j]，可以所谓基础值</span></span><br><span class="line">    <span class="comment">//初始化 dp[..][0] = 0;</span></span><br><span class="line">    <span class="comment">//终点 dp[n][m]</span></span><br><span class="line">    <span class="comment">//动态迭代</span></span><br><span class="line">    <span class="comment">//先令dp[i][j]=dp[i-1][j],,若(j-W[i-1]&gt;0),就表示W[i-1]元素可以作为填充背包的一部分，则</span></span><br><span class="line">    <span class="comment">//dp[i][j] = max(dp[i-1][j],dp[i-1][j-W[i-1]]+V[i-1]);</span></span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j-W[i-<span class="number">1</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由遍历过程我们可以知道，<code>dp[i][j]</code>层都是由<code>dp[i-1][j]</code>层推导过来的，其实可以只使用一维数组保存状态。</p><p><strong>要注意到，此时<code>j</code>的循环必须是从大到小的逆序循环！！ 因为<code>dp[i][j]</code>是由<code>dp[i-1][j]</code>  <code>dp[i-1][j-w[i-1]]</code>推导而来，，每次求<code>j</code>的位置的值 用到了<code>j</code>位置和<code>j</code>之前位置的元素！！！</strong></p><p>代码如下，不再赘述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack01</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] W, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];<span class="comment">//表示容量为j的背包的最大价值和</span></span><br><span class="line">    <span class="keyword">int</span> n = W.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-W[i-<span class="number">1</span>]&gt;=<span class="number">0</span>) dp[j] = Math.max(dp[j],dp[j-W[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-01背包题解"><a href="#2-01背包题解" class="headerlink" title="2 01背包题解"></a>2 01背包题解</h1><blockquote><p>了解概念之后、直接刷题学习</p><p>0/1背包类型：5m、53e、55m、62m、70e、91m、121e、139m、152m、198m、 213m、300m、303e、309m、322m、338m、377m、<strong>416m</strong>、647m、673m、698m</p><p>416 1049 494 474</p></blockquote><h2 id="92-·-背包问题"><a href="#92-·-背包问题" class="headerlink" title="92 · 背包问题"></a><a href="https://www.lintcode.com/problem/92/">92 · 背包问题</a></h2><blockquote><p>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为<code>A[i]</code></p></blockquote><p>思路：<code>dp[i][j]</code> 表示使用前<code>i</code>个物品最多能将容量为<code>j</code>的背包装的容量大小</p><ul><li>初始化<code>dp[i][0]=0  dp[0][j]=0</code>  <code>dp[i][j] = dp[i-1][j]</code></li><li>迭代方程<code>if(j&gt;A[i-1]) dp[i][j] = dp[i-1][j-A[i-1]]+A[i-1]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// `dp[i][j]` 表示使用前`i`个物品最多能将容量为`j`的背包装的容量大小</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=A[i-<span class="number">1</span>]) dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+A[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><blockquote><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote><p>思路：<strong>做这道题需要做一个等价转换：两子集元素和相等即表示：是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。</strong></p><p>所以题目变成了，是否可以挑出一些数来是他们的和等于sum/2。挑选的过程就类似与背包选择的过程。经典的背包问题是能装多满、这里问的是是否刚好等于，所以状态数组<code>dp[][]</code>是boolean类型的</p><ul><li>状态<code>dp[i][j]</code> 表示使用前<code>i</code>个元素，是否存在一个组合使其和为<code>j</code><ul><li>i从0到n-1，，j从0到target</li></ul></li><li>初始化 <code>dp[i][0]=false</code>; <code>dp[0][j]=true(if nums[0]==j)</code> ;<code>dp[i][j] = dp[i - 1][j]</code></li><li>终点 <code>dp[n-1][sum/2]</code>;</li><li>动态迭代 <code>if(j-nums[i]&gt;=0 &amp;&amp; dp[i-1][j-nums[i]]) dp[i][j] = true;</code></li></ul><p>依然可以看到<code>dp[i][j] = dp[i - 1][j]</code>类似的初始化，因为多一个元素一定比少一个元素的结果更理想，</p><p>然后动态迭代时，同样也用到了<code>dp[i-1][j-nums[i]]</code> 之前的状态，即使用nums[i]和不使用nums[i]存在明显的先后关系！！</p><p>代码：细节挺多的，不容易ak</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个数是否能组合出j的整数和</span></span><br><span class="line">        <span class="comment">//目标值target就是sum的一半</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[i][<span class="number">0</span>] = <span class="keyword">false</span>; <span class="comment">//可写可不写</span></span><br><span class="line">        <span class="comment">//0个数一定组合不出来什么 这样的初始状态无意义 所以要从1个数开始</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target) dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>; <span class="comment">//这里的判断别忘记加</span></span><br><span class="line">        <span class="comment">//for(int j=0;j&lt;=target;j++) dp[0][j] = nums[0]==j? true:false;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]&gt;=<span class="number">0</span> &amp;&amp; dp[i-<span class="number">1</span>][j-nums[i]]) dp[i][j] = <span class="keyword">true</span> ; </span><br><span class="line">                <span class="comment">//这里必须这么写 防止把true变为了false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h2><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p>下意识看到觉得好难，然后思路是回溯….</p><p>方法一：回溯法（为什么不需要用for循环呢？)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sumIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自己再尝试一下回溯写法</span></span><br><span class="line">        backtrack(nums,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sumIndex == target) count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做加法的选择</span></span><br><span class="line">        sumIndex += nums[index];</span><br><span class="line">        backtrack(nums,target,index+<span class="number">1</span>);</span><br><span class="line">        sumIndex -= nums[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//做减法的选择</span></span><br><span class="line">        sumIndex -= nums[index];</span><br><span class="line">        backtrack(nums,target,index+<span class="number">1</span>);</span><br><span class="line">        sumIndex +=nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//还是先写一遍递归的吧 最适合面试A</span></span><br><span class="line">        helper(<span class="number">0</span>,<span class="number">0</span>,nums,target);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> SumIndex, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(SumIndex==target) count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helper(index+<span class="number">1</span>,SumIndex+nums[index], nums,target);</span><br><span class="line">            helper(index+<span class="number">1</span>,SumIndex-nums[index],nums,target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：动态规划（01背包问题）</strong></p><p>思路：看起来不像01背包、但其实就是01背包</p><ul><li><code>dp[i][j]</code> 表示前i个元素可以组成j值的组合数目</li><li>动态规划问题，建议先考虑迭代方程（这样你才知道需要初始化哪些位置：因为不一定总是第1行第1列）</li><li><code>dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]</code> //总是由上一行推导这一行，所以初始化第一行就ok</li><li> <code>dp[0][j]</code> //第一个元素组合出j的种数，，那就是<code>dp[0][nums[i]] += 1; dp[0][-nums[i]] += 1</code>; 就完事  ！！注意用+=因为这两个可能是同一个位置！！</li><li>最后因为<code>j</code>可能为负数，且范围是[-1000,1000], 所以<code>j</code>索引的位置总是+1000，使索引非负</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j] 表示前i个元素可以组成j值的组合数目</span></span><br><span class="line">        <span class="keyword">int</span> m = nums.length; <span class="keyword">int</span> n = <span class="number">2001</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1000</span>;j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i]+<span class="number">1000</span>&gt;=<span class="number">0</span>) dp[i][j+<span class="number">1000</span>] += dp[i-<span class="number">1</span>][j-nums[i]+<span class="number">1000</span>]; </span><br><span class="line">                <span class="keyword">if</span>(j+nums[i]+<span class="number">1000</span>&lt;=<span class="number">2000</span>) dp[i][j+<span class="number">1000</span>] += dp[i-<span class="number">1</span>][j+nums[i]+<span class="number">1000</span>]; </span><br><span class="line">                <span class="comment">//if(j==0) System.out.println(dp[i][j+1000]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][target+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么说他是零一背包的问题呢？因为都是由上一行的状态推导这一行，并且推导过程需要减去（加上）<code>nums[i]</code></p><ul><li><code>dp[i][j] += dp[i-1][j-nums[i]]</code></li><li><code>dp[i][j] += dp[i-1][j+nums[i]]</code></li></ul><h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h2><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p></blockquote><p>思路：就是多了一维的01背包问题</p><ul><li><code>dp[i][j][k]</code> 表示前<code>i</code>索引的字符串 满足0的个数&lt;=j &amp;&amp; 1的个数&lt;=k的最大子集的大小</li><li><code>dp[i][j][k] = dp[i-1][k][j]</code>; <code>dp[i][j][k] = dp[i-1][j-a][k-b]+1</code>    a、b分别表示strs[i]中0和1的个数</li><li>初始化：01背包问题都是有上一行推导下一行、所以只用初始化第一行<code>dp[0][j][k] =1 if(j&gt;=a&amp;&amp;k&gt;=b)</code></li></ul><p>代码：其实代码简单、就是不容易想到是01背包问题…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//恐怖如斯，，我思路和题解完全一致..多了一维的01背包问题</span></span><br><span class="line">        <span class="comment">//dp[i][j][k] 表示前i索引的字符串 满足0的个数&lt;=j &amp;&amp; 1的个数&lt;=k的最大子集的大小</span></span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] temp = getCount(strs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=temp[<span class="number">0</span>];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=temp[<span class="number">1</span>];k--)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j][k]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    dp[i][j][k] = dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                    temp = getCount(strs[i]);</span><br><span class="line">                    <span class="keyword">if</span>(temp[<span class="number">0</span>]&lt;=j&amp;&amp;temp[<span class="number">1</span>]&lt;=k) dp[i][j][k] = Math.max(dp[i][j][k], dp[i-<span class="number">1</span>][j-temp[<span class="number">0</span>]][k-temp[<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getCount(String s)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;0&#x27;</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-完全背包题解"><a href="#3-完全背包题解" class="headerlink" title="3 完全背包题解"></a>3 完全背包题解</h1><blockquote><p><strong>518</strong> 377  322 279 139</p><p>70 爬楼梯是完全背包？我不会写了</p></blockquote><h2 id="440-·-背包问题-III"><a href="#440-·-背包问题-III" class="headerlink" title="440 · 背包问题 III"></a><a href="https://www.lintcode.com/problem/440/">440 · 背包问题 III</a></h2><blockquote><p>给定 <code>n</code> 种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p><p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p><p><strong>样例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4], m &#x3D; 10</span><br><span class="line">输出: 15</span><br><span class="line">解释: 装入三个物品 1 (A[1] &#x3D; 3, V[1] &#x3D; 5), 总价值 15.</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路一：先来一个01背包的解法。（01生万物）</strong></p><ul><li>   完全背包问题，<strong>三层循环</strong></li><li>   <code>dp[i][j]</code>表示前<code>i</code>索引物品任意取，背包容量为<code>j</code>时的最大价值</li><li><pre><code>动态迭代 第`i`索引物品最多使用的个数是 `m/A[i]`   所以次数`k`取0到`m/A[i]`</code></pre></li><li>   ``dp[i][j] = max(dp[i][j], dp[i-1][j-k<em>A[i-1]]+k</em>V[i-1])`</li><li>   初始化 <code>dp[0][j]=j/A[0]*A[0]</code>; <code>dp[i][j]=dp[i-1][j] </code>终点<code>dp[n-1][m]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 完全背包问题，三层循环</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示前i索引物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;=m/A[i];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k*A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*A[i]]+k*V[i] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><ul><li><p><code>dp[i][j]=dp[i-1][j] </code> 同样采用了多用一个元素一定比少用一个元素结果更理想的01背包思想！！</p></li><li><p>动态迭代方程采用<code>dp[i-1][j-k*A[i]]+k*V[i]</code>，表示在上一行的选择基础上、选择k个A[i]元素的价值，，取其中的最大值就好了。就是多了一层k循环的01背包问题</p></li></ul><p><strong>思路二：对于时间问题的简化</strong></p><p>01背包问题是每个物品只能选一次、所以我们只能在上一行未选择A[i]这个元素的基础上继续做选择（选或者不选），，，而完全背包的问题是A[i]这个元素可以选择任意次，所以<strong>我们可以直接在本行已选择A[i]的基础上继续选择！！！</strong>，这就是完全背包和01背包最根本的区别，<strong>所需的改动也仅仅是动态方程中从上行<code>[i-1]</code>选还是从本行<code>[i]</code>选</strong></p><p>一旦我们从本行选择、就无需每次都遍历k次，直接减少一层循环！！因为本行的<code>dp[i][j]</code>用到了本行的<code>dp[i][j-A[i]]</code>所以，<code>j</code>一定过要从小到大遍历！！</p><ul><li> <code>dp[i][j]</code>表示前<code>i</code>索引物品任意取，背包容量为<code>j</code>时的最大价值</li><li>动态迭代： <code>dp[i][j] = max(dp[i][j], dp[i][j-k*A[i-1]]+k*V[i-1])</code></li><li>注意因为 <code>dp[i</code>][j]用到了<code>dp[i][j-k*A[i-1]]</code>，所以<code>j</code>的循环要从小到大</li><li>初始化 <code>dp[0][j]=j/A[0]*A[0]</code>;   <code>dp[i][j]=dp[i-1</code>][j] 终点<code>dp[n-1</code>][m]</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法二：完全背包问题的时间优化</span></span><br><span class="line">        <span class="comment">// dp[i][j]表示前i索引物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[<span class="number">0</span>][j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(j-A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i][j-A[i]]+V[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路三：进一步对空间问题的简化</strong></p><p>因为求本行的数据只用到了上一行<code>j</code>位置的数据，和本行<code>j</code>之前的数据，所以一维数组就可以(和01背包的空间优化是一个思路)</p><ul><li><code>dp[j]</code>表示示前<code>i</code>个物品任意取，背包容量为<code>j</code>时的最大价值</li><li>动态迭代 j从0迭代到m，，i还是从1迭代到n，，O(mn)时间复杂度</li><li><code>dp[j] = Math.max(dp[j], dp[j-A[i]]+V[i])</code>;</li><li>初始化 <code>dp[j]== j/A[0]*A[0]</code>; 终点<code>dp[m]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法三：完全背包 时间空间都优化</span></span><br><span class="line">        <span class="comment">//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m;j++) dp[j] = j/A[<span class="number">0</span>]*A[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">                <span class="keyword">if</span>(j-A[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i]]+V[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以完全背包问题的时间空间简化版本、和01背包的空间优化版本，其实就只有一个<code>j</code>遍历顺序的差别</strong></p><h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h2><blockquote><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><p><strong>思路：完全背包问题，注意第一行的初始化方式！！</strong></p><ul><li><code>dp[i][j]</code>表示前<code>i</code>索引的硬币，能够拼成<code>j</code>的组合数</li><li><code>dp[i][j] += dp[i][j-coins[i]]</code></li><li>初始化 <code>if(j%coins[0]==0) dp[0][j] = 1</code>,,, <code>dp[i][j]= dp[i-1][j]</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型完全背包问题</span></span><br><span class="line">        <span class="comment">//dp[i][j]表示前i索引的硬币，能够拼成j的组合数</span></span><br><span class="line">        <span class="keyword">int</span> m = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [m][amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化 只要j%coins[0]==0 dp[0][j]=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++) <span class="keyword">if</span>(j%coins[<span class="number">0</span>]==<span class="number">0</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i]&gt;=<span class="number">0</span>) dp[i][j] += dp[i][j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：完全背包，优化空间</strong></p><ul><li><code>dp[j]</code>表示前<code>i</code>索引的硬币，能够拼成<code>j</code>的组合数</li><li><code>dp[j] += [j-coins[i]]</code></li><li>初始化 <code>if(j%coins[0]==0) dp[j] = 1</code>,,, <code>dp[j]= dp[j]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//典型完全背包问题 优化空间</span></span><br><span class="line">        <span class="comment">//dp[j]表示前i索引的硬币，能够拼成j的组合数</span></span><br><span class="line">        <span class="keyword">int</span> m = coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [amount+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化 只要j%coins[0]==0 dp[0][j]=1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++) <span class="keyword">if</span>(j%coins[<span class="number">0</span>]==<span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[j] = dp[j];</span></span><br><span class="line">                <span class="keyword">if</span>(j-coins[i]&gt;=<span class="number">0</span>) dp[j] += dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>完全背包问题和01背包问题的区别在于是否可以重复选择，对应到代码层面，就是当前行是由当前行推导（完全背包）还是由上一行推导（01背包）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;动态规划之背包问题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wukang555.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="力扣" scheme="https://wukang555.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://wukang555.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="背包问题" scheme="https://wukang555.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-力扣题解</title>
    <link href="https://wukang555.github.io/2021/11/18/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wukang555.github.io/2021/11/18/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-11-18T14:55:00.000Z</published>
    <updated>2022-05-17T12:23:17.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/comments/377874">“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。”</a></p><p><a href="https://leetcode-cn.com/problems/3sum/comments/401721">“十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”</a></p><a id="more"></a><blockquote><p>[1] 定义部分参考了力扣官方<a href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/xceyqr/">力扣小卡片-动态规划</a></p><p>[2] 使用方法和力扣题目来自于<a href="https://greyireland.gitbook.io/algorithm-pattern/ji-chu-suan-fa-pian/dp">开源模板-动态规划</a></p><p>[3] 文章结构和代码全凭个人理解、错误之处敬请指出；除标注外皆原创、保留权力</p></blockquote><h2 id="1-如何使用动态规划"><a href="#1-如何使用动态规划" class="headerlink" title="1 如何使用动态规划"></a>1 如何使用动态规划</h2><p>​        动态规划（Dynamic programming，简称 DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划不是某一种具体的算法，而是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。[1]</p><p>​        现阶段的刷题就是为了面试撕代码，所以第一节直接讲怎么用，第二节再讲DP是什么。</p><h3 id="1-1-使用场景-2"><a href="#1-1-使用场景-2" class="headerlink" title="1.1 使用场景[2]"></a>1.1 使用场景[2]</h3><ul><li><strong>满足以下条件之一</strong><ul><li>求最大/最小值（Maximum/Minimum ）</li><li>求是否可行（Yes/No ）</li><li>求可行个数（Count(*) ）</li></ul></li><li><strong>满足不能排序或者交换（Can not sort / swap ）</strong></li></ul><h3 id="1-2-四点要素-2"><a href="#1-2-四点要素-2" class="headerlink" title="1.2 四点要素[2]"></a>1.2 四点要素[2]</h3><ul><li>状态 State<ul><li><strong>灵感，创造力，存储小规模问题的结果</strong></li></ul></li><li>方程 Function<ul><li>状态之间的联系，怎么通过小的状态，来算大的状态</li></ul></li><li>初始化 Intialization<ul><li>最极限的小状态是什么, 起点</li></ul></li><li>答案 Answer<ul><li>最大的那个状态是什么，终点</li></ul></li></ul><h3 id="1-3-示例模板-斐波那契数"><a href="#1-3-示例模板-斐波那契数" class="headerlink" title="1.3 示例模板-斐波那契数"></a>1.3 <a href="https://leetcode-cn.com/problems/fibonacci-number/">示例模板-斐波那契数</a></h3><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p></blockquote><p>​        以最为简单的斐波拉契数作为例子，<strong>方便理解动态规划算法的使用流程</strong>。<strong>四点要素中我觉得最重要的是状态</strong>，状态用来存储小规模问题的结果、状态的选择需要创造力，但就应试考试而言、我们通过经验来弥补就好了。其次是状态转移方程、基本只要能列出方程就离解题不远了。本题而言、方程已经直接给了就可以直接上手：</p><ul><li>动态规划 <code>dp[i]</code>表示<code>F(i)</code>的值</li><li>初始化 <code>dp[0]=0, dp[1]=1</code>; 终点求<code>dp[n]</code></li><li>状态转移方程 <code>dp[i]=dp[i-1]+dp[i-2]</code>;</li></ul><p>模板代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        至于怎么减少空间复杂度，重复利用<code>dp</code>数组的空间，其实是细支末节，并不很难，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//重复利用空间</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-介绍动态规划-1"><a href="#2-介绍动态规划-1" class="headerlink" title="2 介绍动态规划[1]"></a>2 介绍动态规划[1]</h2><p>​        应用这种动态规划算法思想解决问题的可行性，对<strong>子问题与原问题的关系</strong>，以及<strong>子问题之间的关系</strong>这两方面有一些要求，它们分别对应了<strong>最优子结构</strong>和<strong>重复子问题</strong>。</p><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>一个问题的最优解是由它的各个子问题的最优解决定的。将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。找到了最优子结构，也就能推导出一个状态转移方程 $f(n)$</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213436.png" alt="img"></p><h3 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h3><p>重复子问题规定的是子问题与子问题的关系。动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。</p><p>动态规划算法中关于最优子结构和重复子问题的理解的关键点：</p><ul><li>证明问题的方案中包含一种选择，选择之后留下一个或多个子问题</li><li>设计子问题的递归描述方式</li><li>证明对原问题的最优解包括了对所有子问题的最优解</li><li>证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）</li></ul><h2 id="3-力扣题解"><a href="#3-力扣题解" class="headerlink" title="3 力扣题解"></a>3 力扣题解</h2><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h3><blockquote><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标<code>i</code>或<code> i + 1</code> 。</p></blockquote><p>思路：</p><ul><li>这题状态的选择很有创造性，<strong>从底部往上动态查找</strong></li><li><code>dp[i][j]</code>表示 第<code>i</code>行的<code>j</code>节点出发 到第<code>n</code>行的最小路径和</li><li>初始化<code> dp</code>为原集合 目标<code>dp[0][0]</code></li><li>动态迭代 <code>dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1])+arr[i][j]</code></li></ul><p>代码：空间优化就是一维数组，代码就不再列出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">1</span>) <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化最后一层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][j] = triangle.get(m-<span class="number">1</span>).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><blockquote><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213441.jpg" alt="img" style="zoom: 67%;"><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>思路：</p><ul><li>原地动态规划<code> dp[i][j]</code>表示从左上角到<code>i,j</code>处的最小路径和</li><li>初始化<code>dp[0][i], dp[j][0]</code>累计即可  终点<code>dp[m-1][n-1]</code></li><li>动态规划方程<code> dp[i][j] = grid[i][j]+ Math.min(dp[i-1][j],dp[i][j-1])</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                grid[i][j] += Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例 1：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213444.jpg" alt="img" style="zoom:67%;"><p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2</p></blockquote><p>思路：</p><ul><li>状态就是某网格的路径数 有障碍物时当前为0</li><li><code>dp[i][j]</code>表示从左上角到<code>i,j</code>位置的路径数目</li><li>初始化 第一行第一列为1 如果出现障碍物后面全0 终点<code>dp[m-1][n-1]</code></li><li>动态迭代 有障碍物则0，如果没有就<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li></ul><p>代码：其实如果新建一个<code>dp[][]</code>数组后细节处更不易出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//排除干扰</span></span><br><span class="line">        <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;j++) obstacleGrid[j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里第一行要从第二个开始了 因为第一列初始化已经修改了值！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++) obstacleGrid[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    obstacleGrid[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    obstacleGrid[i][j]=obstacleGrid[i-<span class="number">1</span>][j]+obstacleGrid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><blockquote><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p>思路：动态规划——维护每个点是否可达的数组</p><ul><li><code>dp[i] </code>表示能否跳到<code>i+1</code>这个节点</li><li><code>dp[0] = true</code>  求<code>dp[n-1]</code>;</li><li><strong>动态迭代求<code>dp[i]</code>时，从<code>i-1</code>处向前找</strong></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;n&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">//默认为false</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//动态迭代求dp[i]时，从i-1处向前找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span>&amp;&amp;i-j&lt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p></blockquote><p>这个动态规划怎么这么慢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示从索引i到j的子串是否是回文串</span></span><br><span class="line">        <span class="comment">//动态迭代 dp[i][j] = dp[i+1][j-1] &amp;&amp; s.charAt(i)==s.charAt(j);</span></span><br><span class="line">        <span class="comment">//两层循环 外层长度从1到n  内层索引 i从0到n-l</span></span><br><span class="line">        <span class="comment">//初始化 需要初始长度为1 和长度为2 的dp</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> length=<span class="number">1</span>;length&lt;=n;length++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n-length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+length-<span class="number">1</span>;  <span class="comment">//[i,j]</span></span><br><span class="line">                <span class="keyword">if</span>(length==<span class="number">1</span>) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(length==<span class="number">2</span>) dp[i][j] = s.charAt(i)==s.charAt(j);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s.charAt(i)==s.charAt(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;length&gt;maxLength)&#123;</span><br><span class="line">                    maxLength = length;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的频率不是一般的高，暴力解法也来爽一爽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想先写一个暴力解法</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">                String cur = s.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(cur)&amp;&amp; cur.length()&gt;maxLength)&#123;</span><br><span class="line">                    left = i; right = j;</span><br><span class="line">                    maxLength = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(s.length()-i-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h3><blockquote><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 最少分割次数 。</p><p>示例 1：</p><p>输入：s = “aab”<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。</p></blockquote><p>思路：</p><ul><li><code>dp[i]</code>表示1到i的子串的最小分割次数 <code>dp = new int[n+1]</code>; <code>dp[]</code>的长度比字符串s大1</li><li><code>dp[i]</code>的初始化为<code>dp[i-1]+1</code>,,并且<code>dp[1]=0; dp[0]=-1</code>，终点<code>dp[n]</code></li><li><code>dp[i]</code>的求解需要利用遍历，<code>j</code>从<code>0</code>遍历到<code>i-1</code> 如果有<code>[j+1,i]</code>部分是回文的(对应于<code>s(j,i-1)</code> )则<code>dp[i]=Math.min(dp[i],dp[j]+1)</code></li></ul><p>代码：运行相当之慢，好像判断是否回文哪里可以用动态规划优化一下（回头再看吧…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=-<span class="number">1</span>; dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//[j+1,i]为回文则取小值</span></span><br><span class="line">                <span class="keyword">if</span>(isBack(s,j,i-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBack</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)!=s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><ul><li>和分割回文子串的最小次数是一类题，<code>dp[i]</code>的求解需要 <code>dp[]数组</code>从<code>0</code>往<code>i</code>的遍历 找找迭代方程中的需要的那个元素</li><li><code>dp[i]</code>表示<strong>以<code>i</code>索引元素结尾的</strong>严格增子序列的长度！！！<code>dp[i]</code>非递增，而是代表类它自己那个递增序列的长度</li><li>初始化 <code>dp[0]=1; dp[i]=1</code> 终点不是<code>dp[n-1]</code>，而是**<code>dp[i]</code>数组的最大值**</li><li>动态迭代<code> j</code>有<code>0</code>到<code>i-1</code>,<code>if(nums[j]&lt;nums[i])</code> 则<code>dp[i] =max(dp[i], dp[j]+1)</code>,,,</li><li>用一个<code>maxResult</code>记录<code>dp[]</code>数组的最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxResult=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]) dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxResult=Math.max(dp[i],maxResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h3><blockquote><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure></blockquote><p>​        思路：连续三道<strong>找状态<code>dp[i]</code>，需要遍历<code>dp[]</code>数组<code>i</code>之前的所有元素</strong>、来判断<code>dp[i]</code>的取值了！！ 都是复杂度为<code>O(n2)</code>的<code>DP</code></p><ul><li><code>dp[i]</code>表示字符串第<code>i-i</code>个元素，是否可以被拆分为字典中出现的词</li><li><code>dp[0]</code>表示无字符串为true， 终点<code>dp[n]</code></li><li>动态迭代 当<code>dp[j]=true&amp;&amp;[j+1,i]位于字典中</code>，对应s的索引为<code>s[j,i-1]</code></li><li>用set集合判断是否在字段中</li></ul><p>​    代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">//因为求dp[1]要用到dp[0]索引定义dp长度为n+1！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span> &amp;&amp; wordDictSet.contains(s.substring(j,i)) )&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：想复杂了没想到是一个简单的DP</p><ul><li>当<code>text[i]==text[j]</code>时 <code>dp[i][j] = dp[i-1][j-1]+1</code></li><li>否则 <code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code></li><li>初始化<code>dp[0][0] = 0</code>第一行第一列都为0 终点<code>dp[m][n]</code></li><li><strong>定义m+1 n+1维的数组就很完美</strong></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(); <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li><code>dp[i][j]</code>表示word1前<code>i</code>个转换成word2前<code>j</code>个 所需使用的最小操作数</li><li>初始化 第一行<code>dp[0][j]=j </code>第一列<code>dp[i][0]=i</code>    //终点<code>dp[m][n]</code></li><li>动态规划,若<code>word1.charAt(i-1)==word2.charAt(j-1)</code> 则<code>dp[i][j]=dp[i-1][j-1]</code>表示不需要操作</li><li>若不相等 则<code>dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code></li><li><strong>定义m+1 n+1维的数组就很完美</strong><ul><li>因为要用到<code>i-1 j-1</code>,所以需要从<code>1</code>开始循环，<code>dp[0][0]</code>表示都为空时的状态，<code>dp[1][1]</code>代表第一个元素的状态，所以<code>dp[m][n]</code>是终点</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行第一列为i,j</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min( Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>; <span class="comment">//分别对应：增加、增加、替换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-面试高频题"><a href="#4-面试高频题" class="headerlink" title="4 面试高频题"></a>4 面试高频题</h2><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><blockquote><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112213451.jpg" alt="img" style="zoom:50%;"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></blockquote><p>思路：这题的关键是状态的确定 还有迭代方程</p><ul><li><code>dp[i][j]</code>表示以<code>[i][j]</code>为右下角，且只包含 1 的正方形的边长最大值</li><li>初始化：第一行第一列最大为1，并且就等于<code>matrix</code>矩阵的值</li><li>需要用一个<code>maxLength</code>记录最大边长</li><li>迭代方程<code> dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLength) maxLength=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength*maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h3><blockquote><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure></blockquote><p>思路：动态规划，有变化的地方在于p，需要分类考虑</p><ul><li>状态<code>dp[i][j]</code>表示s的前<code>i</code>个字符和p的前<code>j</code>个字符是否匹配成功</li><li>初始化 <code>dp[0][0]=true</code>, <code>dp[i][0]=false</code>; <code>dp[0][j]</code>仅p前j个全为*才为真； 终点<code>dp[m][n]</code></li><li>动态迭代 如果p[j]为小写字母，<code>dp[i][j] = s[i]==p[j] &amp;&amp; dp[i-1][j-1]</code></li><li>如果 p[j]为？, <code>dp[i][j] = dp[i-1][j-1]</code></li><li>如果 p[j]为*， <code>dp[i][j] = dp[i][j-1] || dp[i-1][j]</code>; 分别表示 *使用和不使用的情况 (这里难想一点)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//为小写字母</span></span><br><span class="line">                    dp[i][j] = s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) &amp;&amp; dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><blockquote><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>动态规划 状态<code>dp[i]</code>表示索引<code>i</code>的字符结尾的最长有效子串的长度</li><li>初始化<code>dp[i]=0</code>, 终点：求<code>dp[]数组</code>的最大值</li><li>动态迭代 当<code>s[i]为&#39;(&#39; </code>时<code>dp[i]=0</code>;</li><li>1形如<code>&quot;...()&quot;</code> 当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;(&#39; 时 dp[i]=dp[i-2]+2</code>;</li><li>2形如<code>&quot;...))&quot; </code>当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;)&#39; </code>时 当前一个子串之前的有<code>(</code>能与s[i]的<code>)</code>配对时，需<code> +2+(之前的子串长度</code><ul><li> <code>if(s[i-dp[i-1]-2]==&#39;(&#39;)</code> 则<code>dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]</code></li></ul></li><li>注意每一次赋值判断之前都要判断s和dp是否可能发生越界！！细节太多了！</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;=<span class="number">2</span>) dp[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&lt;<span class="number">0</span>) dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候需要定义<code>dp[]</code>数组长度+1，还真实一个苦恼的问题</p><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>状态：<code>dp[i][0]</code> 第i天不持有的最大利润;<code>dp[i][1]</code> 第i天持有的最大利润</li><li>初始化:<code>dp[0][0] = 0; dp[0][1] = -prices[0]</code>   ；终点：<code>dp[n-1][0]</code> </li><li>只能买卖一次 说明买入的时候 资产为<code>-prices[i]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只能买卖一次 说明买入的时候 资产为-price[i]</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少空见复杂度,重复利用<code>dp[]数组</code>的空间</p><ul><li><code>% 2</code>还可以写成 <code>&amp; 1</code>，这里为了保证可读性，选用 <code>% 2</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(n-<span class="number">1</span>)&amp;<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//与运算博大精深啊</span></span><br><span class="line">        <span class="comment">//return Math.max(dp[1][0],dp[0][0]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><blockquote><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><ul><li>状态 <code>dp[i][j]</code>表示索引<code>i</code>天状态<code>j</code>下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</li><li>初始化 第一天：<code>dp[0][0]=dp[0][2]=dp[0][4]=0</code>; <code>dp[0][1]=dp[0][3]=-prices[0] </code> 终点<code>dp[n-1][2or4]</code></li><li>动态迭代 <code>dp[i][0] = 0; dp[i][1] =max(-prices[i],dp[i-1][1]); dp[i][2] = max(dp[i-1][1]+prices[i],dp[i-1][2]);</code></li><li><code>dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3]); dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4]);</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态 dp[i][j]表示索引i天状态j下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>]= dp[<span class="number">0</span>][<span class="number">3</span>] =-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]= dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">2</span>],dp[n-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//状态：0表示未交易 1表示买入一次 2表示卖出一次 3表示买入两次 4表示卖出两次</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">4</span>] = Math.max(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><blockquote><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>状态（0到2k） 0表示未交易 1表示买入一次 2表示卖出一次…2k-1表示买入k次，2k表示卖出k次</li><li>初始化：<code>dp[0]</code>始终为0；<code>dp[1]= - prices[0]</code>；<code>dp[2-end]</code>初始化为一个小值</li><li>动态迭代：<ul><li><strong>外层循环</strong>为考虑的天数，从<code>i=1:n-1</code></li><li><strong>内层循环</strong>为遍历所有状态：从<code>j=1:2k</code></li><li>如果当前状态索引j为奇数，也就是手头有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] - prices[i])</code></li><li>如果当前状态索引j为偶数，也就是手头没有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] + prices[i])</code></li></ul></li><li>终点为数组<code>dp[] </code>的最大值</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[]:2k+1;  dp[2*k-1]买入k次  dp[2*k]表示卖出k次</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        k = Math.min(k,n/<span class="number">2</span>); <span class="comment">//最多进行n/2次交易！！</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp为小值</span></span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i++) dp[i]= Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//按天数动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]+prices[i],dp[j]);</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">1</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]-prices[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><blockquote><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>//<code>dp[i][j]</code> 表示n1以<code>i</code>开头、n2以<code>j</code>开头的子数组的最长公共子数组长度 即<code>nums1[i:end] nums2[j:end]</code></li><li>//初始化<code>dp[m-1][n-1]=0or1</code>;<code> dp[m-1][j]=0or1; dp[i][n-1]=0or1</code>; 终点<code>dp[0][0]</code>，求数组<code>dp[][]</code>的最大值</li><li>//动态迭代 <code>nums1[i]==nums2[j]? dp[i][j] = dp[i+1][j+1]+1:0</code>;</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个反序推导的题</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[m-<span class="number">1</span>]==nums2[j]) dp[m-<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]==nums2[n-<span class="number">1</span>]) dp[i][n-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] =  nums1[i]==nums2[j]? dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;res) res = dp[i][j];          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接定义<code>dp[][]</code>数组的长度为<code>[m+1,n+1]</code>,那样就不用初始化了</p><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li><code>dp[i]</code>表示偷窃前<code>i</code>个房屋所能获得的最大金额</li><li>初始化 <code>dp[0]=nums[0]</code> <code>dp[1]=Max(dp[0],nums[1])</code>; 终点<code>dp[n-1]</code></li><li>动态迭代 <code>dp[i] = Max(dp[i-1],dp[i-1]+nums[i])</code>;</li></ul><p>代码: 如果使用滚动数组可以减少空间复杂度、不列出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示偷窃前i个房屋所能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; dp[<span class="number">1</span>]=Math.max(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p></blockquote><p>思路：</p><ul><li><code>dp[i] </code>表示前<code>i</code>件范围盗窃 最大金额</li><li><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code>;</li><li>如果第一件盗窃 则盗窃范围为[0,n-2]</li><li>如果第一间不盗窃 范围为[1,n-1]</li><li><strong>因为要用到<code>dp[i-2]</code>，所以用<code>dp[0]=0</code>表示不盗窃！！</strong></li></ul><p>代码一：两个<code>dp[]</code>数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相当于两个动态规划的叠加 1盗窃第一间房[0,n-2] 2不盗窃第一间房[1,n-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]; <span class="comment">//盗窃第一间房</span></span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]; <span class="comment">//盗窃了第二间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">            dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1[n-<span class="number">1</span>],dp2[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：滚动数组优化空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一件盗窃 则盗窃范围为[0,n-2]</span></span><br><span class="line">        <span class="comment">//如果第一间不盗窃 范围为[1,n-1]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//前3 后3</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">2</span>],Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//初始化 至少有四个元素</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">3</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = Math.max(nums[<span class="number">2</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//两种情况循环次数是一样的 注意i的大小就好了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+nums[i]);</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//第二种情况</span></span><br><span class="line">            dp[<span class="number">5</span>] = Math.max(dp[<span class="number">4</span>],dp[<span class="number">3</span>]+nums[i+<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">4</span>];</span><br><span class="line">            dp[<span class="number">4</span>] = dp[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//System.out.println(dp[5]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><blockquote><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure></blockquote><p>思路：注意负负得正</p><ul><li>因为 负负得正，一个负数乘一个很小的负数可能得到一个很大的乘积，所以对每个i索引要分别保存最大乘积和最小乘积</li><li><code>dp[i][0]</code>表示<code>i</code>索引元素结尾的连续子数组的最大乘积 <code>dp[i][1]</code>表示最小乘积</li><li>初始化<code>dp[0][0]=dp[0][1]=nums[0]</code>; 终点<code>dp[i][0]</code>数组的最大值</li><li>动态迭代 <code>dp[i][0] = max(dp[i-1][0]*numd[i],dp[i-1][1]*nums[i],nums[i])</code>; <code>dp[i][1] = min(...)</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][0]表示i索引元素结尾的连续子数组的最大乘积 dp[i][1]表示最小乘积</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            max = Math.max(max,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p></blockquote><p>思路：</p><ul><li>动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</li><li><code>dp[i]</code>表示第<code>i</code>个字符前的子串解码方法的总数，<strong>因为要用到<code>i-2</code>所以令<code>dp[0]=1</code>代表空字符串</strong></li><li>初始化 <code>dp[0]=dp[1]=1</code>; 终点<code>dp[n]</code></li><li>动态迭代 单个字符结尾<code>s[i]!=&#39;0&#39; dp[i] += dp[i-1]</code>;</li><li>两个字符结尾 <code>s[i-1]!=&#39;0&#39;&amp;&amp; s[i-1]s[i]&lt;=26 dp[i] += dp[i-2]</code>;</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</span></span><br><span class="line">        <span class="comment">//dp[i]表示第i个字符前的子串解码方法的总数</span></span><br><span class="line">        <span class="comment">//因为要用到i-2所以令dp[0]=1代表空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)!=<span class="string">&#x27;0&#x27;</span>) dp[i] +=dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>)!=<span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">2</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h3><blockquote><p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：k &#x3D; 1, n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f &#x3D; 0 。 </span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f &#x3D; 1 。 </span><br><span class="line">如果它没碎，那么肯定能得出 f &#x3D; 2 。 </span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：k &#x3D; 2, n &#x3D; 6</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：k &#x3D; 3, n &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure></blockquote><p>思路：动态规划+二分查找</p><ul><li>动态规划 <code>dp[i][j]</code>表示用<code>i</code>个鸡蛋确定<code>j</code>层楼房的f值 的最小操作数</li><li>初始化 <code>dp[i][1]= 1 </code>一层楼房 抛一次就确定了 ；<code>dp[1][j]=j </code>一个鸡蛋确定<code>j</code>层楼房 从下往上试直到摔破共<code>j</code>次</li><li>终点<code> dp[k][n]</code></li><li>动态迭代 外层<code>i从2到k个鸡蛋</code> 内层<code>j从2层到n层楼房</code>； 如果不用二分、第三层 <code>x从1到n</code></li><li><code>dp[k][n] = 1+ min( max( dp[k-1,x-1] , dp[k,n-x]) )</code> 摔破/没摔破 取所有x的小值</li><li><strong><code>dp[k-1][x-1]</code>随x递增 <code>dp[k][x-k]</code>随x递减,，注意画这两个单调数列的图（两条直线），就明白如何用二分了，取两个函数的大值，就是上边的折线，然后找整个折线的最小值</strong></li><li>使用二分找到 <code>dp[k-1][x-1] &lt; dp[k][n-x]</code> 的最后一个x0，，然后比较获得<code>min(T1(x0+1), T2(x0))</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示用i个鸡蛋确定j层楼房的f值 的最小操作数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) dp[i][<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">1</span>][j]= j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果不用二分算法</span></span><br><span class="line">                <span class="comment">// int min = n+1;</span></span><br><span class="line">                <span class="comment">// for(int x=1;x&lt;=j;x++)&#123;</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = 1 + Math.min(min, Math.max(dp[i-1][x-1],dp[i][j-x])) </span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//二分算法</span></span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = j;</span><br><span class="line">                <span class="comment">//要找T1小于T2的最大x0</span></span><br><span class="line">                <span class="keyword">int</span> x0=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">                    x0 = left+(right-left)/<span class="number">2</span>; </span><br><span class="line">                    <span class="keyword">if</span>( dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&lt;dp[i][j-x0])&#123;</span><br><span class="line">                        left = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&gt;dp[i][j-x0])&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断right和left谁才是真正要找的x0的位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][right-<span class="number">1</span>]&lt;=dp[i][j-right]) x0=right;</span><br><span class="line">                <span class="keyword">else</span> x0= left;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//所以最小值 min(T1(x0+1),T2(x0))</span></span><br><span class="line">                dp[i][j] =<span class="number">1</span> + Math.min(dp[i-<span class="number">1</span>][x0+<span class="number">1</span>-<span class="number">1</span>], dp[i][j-x0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h3><blockquote><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure></blockquote><p>思路：</p><ul><li>动态规划 <code>dp[i][j]</code>表示索引<code>i</code>之前的数能够构造出结果<code>j</code>的表达式数目</li><li>因为属于j[-1000,1000], 所以事实上用<code>dp[i][j+1000]</code>，</li><li>动态规划 <code>dp[i][j+1000-nums[i]] += dp[i-1][j+1000];</code> //对应-号</li><li><code>dp[i][j+1000+nums[i]] += dp[i-1][j+1000]</code>; //对应+号</li><li><code>i</code>外层循环<code>[0，n-1]</code>；<code> j</code>内层循环<code>[-1000，1000]</code></li><li>不知道初始化谁，就手动循环一遍发现只用<code>i=0, dp[0][j+1000]+=1</code>就好了,其中<code>j=nums[0]/-nums[0]</code>,一定要+=防止出现多个0的情况！！、其他必然为0</li><li>终点 <code>dp[n-1][target+1000]</code>;</li><li>对于<code>j</code>的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别，就是用<code>[j]</code>更新<code>[j+/-nums[i]]</code><ul><li>如果<code>dp[i - 1][j]==0</code>就没有进入更新的必要</li></ul></li></ul><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示索引i之前的数能够构造出结果j的表达式数目</span></span><br><span class="line">        <span class="comment">// 因为属于j[-1000,1000],所以事实上用dp[i][j+1000]，</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2001</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1000</span>;j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//对于j的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别</span></span><br><span class="line">                <span class="comment">//就是用[j]更新[j+/-nums[i]]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j + <span class="number">1000</span>] &gt; <span class="number">0</span>)&#123; <span class="comment">//如果==0就没有进入更新的必要</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>-nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应-号</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>+nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应+号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleavingz-string/">97. 交错字符串</a></h3><blockquote><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>提示：a + b 意味着字符串 a 和 b 连接。</p></blockquote><p>思路:</p><ul><li><del>开始我想错了 以为i、j之差不能超过1,没必要没必要</del></li><li><code>dp[i][j]</code>表示s1的前<code>i</code>个与s2的前<code>j</code>个能否交错组成s3的前<code>(i+j)</code>个s3，，s1+s2与s3长度若不相等直接返回false</li><li>初始化<code>dp[0][j]=true</code>仅当<code>s2[0:j-1]=s3[0:j]</code>;    <code>dp[i][0]=true仅当s1[0:i-1]=s3[0:i]</code></li><li>动态迭代 <code>dp[i][j] = dp[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1]</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示s1的前i个与s2的前j个能否交错组成s3的前(i+j)个s3</span></span><br><span class="line">        <span class="keyword">int</span> m =s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(n+m!=s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = ( dp[i-<span class="number">1</span>][j]&amp;&amp;s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>+j) ) || </span><br><span class="line">                        (dp[i][j-<span class="number">1</span>]&amp;&amp;s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-背包问题-领扣）"><a href="#5-背包问题-领扣）" class="headerlink" title="5 背包问题(领扣）"></a>5 背包问题(领扣）</h2><p>我为什么这么菜？还是直接以题代学。领扣上面有全套的背包题。</p><h3 id="125-·-背包问题（二）"><a href="#125-·-背包问题（二）" class="headerlink" title="125 · 背包问题（二）"></a><a href="https://www.lintcode.com/problem/125/description">125 · 背包问题（二）</a></h3><blockquote><p>描述</p><p>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值.</p><p>问最多能装入背包的总价值是多大?</p><p><code>A[i], V[i], n, m</code> 均为整数你不能将物品进行切分你所挑选的要装入背包的物品的总大小不能超过 <code>m</code>每个物品只能取一次</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D; 10</span><br><span class="line">A &#x3D; [2, 3, 5, 7]</span><br><span class="line">V &#x3D; [1, 5, 2, 4]</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p>解释：</p><p>装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9</p></blockquote><p><strong>就是最基础的01背包问题，每一个物品只能用一次。</strong></p><p>思路1：二维数组</p><ul><li><code>dp[i][j]</code>表示前<code>i</code>个物品装入<code>j</code>大小的背包 的最大总价值数</li><li>初始化<code>dp=[i][0]0</code>; 终点<code>dp[n][m]</code></li><li>动态迭代：i的范围<code>[1,n]</code>  j的范围<code>[0,m]</code>  状态分别对应将第i个物品装入背包和不装入背包两种情况</li></ul><p>$$<br>dp[i][j]=max(dp[i-1][j], dp[i-1][j-A[i-1]]+V[i-1])<br>$$</p><p>代码1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品装入j大小的背包 的最大总价值数</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&lt;<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max( dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+ V[i-<span class="number">1</span>] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：空间优化的一维数组</p><p>我们发现，欲求<code> dp[i][j]</code>需要使用<code>dp[i-1][j]</code>和<code>dp[i-1][j-A[i-1]]</code>两种状态，显然就是计算<code>i</code>时需要<code>i-1</code>时候的状态！！ 令状态<code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>能装的最大价值数，每遍历完一次、就更新了该数组一次。状态转移方程：<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$<br>但是这时出现了一个问题：如果<code>j</code>仍然从0遍历到最大容量m，，，<code>dp[j-A[i-1]]</code>总是先于<code>dp[j]</code>更新，所以更新过程，用到了更新的数组的值、当然就有问题了。。</p><p><strong>这个时候就需要反向遍历,<code>j</code>仍然从m遍历到0，，计算索引靠右边的<code>dp[j]</code>时，利用的是上一个数组中的<code>dp[j]</code>和没有更新的索引位置较小的<code>dp[j-x]</code></strong></p><p>动态规划的要素如下：</p><ul><li><code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>的背包能装的最大价值数</li><li>初始化dp[j]=0标识0个物品时的最大价值 , 终点dp[m]标识n个物品时容量m背包的最大价值数</li><li>动态迭代 j从m迭代到0，状态转移方程如上 ，<strong>i还是从1迭代到n，，时间并没有优化！！</strong></li></ul><p>代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>) dp[j] = Math.max(dp[j],dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="92-·-背包问题"><a href="#92-·-背包问题" class="headerlink" title="92 · 背包问题"></a><a href="https://www.lintcode.com/problem/92/description">92 · 背包问题</a></h3><blockquote><p>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为A[i]</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组 &#x3D; [3,4,8,5]</span><br><span class="line">backpack size &#x3D; 10</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></blockquote><p>思路：就是01背包问题，然后体积和价值是同一个数组</p><p>代码：一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实就是01背包问题，然后体积和价值是同一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=A[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+A[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="440-·-背包问题-III"><a href="#440-·-背包问题-III" class="headerlink" title="440 · 背包问题 III"></a><a href="https://www.lintcode.com/problem/440/">440 · 背包问题 III</a></h3><blockquote><p>给定 <code>n</code> 种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p><p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p><p>不能将一个物品分成小块.放入背包的物品的总大小不能超过 <code>m</code>.</p><p><strong>样例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4], m &#x3D; 10</span><br><span class="line">输出: 15</span><br><span class="line">解释: 装入三个物品 1 (A[1] &#x3D; 3, V[1] &#x3D; 5), 总价值 15.</span><br></pre></td></tr></table></figure></blockquote><p><strong>就是最经典的完全背包问题，每一个物品只能无限次。</strong></p><p>思路1：三层循环</p><ul><li><code>dp[i][j]</code>表示前i个物品任意取，背包容量为j时的最大价值</li><li>初始化 <code>dp[i][0]=0</code>; 终点<code>dp[n][m]</code></li><li>动态迭代 第<code>i</code>个物品最多使用的个数是 <code>m/A[i-1]</code>    k取0到<code>m/A[i-1]</code></li><li><code>dp[i][j] = max( dp[i-1][j-k*A[i-1]]+k*V[i-1])</code></li></ul><p>代码1：就嗯循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j];</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;=m/A[i-<span class="number">1</span>];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k*A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]]+k*V[i-<span class="number">1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：O(nm)的算法，翻转01背包的遍历顺序即可！！这里摘用一下《背包九讲》中的解释</p><blockquote><p>首先想想为什么 01 背包中要按照 j 递减的次序来循环。让 j 递减是为了保证第i次循环中的状态 <code>dp[i, j]</code> 是由状态 <code>dp[i − 1, j − Ai]</code> 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 <code>i </code>件物品”这件策略时，依据的是一个绝无已经选入第 <code>i </code>件物品的子结果 <code>dp[i − 1, j − Ai]</code>。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第<code> i</code> 种物品”这种策略时，却正需要一个可能已选入第<code>i</code>种物品的子结果 <code>dp[i, j − Ai]</code>，所以就可以并且必须采用 <code>j</code>递增的顺序循环。这就是这个简单的程序为何成立的道理。</p></blockquote><ul><li><p>//完全背包 时间空间都优化</p></li><li><p>//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</p></li><li><p>//初始化 dp[0]=0; 终点dp[m]</p></li><li><p>//动态迭代 j从0迭代到m，，i还是从1迭代到n，，O(mn)时间复杂度！！<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$</p></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//完全背包 时间空间都优化</span></span><br><span class="line">        <span class="comment">//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i-<span class="number">1</span>];j&lt;=m;j++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/comments/377874&quot;&gt;“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/comments/401721&quot;&gt;“十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wukang555.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="力扣" scheme="https://wukang555.github.io/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="动态规划" scheme="https://wukang555.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Redis面经</title>
    <link href="https://wukang555.github.io/2021/08/03/%E9%9D%A2%E7%BB%8F_09_Redis/"/>
    <id>https://wukang555.github.io/2021/08/03/%E9%9D%A2%E7%BB%8F_09_Redis/</id>
    <published>2021-08-03T14:55:00.000Z</published>
    <updated>2022-05-17T12:19:32.417Z</updated>
    
    <content type="html"><![CDATA[<p>Redis系统的理解和介绍。</p><a id="more"></a><blockquote><p>[1] 主要参考了库森的总结<a href="https://github.com/cosen1024/Java-Interview/blob/main/Redis/Redis.md">十分全面</a></p><p>文章的结构也基本是库森文章的简化。</p><p>先说明redis是什么、有什么优点、使用场景是什么</p><p>然后具体谈谈redis的一些特性 比如数据类型、持久化、事务、单线程</p><p>使用redis可能带来的问题：缓存淘汰策略、缓存一致性、缓存穿透、缓存雪崩</p><p>结构和模式：主从复制、哨兵模式、集群模式；</p><p>最后是Redis实际使用的优化</p></blockquote><h1 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1 Redis概述"></a>1 Redis概述</h1><h2 id="1-1-Redis是什么？它的优缺点？【重要】"><a href="#1-1-Redis是什么？它的优缺点？【重要】" class="headerlink" title="1.1 Redis是什么？它的优缺点？【重要】"></a>1.1 Redis是什么？它的优缺点？【重要】</h2><p>﻿Redis本质上是一个Key-Value键值对的非关系型数据库，整个数据库加载在内存中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。Redis最大的特点就是性能好，每秒可以处理超过 10万次读写操作。</p><p>优点：</p><ul><li>读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s</li><li>数据结构丰富，除了支持string类型外，还支持hash、set、zset、list等数据结构。</li><li>支持数据持久化，支持AOF和RDB两种持久化方式。</li><li>支持事务， Redis的所有操作都是原子性的，一般通过MULTI和EXEC将指令打包实现事务。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>缺点：</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。（因为内存根本放不下海量数据嘛）</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换主机后可能导致数据不一致的问题，降低了系统的可用性。（缓存一致性问题）</li></ul><h2 id="1-2-Redis的常用场景有哪些"><a href="#1-2-Redis的常用场景有哪些" class="headerlink" title="1.2 Redis的常用场景有哪些?"></a>1.2 Redis的常用场景有哪些?</h2><p><strong>1、缓存（定期删除、淘汰策略是为缓存准备的）</strong></p><p>缓存现在几乎是所有中大型网站都在用的必杀技<strong>，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力</strong>。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><p><strong>2、分布式会话</strong></p><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建<strong>以Redis等内存数据库为中心的session服务</strong>，session不再由容器管理，而是由session服务及内存数据库管理。（就是说session放在redis中、也就是类似无状态登录嘛）</p><p><strong>3、分布式锁</strong></p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><p><strong>4、 社交网络</strong></p><p>点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，<strong>Redis提供的哈希、集合等数据结构</strong>能很方便的的实现这些功能。如在微博中的<strong>共同好友</strong>，通过Redis的set能够很方便得出。</p><p><strong>5、排行榜</strong></p><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的<strong>有序集合数据类</strong>构能实现各种复杂的排行榜应用。</p><h2 id="1-3-关系型数据库和非关系型数据库的区别【理解背】"><a href="#1-3-关系型数据库和非关系型数据库的区别【理解背】" class="headerlink" title="1.3 关系型数据库和非关系型数据库的区别【理解背】"></a>1.3 关系型数据库和非关系型数据库的区别【理解背】</h2><ul><li><p>关系型数据库：</p><ul><li>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</li><li>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</li><li>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</li></ul></li><li><p>非关系型数据库 not only SQL</p><ul><li>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</li><li>面向高性能并发读写的key-value数据库</li><li>面向可扩展性的分布式数据库</li></ul></li></ul><p>数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库</p><h1 id="2-Redis的数据结构、持久化、事务-和单线程"><a href="#2-Redis的数据结构、持久化、事务-和单线程" class="headerlink" title="2 Redis的数据结构、持久化、事务 和单线程"></a>2 Redis的数据结构、持久化、事务 和单线程</h1><blockquote><p>redis最基本的一些特性</p></blockquote><h2 id="2-1-Redis的数据结构【重要】"><a href="#2-1-Redis的数据结构【重要】" class="headerlink" title="2.1 Redis的数据结构【重要】"></a>2.1 Redis的数据结构【重要】</h2><p>有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中HyperLogLog、Bitmap的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。</p><p><strong>五种常用的数据类型</strong>【重要】：</p><p>1、String：String是最常用的一种数据类型，普通的key- value 存储都可以归为此类。其中Value既可以是数字也可以是字符串。使用场景：常规key-value缓存应用。常规计数: 微博数， 粉丝数。</p><p>2、Hash：Hash 是一个键值(key =&gt; value)对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值。（类似hashmap）</p><p>3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。(类似hashset)</p><p>4、List：List是一个有序可重复的集合，其遵循FIFO的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于最新回复这类的功能实现。(类似linkedlist)</p><p>5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。适用于排行榜和带权重的消息队列等场景。</p><p><strong>三种特殊的数据类型</strong>：</p><p>1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p><p>2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。场景：统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><p>3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。</p><h2 id="2-2-Redis-的持久化【重要】"><a href="#2-2-Redis-的持久化【重要】" class="headerlink" title="2.2 Redis 的持久化【重要】"></a>2.2 Redis 的持久化【重要】</h2><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化。</p><p>Redis 支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><ul><li><strong>快照：（数据可能丢失）</strong></li></ul><p>快照就是根据设置的时间间隔和更新次数来判断是否进行数据的备份，设置命令是save 900 1(就是指900秒内如果至少有一个key进行了修改，就进行持久化的操作)。快照的备份通过单独创建子进程来完成，备份过程中主进程不进行任何的IO操作，确保了极高的性能。适合于对大规模数据的恢复</p><p>快照的缺点是：1创建子进程会占用一定的内存空间；2 最后一次持久化之后的数据可能丢失</p><ul><li><strong>AOF:（修复速度慢）</strong></li></ul><p>AOF持久化是记录每一次修改redis数据的命令。AOF默认是关闭的，可以在配置文件中开启，一般有三个选项：每次修改都写入AOF文件、每秒一次写入AOF文件、由操作系统决定何时同步。AOF的实时性更好，但如果选择每次修改都写入时，可能会降低redis的性能；建议选择每秒同步一次，这样Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。</p><p>AOF的缺点是，AOF文件的大小远远大于 数据文件，AOF的修复速度也比数据文件慢！</p><h2 id="2-3-Redis-的事务【重要】"><a href="#2-3-Redis-的事务【重要】" class="headerlink" title="2.3 Redis 的事务【重要】"></a>2.3 Redis 的事务【重要】</h2><p>Redis事务的简单理解就是<strong>将多个命令打包、放入一个队列中、然后一起执行所有命令</strong>。因为某条命令执行失败不会影响其他命令，所以Redis的事务严格来说并不是原子性的。</p><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><ul><li>使用 <a href="https://redis.io/commands/multi"><code>MULTI</code></a>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec"><code>EXEC</code></a>命令将执行所有命令。</li><li>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</li><li><a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话(<strong>在本事务外被修改</strong>)，整个事务都不会执行，直接返回失败。</li></ul><p>Redis事务之所以不支持回滚（以实现原子性）是因为认为错误的指令应该在开发过程就发现，而不应该出现在生产环境中。因为不用支持回滚、Redis的设计可以保持简单和高效。Watch命令的监视功能类似于乐观锁，发现了key被其他事务修改之后，可以是队列中后面的命令失效。</p><h2 id="2-4-Redis单线程【略重要】"><a href="#2-4-Redis单线程【略重要】" class="headerlink" title="2.4 Redis单线程【略重要】"></a>2.4 Redis单线程【略重要】</h2><p><strong>1 Redis为何选择单线程？</strong>【重要】</p><blockquote><p>Redis6.0引入多线程I/O，只是用来处理网络数据的读写和协议的解析，而执行命令依旧是单线程。</p></blockquote><p>在Redis 6.0以前，Redis的核心网络模型选择用单线程来实现。简单的原因就是大多数请求都是 I/O 密集型的，而不会是 CPU 密集型的。Redis的执行速度是非常快的，Redis真正的性能瓶颈常常在于网络 I/O，因此Redis选择了单线程的 I/O 多路复用来实现它的核心网络模型。（多路复用思想也存在于http2.0中）</p><p>主要的原因还包括：</p><ul><li><p>单线程避免过多的上下文切换开销</p></li><li><p>避免数据同步机制的开销</p></li><li><p>简单可维护</p></li></ul><p>总而言之，Redis选择单线程可以说是一种权衡的选择：在保证足够的性能的前提下，使用单线程保持代码的简单和可维护性。</p><p><strong>2 Redis6.0又支持多线程主要原因：</strong></p><ul><li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核（单线程浪费了cpu等待网络IO的时间）</li><li>多线程任务可以分摊 Redis 同步 IO 读写负荷</li></ul><p><strong>3  IO 多路复用机制</strong>【了解】</p><p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p><h1 id="3-Redis-缓存可能带来的问题及解决"><a href="#3-Redis-缓存可能带来的问题及解决" class="headerlink" title="3 Redis 缓存可能带来的问题及解决"></a>3 Redis 缓存可能带来的问题及解决</h1><blockquote><p>使用redis可能带来的问题：过期key删除、缓存淘汰策略、缓存一致性、缓存穿透、缓存雪崩。</p><p>1 使用缓存、缓存的容量是有限的，如果使缓存中始终存“热点的数据”，这是首先要考虑的。也就是放什么样的数据到缓存中、以及如何淘汰数据（淘汰策略）</p><p>2 缓存和数据库存在着一个同步的问题，如何保证缓存一致性（读写顺序！！）</p><p>3 某些极端的攻击，引发的缓存穿透、缓存雪崩问题应该如何解决</p></blockquote><h2 id="3-1-Redis过期键的删除策略"><a href="#3-1-Redis过期键的删除策略" class="headerlink" title="3.1 Redis过期键的删除策略"></a>3.1 Redis过期键的删除策略</h2><blockquote><p>通过expire或pexpire命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。</p></blockquote><p><strong>Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。</strong></p><p><strong>1、惰性删除</strong></p><p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><p>优点：对 CPU友好，只会在使用该键时才会进行过期检查</p><p>缺点：对内存不友好，不用的键就会一直存在内存中</p><p><strong>2、定期删除</strong></p><p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p><p>优点：对CPU和内存都友好</p><p>缺点：难以确定删除操作执行的时长和频率。可能出现过期了还没有被删除的问题。</p><h2 id="3-2-Redis缓存淘汰策略【略重要】"><a href="#3-2-Redis缓存淘汰策略【略重要】" class="headerlink" title="3.2 Redis缓存淘汰策略【略重要】"></a>3.2 Redis缓存淘汰策略【略重要】</h2><blockquote><p>设置了过期时间的数据由过期键的删除策略负责删除（也可以通过淘汰策略）</p><p>如果没有设置过期时间的数据（很多），通过淘汰策略来删除。当Redis的内存超过最大允许的内存之后，Redis会触发<strong>内存淘汰策略</strong>，删除一些不常用的数据</p></blockquote><p><strong>Redisv4.0前提供 6种数据淘汰策略</strong>：</p><ul><li>volatile-lru：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（<strong>这个是最常用的</strong>）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！【居然是默认】</li></ul><p><strong>Redisv4.0后增加以下两种</strong>：</p><ul><li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ul><h2 id="3-3-缓存不一致问题及解决"><a href="#3-3-缓存不一致问题及解决" class="headerlink" title="3.3 缓存不一致问题及解决"></a>3.3 缓存不一致问题及解决</h2><blockquote><p>缓存不一致问题一般出现于要更新数据库的时候。处理缓存不一致问题主要有两种方案：</p><p>1 先删除缓存，后更新数据库</p><p>2 先更新数据库，后删除缓存</p><p>其他的方案诸如： 先更新数据库在更新缓存，并发会有脏数据进缓存。 先更新缓存在更新数据库，可能更缓存成功、更数据库失败照成不一致问题。</p></blockquote><p><strong>1 先删除缓存，后更新数据库</strong></p><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><blockquote><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ol><p>就是查询操作B可能将数据库中旧值更新到缓存中，照成缓存不一致</p></blockquote><p>解决办法就是<strong>“延时双删”</strong>，步骤如下（就是两次删除一次更新、更新后记得延时一下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）先淘汰缓存 </span><br><span class="line">（<span class="number">2</span>）再写数据库（这两步和原来一样）</span><br><span class="line">（<span class="number">3</span>）休眠<span class="number">1</span>秒，再次淘汰缓存</span><br></pre></td></tr></table></figure><p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求B结束后，写请求A可以删除读请求造成的缓存脏数据。</p><p><strong>2 先更新数据库，后删除缓存</strong></p><blockquote><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p></blockquote><p>解决办法是利用消息队列，确保消息操作能够可靠的被消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 请求 A 先对数据库进行更新操作</span><br><span class="line"><span class="number">2</span> 在对 Redis 进行删除操作的时候发现报错，删除失败</span><br><span class="line"><span class="number">3</span> 此时将Redis 的 key 作为消息体发送到消息队列中</span><br><span class="line"><span class="number">4</span> 系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</span><br></pre></td></tr></table></figure><h2 id="3-4-缓存穿透的问题及解决【重要】"><a href="#3-4-缓存穿透的问题及解决【重要】" class="headerlink" title="3.4 缓存穿透的问题及解决【重要】"></a>3.4 缓存穿透的问题及解决【重要】</h2><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212640.png" alt="image-20210707115232430"></p><blockquote><p>解决缓存穿透问题，最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。</p></blockquote><p>解决方法：除了基本的参数校验方法外，还有<strong>缓存无效key和布隆过滤器</strong></p><p><strong>1 缓存无效key</strong>（将无效的key缓存到redis中）</p><p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。这种方式可以解决请求的 key 变化不频繁的情况。（当key变化频繁时无法解决问题）</p><p><strong>2 布隆过滤器</strong>（就是多加一层布隆过滤器的判断，不在布隆过滤器中就直接返回null）</p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>布隆过滤器可能出现小概率的误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><blockquote><p>布隆过滤器的原理是根据哈希函数对是元素值进行计算，映射到数组中来判断是否存在。</p></blockquote><h2 id="3-5-缓存雪崩的问题及解决【重要】"><a href="#3-5-缓存雪崩的问题及解决【重要】" class="headerlink" title="3.5 缓存雪崩的问题及解决【重要】"></a>3.5 缓存雪崩的问题及解决【重要】</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong>可能导致宕机。</p><p><strong>缓存雪崩的原因</strong></p><ul><li>系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</li><li>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</li></ul><p><strong>缓存雪崩的解决办法：</strong></p><ul><li><p>针对 Redis 服务不可用的情况：</p><ul><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ul></li><li><p>针对热点缓存失效的情况：</p><ul><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ul></li></ul><h1 id="4-Redis的主从、哨兵、集群"><a href="#4-Redis的主从、哨兵、集群" class="headerlink" title="4 Redis的主从、哨兵、集群"></a>4 Redis的主从、哨兵、集群</h1><blockquote><p>Redis的应用模式比如主从复制、哨兵模式、redis集群。。感觉这部分比较难</p><p>主从复制原理？</p><p>被选举为master的标准？</p><p>集群是如何实现数据分布的?优点</p><p>集群的通信机制</p></blockquote><h2 id="4-1-主从复制架构"><a href="#4-1-主从复制架构" class="headerlink" title="4.1 主从复制架构"></a>4.1 主从复制架构</h2><p>Redis主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）。</p><p><strong>主从机的特点：</strong></p><ul><li><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动在从机中保存！</p></li><li><p>主机断开连接，从机依旧连接到主机的。主机后面如果回来了，从机依旧可以直接获取到该主机写的信息！</p></li><li><p>如果从机重启了（命令行来配置的主从的情况），就会变回主机（默认）！只要（重新设置）变为从机，立马就会从主机中获取值！</p><ul><li>只要是重新连接master，一次完全同步（全量复制）将被自动执行！</li></ul></li></ul><p><strong>复制原理：</strong></p><p>Slave 启动成功连接到 master 后会发送一个sync同步命令。Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li>全量复制：（全部复制）</li><li>增量复制：（复制更新的部分）</li></ul><p><strong>缺点：</strong></p><p><strong>如果主机因为故障断开了连接，我们只能手动配置主机、从机。</strong>升级为哨兵模式就是为了解决这个问题，实现自动配置主从！！</p><h2 id="4-2-哨兵模式架构"><a href="#4-2-哨兵模式架构" class="headerlink" title="4.2 哨兵模式架构"></a>4.2 哨兵模式架构</h2><blockquote><p>主机故障之后，自主配置新主机从机！！</p></blockquote><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵是一个独立的进程，作为进程，它会独立运行。</p><p>==其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。==</p><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ol><p><strong>缺点：</strong></p><ol><li>Redis 不好线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，实现起来相对复杂！</li></ol><h2 id="4-3-Redis集群架构（Redis-Cluster）"><a href="#4-3-Redis集群架构（Redis-Cluster）" class="headerlink" title="4.3 Redis集群架构（Redis Cluster）"></a>4.3 Redis集群架构（Redis Cluster）</h2><blockquote><p>哨兵模式虽然已经高可用了，但是备份太多相同的数据，是浪费内存的操作。</p><p> Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。（也能够缓解内存数据库不能存海量数据的缺点）</p></blockquote><p>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p><strong>优点：</strong></p><ul><li>无中心架构；</li><li>可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ul><p><strong>缺点（缺点也有很多）：</strong></p><ul><li>Client实现复杂</li><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li><li>Slave在集群中充当“冷备”，不能缓解读压力</li><li>Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。</li><li>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。</li><li>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。</li><li>不支持多数据库空间，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</li></ul><h2 id="4-4-几个常问的问题【重要】"><a href="#4-4-几个常问的问题【重要】" class="headerlink" title="4.4 几个常问的问题【重要】"></a>4.4 几个常问的问题【重要】</h2><p>1 Redis哨兵是怎么工作的？主观下线、客观下线 </p><ul><li>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。如果监测到某个Master回复时间超过指定的值，就认为这个Master宕机了，标记为<strong>主观下线</strong>的状态</li><li>其他Sentinel发送命令确认这个Master是否真的进入了宕机状态。如果有足够多的Sentinel认为这个Master确实主观下线了，那么Master会被标记为<strong>客观下线</strong> 。</li><li>足够多的Sentinel同意Master客观下线之后，就会相互沟通，从选举出一个从节点作为新的Master。其他从节点转移到这个新的主节点上来。</li></ul><p>2 新被选举为master的标准是什么？</p><ul><li><p>跟master断开连接的时长。 如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master.</p></li><li><p>slave优先级。 按照slave优先级进行排序，slave priority越低，优先级就越高</p></li><li><p>复制offset。 如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，优先级就越高</p></li><li><p>run id 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</p></li></ul><h1 id="5-Redis的其他问题（优化）"><a href="#5-Redis的其他问题（优化）" class="headerlink" title="5 Redis的其他问题（优化）"></a>5 Redis的其他问题（优化）</h1><p><strong>1 Redis如何做内存优化？</strong></p><ul><li><strong>控制key的数量</strong>。当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。</li><li><strong>缩减键值对象</strong>，降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。<ul><li>key长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li><li>value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。</li></ul></li></ul><p><strong>2 如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？</strong></p><p>如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。</p><p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。</p><p>如果需要缓存1T+的数据，选择Redis cluster模式，每个主节点存一部分数据，假设一个master存32G，那只需要n*32G&gt;=1T，n个这样的master节点就可以支持1T+的海量数据的存储了。</p><blockquote><p>Redis单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个slave的数据和master的完全一样。假如master是10G那slave也只能存10G数据。所以数据量受单主的影响。 而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis官方给出的 Redis cluster 模式完美的解决了这个问题。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis系统的理解和介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Redis" scheme="https://wukang555.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://wukang555.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>vhr人力资源管理系统面经</title>
    <link href="https://wukang555.github.io/2021/08/02/%E9%9D%A2%E7%BB%8F_08_vhr%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94/"/>
    <id>https://wukang555.github.io/2021/08/02/%E9%9D%A2%E7%BB%8F_08_vhr%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94/</id>
    <published>2021-08-02T14:55:00.000Z</published>
    <updated>2022-05-17T12:19:13.256Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。</p><a id="more"></a><h2 id="1-介绍一下vhr人力资源管理系统"><a href="#1-介绍一下vhr人力资源管理系统" class="headerlink" title="1 介绍一下vhr人力资源管理系统"></a>1 介绍一下vhr人力资源管理系统</h2><p>vhr 是一个前后端分离的人力资源管理系统，包括人事管理、系统管理等模块，基于 Restful 风格开发后端接口、使用 Swagger 进行接口测试；</p><p>技术栈：Spring Boot、Spring Security、MyBatis、MySQL、Redis、RabbitMQ</p><ul><li>1、使用 Spring Security 基于角色的动态访问控制，实现用户认证和用户授权；即根据用户的角色赋予不同的操作权限和显示菜单。</li><li>2、将邮件服务划分为单独的模块、引入消息中间件 RabbitMQ，实现异步发送欢迎新员工的入职邮件；</li><li>3、实现前后端分离，后端不再处理页面跳转仅传递 JSON 字符串，实现了基于 JWT 的无状态登录；</li></ul><h2 id="2-vhr的数据库是怎么设计的？"><a href="#2-vhr的数据库是怎么设计的？" class="headerlink" title="2 vhr的数据库是怎么设计的？"></a>2 vhr的数据库是怎么设计的？</h2><p>面向的用户是公司的管理人员，然后实现了基于角色的动态动态访问控制，基本的就有管理人员的hr表（用户表）、role表（角色表）、menu表（菜单表），然后就是实现用户、角色和菜单之间连接关系的hr_role表（一对多的关系）、menu_role表（多对多的关系）。然后就是其他一些公司的employee表（员工表）、departmen表（部门表）、joblevel表（职称表）等。</p><ul><li>hr用户表，公司的管理人员也就是该系统的使用用户。。一个用户一般拥有一种或者多种角色</li><li>role角色表，不同的角色对用有不同的权限，比如人事专员只管人事、部门经理管理该部门的员工等</li><li>hr表和role表通过 一个hr_role表相联系，即指定一个用户具有哪几种角色</li><li>还有一个menu表，相当于是一个资源表，menu中的数据会以json返回给前端，然后vue动态更新。其中里面最重要的字段就是url、路径匹配规则，所有的请求会被拦截然后根据这个url去查询访问这个url需要什么角色的权限，然后看当前用户是否具备相应的角色。</li><li>menu_role表将menu和role表相联系，即指定某个url会对哪些角色可见（menu和role是多对多的关系）</li></ul><h2 id="3-RESTful风格，介绍一下"><a href="#3-RESTful风格，介绍一下" class="headerlink" title="3 RESTful风格，介绍一下"></a>3 RESTful风格，介绍一下</h2><h3 id="3-1-RESTful风格是什么？"><a href="#3-1-RESTful风格是什么？" class="headerlink" title="3.1 RESTful风格是什么？"></a>3.1 RESTful风格是什么？</h3><blockquote><p>URI统一资源标识符</p><p>URL是统一资源定位符</p></blockquote><p>REST(Representational State Transfer) 指 表现层状态转化。</p><ul><li><p>在web应用中，我们一般用<strong>URI统一资源标识符</strong>来表示一种资源</p></li><li><p>表现层指的是一个”资源“的具体表现形式，比如一个html文本、一个xml或者一个图片都是表现层</p></li><li><p>状态转换就是客户端通过http的几种请求方式（get\post\put\delete）对服务器进行访问，完成资源的状态转换</p><ul><li>GET 用来获取资源、POST 用来新建资源（也可以用于更新资源）、PUT 用来更新资源、DELETE 用来删除资源</li></ul></li></ul><p>REST的核心在于，当你设计一个系统的时候，资源是第一位的考虑，你首先从资源的角度进行系统的拆分、设计，而不是像以往一样以操作为角度来进行设计。</p><p>总的来说就是，RESTful定义了一种客户端和服务器交互的风格，使URL更简洁、更有层次感。</p><h3 id="3-2-RESTful的使用示例"><a href="#3-2-RESTful的使用示例" class="headerlink" title="3.2 RESTful的使用示例"></a>3.2 RESTful的使用示例</h3><p>SpringMVC 对 RESTful 提供了非常全面的支持，主要有如下几个注解：</p><ul><li>@PathVariable注解：提取请求地址中的参数</li><li>@PostMapping注解：映射一个POST请求</li><li>@GetMapping注解：映射一个GET请求</li><li>@PutMapping注解：映射一个PUT请求</li><li>@DeleteMapping注解：映射一个DELETE请求</li></ul><p>1 使用@PathVariable 注解可以将Controller下方法的参数<strong>绑定到URL的模板变量上</strong>，使url的访问更灵活。反之如果不使用的话，就需要在URL手动用=赋值参数</p><p>2 使用不同的注解组合（不同的请求方式）可以实现 相同的URL实现不同的效果！！使显示的url更简洁和有层次感</p><h3 id="3-3-RESTful风格的设计原则"><a href="#3-3-RESTful风格的设计原则" class="headerlink" title="3.3 RESTful风格的设计原则"></a>3.3 RESTful风格的设计原则</h3><ul><li><p>URL尽量使用名词复数, 不使用动词</p></li><li><p>访问同一个URL地址, 采用不同的请求方式, 代表执行不同的操作(get获取, post新增等)</p></li><li><p>服务器返回的响应格式数据，尽量通过XML JSON进行数据传递；</p></li><li><p>无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的；</p></li></ul><h2 id="4-前后端分离时，前后端是如何交互的"><a href="#4-前后端分离时，前后端是如何交互的" class="headerlink" title="4 前后端分离时，前后端是如何交互的"></a>4 前后端分离时，前后端是如何交互的</h2><h3 id="4-1-后台如何处理前端传递过来信息，并返回数据的过程"><a href="#4-1-后台如何处理前端传递过来信息，并返回数据的过程" class="headerlink" title="4.1 后台如何处理前端传递过来信息，并返回数据的过程"></a>4.1 后台如何处理前端传递过来信息，并返回数据的过程</h3><blockquote><p>其实就是问springMVC的原理和执行流程</p></blockquote><p>用户发出请求后，前端传过来的实际上是一个url，后台接受请求，返回数据给前端。接受请求并返回数据其实就是springMVC的整个处理流程。</p><p>SpringMVC的执行过程是围绕着前置（调度）控制器<strong>DispatcherServlet</strong>的调度来设计的。</p><ul><li>第一步，DispatcherServlet拦截请求，并调用 处理器映射HandlerMapping 和 解析控制器映射HandlerExecution。<ul><li>目的是根据url查找对应控制器，找到是哪个Controller应该处理这个请求，找到之后返回给DispatcherServlet</li></ul></li><li>第二步，DispatcherServlet调用HandlerAdapter处理器适配器，并让他调用那个Controller。<ul><li>接下来就是我们编写的代码逻辑，后端Controller调Service、Service调Mapper接口，mapper.xml做持久层的增删改查，得到一个JSON对象传递给前端</li><li>前端解析JSON对自己的js对象，然后得到视图和模型，通过HandlerAdapter处理器适配器传递给DispatcherServlet</li></ul></li><li>第三步，DispatcherServlet调用视图解析器(ViewResolver)来解析逻辑视图，最后得到视图，再呈现给用户！！</li></ul><p>总结：简单来讲的话就是三步：1通过url找到对应的Controller、然后2调用执行持久化层的查询获得逻辑视图或者model，最后3解析视图、并呈现给用户。</p><h3 id="4-2-后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？"><a href="#4-2-后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？" class="headerlink" title="4.2 后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？"></a>4.2 后端返回值有字符串、JSON、实体对象，如何统一的传给前端的？</h3><blockquote><p>做一个删除操作——返回的是RespBean对象</p><p>查询所有员工 返回的是一个RespPageBean对象</p><p>查询部门的时候返回的是一个list集合 List<Department></Department></p><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中</p></blockquote><p>其实就是SpringBoot框架的功能，使用了@ResponseBody注解，所有的java对象都转换为了JSON格式写入Http response body中。</p><p>所以我后端不用管其他，你要集合我返回集合、要msg我返回msg、要page返回page，反正最后都变成JSON给前端了。</p><h2 id="5-RBAC基于角色的权限访问控制"><a href="#5-RBAC基于角色的权限访问控制" class="headerlink" title="5 RBAC基于角色的权限访问控制"></a>5 RBAC基于角色的权限访问控制</h2><h3 id="5-1-基于角色的动态访问控制逻辑"><a href="#5-1-基于角色的动态访问控制逻辑" class="headerlink" title="5.1 基于角色的动态访问控制逻辑"></a>5.1 基于角色的动态访问控制逻辑</h3><p>使用springScurity完成用户认证和用户授权。@EnableWebSecurity //开启WebSecurity模式，然后编写一个SecurityConfig类继承WebSecurityConfigurerAdapter，重写里面的configure方法给用户设置角色和权限。</p><p>因为是前后端分离的项目，基本的登录逻辑就是：用户(hr表)登录成功之后，可以通过hr_role表查询到用户的角色，再根据用户角色去（meau_role中）查出来用户可以操作的菜单（资源），然后把这些可以操作的资源，组织成一个 JSON 数据，返回给前端，前端再根据这个 JSON 渲染出相应的菜单。</p><p>这样就可以根据数据库中的表信息，动态的配置资源-角色以及用户-角色之间的关系，进而调整用户可以操作的资源(菜单)。</p><h3 id="5-2-有状态登录和无状态登录"><a href="#5-2-有状态登录和无状态登录" class="headerlink" title="5.2 有状态登录和无状态登录"></a>5.2 有状态登录和无状态登录</h3><p><strong>传统的有状态登录Session</strong></p><ul><li><p>服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理。典型的就是Session。</p></li><li><p>例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li><p>服务端保存大量数据，增加服务端压力</p></li><li><p>服务端保存用户状态，不支持集群化部署</p></li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212621.png" alt="img" style="zoom:80%;"><p><strong>RESTful 风格的无状态服务</strong></p><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：<strong>服务的无状态性</strong>，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>好处：</p><ul><li><p>多次请求不需要必须访问到同一台服务器，</p></li><li><p>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</p></li><li><p>减小服务端存储压力</p></li></ul><p><strong>使用JWT实现无状态服务</strong> </p><ul><li>首先客户端发送账户名/密码到服务端进行认证登录 </li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token   Json web token (JWT)</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212624.png" alt="jwt" style="zoom:80%;"><h3 id="5-3-Token如何保存状态"><a href="#5-3-Token如何保存状态" class="headerlink" title="5.3 Token如何保存状态"></a>5.3 Token如何保存状态</h3><p><strong>如何处理注销账户之后token还有效的问题？</strong></p><blockquote><p>相关的有：退出登录、修改密码、修改权限、注销账户之后，token还有效</p><p>Redis用来储存token,账户注销或者退出登录之后就删除Redis中的token</p></blockquote><p>这个问题不存在于 Session 认证方式中，因为在 Session 认证方式中，遇到这种情况的话服务端删除对应的 Session 记录即可。</p><p>token 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。</p><ul><li>解决方案一：<strong>将 token 存入内存数据库</strong>：将 token 存入 DB 中，redis 内存数据库在这里是是不错的选择。如果需要让某个 token 失效就直接从 redis 中删除这个 token 即可。但是，这样会导致每次使用 token 发送请求都要先从 DB 中查询 token 是否存在的步骤，而且违背了 JWT 的无状态原则。</li></ul><p><strong>token 有效期一般都建议设置的不太长，那么 token 过期后如何认证，如何实现动态刷新 token，避免用户经常需要重新登录？</strong></p><blockquote><p>设置token的有效期为30分钟，服务器每次校验时，检查token的有效期，如果快过期了，就重新生成一个token给客户端。客户端请求之前先检查更新自己的token</p></blockquote><p>先来看看在 Session 认证中一般的做法：假如 session 的有效期30分钟，如果 30 分钟内用户有访问，就把 session 有效期被延长30分钟。</p><ol><li><strong>类似于 Session 认证中的做法</strong>：这种方案满足于大部分场景。假设服务端给的 token 有效期设置为30分钟，服务端每次进行校验时，如果发现 token 的有效期马上快过期了，服务端就重新生成 token 给客户端。客户端每次请求都检查新旧token，如果不一致，则更新本地的token。这种做法的问题是仅仅在快过期的时候请求才会更新 token ,对客户端不是很友好。</li><li><strong>每次请求都返回新 token</strong> :这种方案的的思路很简单，但是，很明显，开销会比较大。</li><li><strong>token 有效期设置到半夜</strong> ：这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li><strong>用户登录返回两个 token</strong> ：第一个是 acessToken ，它的过期时间 token 本身的过期时间比如半个小时，另外一个是 refreshToken 它的过期时间更长一点比如为1天。客户端登录后，将 accessToken和refreshToken 保存在本地，每次访问将 accessToken 传给服务端。服务端校验 accessToken 的有效性，如果过期的话，就将 refreshToken 传给服务端。如果有效，服务端就生成新的 accessToken 给客户端。否则，客户端就重新登录即可。该方案的不足是：1⃣️需要客户端来配合；2⃣️用户注销的时候需要同时保证两个 token 都无效；3⃣️重新请求获取 token 的过程中会有短暂 token 不可用的情况（可以通过在客户端设置定时器，当accessToken 快过期的时候，提前去通过 refreshToken 获取新的accessToken）。</li></ol><h3 id="5-4-JWT的格式？？"><a href="#5-4-JWT的格式？？" class="headerlink" title="==5.4 JWT的格式？？=="></a>==5.4 JWT的格式？？==</h3><h2 id="6-邮件服务原理"><a href="#6-邮件服务原理" class="headerlink" title="6 邮件服务原理"></a>6 邮件服务原理</h2><blockquote><p>vhrserver相当于只是发送了一个消息给中间件</p><p>然后真正发送邮件的功能都在mailserver中，JavaMailSender接口</p></blockquote><p>将邮件服务划分为单独的模块、引入消息中间件 RabbitMQ，实现异步发送欢迎新员工的入职邮件；即当管理人员比如hr在界面上操作新增了一名员工到数据库中，就会自动的向中间件RabbitMQ发送一条消息，然后mailServer会自动异步的订阅消息，向新入职的员工发送一封入职邮件，里面包含姓名、职位、职称和部门等信息。</p><p>vhrServer中的业务逻辑：</p><ul><li>新增员工的命令返回值为1时，进入邮件发送的代码中</li><li>指定消息的唯一UUID,获取一个新的employee对象用于传递</li><li>一个MailSendLog类用来记录消息的发送日志，里面实例变量有消息的id、员工id、投递状态、投递规则key exchage等</li><li>配置RabbitMQ的配置文件，声明队列、交换机、绑定交换机等</li></ul><p>mailServer中的业务逻辑：</p><ul><li>配置RabbitMQ的配置文件，然后消费消息就ok了</li><li>消息确认机制改为手动，只要消费成功一条消息，就将消息id记录在Redis上，避免消息的重复消费</li></ul><h2 id="7-RabbitMQ如何保证消息的可靠性"><a href="#7-RabbitMQ如何保证消息的可靠性" class="headerlink" title="7 RabbitMQ如何保证消息的可靠性"></a>7 RabbitMQ如何保证消息的可靠性</h2><h3 id="1-保证我们的消息能够成功到达队列"><a href="#1-保证我们的消息能够成功到达队列" class="headerlink" title="1 保证我们的消息能够成功到达队列"></a>1 保证我们的消息能够成功到达队列</h3><ul><li><p>消息传递、要经过三个流程：</p><ul><li><p>1 消息到达交换机 </p><ul><li>第一个流程可能由于网络的波动、延迟等原因，消息没有准确达到交换机</li></ul></li><li><p>2 交换机把消息路由到队列中</p><ul><li>第二个流程可能routing key错误等原因，消息没有准确到达队列</li></ul></li><li><p>3 消息持久化写入日志</p><ul><li>第三个流程可能在消息写入日志的过程中，broker crash掉了，重启后消息丢失</li></ul></li></ul></li><li><p>解决方案一：事务控制，但大幅度降低了效率不推荐使用</p></li><li><p>解决方案二：发送者确认模式：即消息发送失败回调、路由失败回调</p><ul><li><p>1 通过实现ConfirmCallBack接口，消息发送到交换器Exchange后触发回调</p></li><li><p>2 通过实现ReturnCallback接口，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）</p></li><li><p>总结：</p><ul><li><p>如果成功入列，单纯给客户端发送”ack”信号</p></li><li><p>如果消息无法路由到队列则是发送 “消息” + “ack”,且”消息”比ack信号先到</p></li></ul></li></ul></li></ul><h3 id="2-rabbitmq的持久化（解决消息到达队列之后的可靠性）"><a href="#2-rabbitmq的持久化（解决消息到达队列之后的可靠性）" class="headerlink" title="2 rabbitmq的持久化（解决消息到达队列之后的可靠性）"></a>2 rabbitmq的持久化（解决消息到达队列之后的可靠性）</h3><ul><li><p>三个持久化：交换机持久化、队列持久化、消息持久化</p></li><li><p>持久化的消息在进入持久化队列之后会写入到rabbitmq的持久性日志文件中，消息被消费掉后，会把持久性日志文件中该消息标记为等待垃圾收集</p></li><li><p>三个持久化很大程度上已经解决了rabbitmq这一端因为宕机而导致消息丢失的问题。。。如果在broker在把消息写入日志文件的时候崩掉了（极端情况），这时可以借助mirror queue来处理</p></li></ul><h3 id="3-确保一条消息只消费一次"><a href="#3-确保一条消息只消费一次" class="headerlink" title="3 确保一条消息只消费一次"></a>3 确保一条消息只消费一次</h3><ul><li><p>首先将 RabbitMQ 的消息自动确认机制改为手动确认，然后每当有一条消息消费成功了，就把该消息的唯一 ID 记录在 Redis 上，然后每次收到消息时，都先去 Redis 上查看是否有该消息的 ID，如果有，表示该消息已经消费过了，不再处理，否则再去处理。</p></li><li><p>这里使用的是Token的思想，核心就是每个操作都有一个唯一凭证 token，一旦执行成功，对于重复的请求，总是返回同一个结果。</p></li><li><p>每一个邮件消息都有唯一的uuid，作为唯一的凭证</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="后端开发" scheme="https://wukang555.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="项目" scheme="https://wukang555.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架面经</title>
    <link href="https://wukang555.github.io/2021/08/01/%E9%9D%A2%E7%BB%8F_07_Spring%E6%A1%86%E6%9E%B6%20/"/>
    <id>https://wukang555.github.io/2021/08/01/%E9%9D%A2%E7%BB%8F_07_Spring%E6%A1%86%E6%9E%B6%20/</id>
    <published>2021-08-01T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。</p><a id="more"></a><h1 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1 Mybatis"></a>1 Mybatis</h1><h2 id="1-1-Mybatis的介绍和运行原理"><a href="#1-1-Mybatis的介绍和运行原理" class="headerlink" title="1.1 Mybatis的介绍和运行原理"></a>1.1 Mybatis的介绍和运行原理</h2><blockquote><p>Mybatis介绍，Mybatis的映射原理、Mybatis的工作流程、Mybatis里类的生命周期</p></blockquote><h3 id="1-1-1-什么是Mybatis、Mybatis的好处？"><a href="#1-1-1-什么是Mybatis、Mybatis的好处？" class="headerlink" title="1.1.1 什么是Mybatis、Mybatis的好处？"></a>1.1.1 什么是Mybatis、Mybatis的好处？</h3><p><strong>Mybatis的定义：</strong></p><ul><li>MyBatis 是一款持久层框架。一般就是写一个抽象的mapper接口，然后用xml（或者注解的方式）去实现该接口写SQL语句，实现了SQL与业务代码的分离。但一般注解方式只支持一些简单的SQL语句。</li></ul><p><strong>Mybatis的好处：</strong></p><ul><li>1 最重要的就是用xml实现接口来写SQL语句，实现了SQL与业务代码的分离</li><li>2 mybatis配置了数据库的连接，无需程序员配置JDBC加载驱动、创建连接等繁杂的过程</li><li>3 还有比较重要的就是：自动映射功能，Mybatis自动将Java对象映射至sql语句、也能将sql的执行结果映射至java对象</li></ul><h3 id="1-1-2-XML映射文件实现mapper接口的工作原理"><a href="#1-1-2-XML映射文件实现mapper接口的工作原理" class="headerlink" title="1.1.2 XML映射文件实现mapper接口的工作原理"></a>1.1.2 XML映射文件实现mapper接口的工作原理</h3><blockquote><p>接口如何找到xml文件、如何定位到SQL语句</p><p>比如我写一个mapper.java的接口（里面有一个findById(int id)的方法），在mapper.xml里面写了对应的SQL语句</p></blockquote><p><strong>mapper接口的工作原理? 动态代理：</strong></p><p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行该接口方法对应的 sql语句，然后将 sql 执行结果返回。</p><p>需要设置：</p><ul><li>1 mappr.xml映射文件中的 namespace 的值 需要与mapper接口的全限名一致</li><li>2 mappr.xml映射文件中的SQL语句的id值，需要与 接口的方法名一致。接口方法内的参数，就是传递给sql的参数</li></ul><p>所以，虽然<code>Mapper.java</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>也即是SQL语句。实现接口的方式是动态代理。</p><p>还有两个小问题：id值必须唯一么？ mapper接口中的方法可不可以重载？</p><p><strong>id值必须唯一么？</strong></p><ul><li>同一个XML映射文件，的id必须唯一</li><li>不同XML映射文件，如果配置了namespace ，则id值可以重复，因为namespace+id是作为寻找SQL语句的key使用的</li></ul><p><strong>mapper接口中的方法可不可以重载？</strong></p><ul><li>mapper.java 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。</li><li>因为只有一个ID，所以可以用动态SQL分别处理两个重载的方法！！</li></ul><h3 id="1-1-3-Mybatis内部的工作流程"><a href="#1-1-3-Mybatis内部的工作流程" class="headerlink" title="1.1.3 Mybatis内部的工作流程"></a>1.1.3 Mybatis内部的工作流程</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212551.jpg" alt="20200225164530119"></p><p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）加载映射文件（就是我们写的SQL语句）。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句。一个mybatis-config.xml 配置文件可以加载多个映射文件。</p><p>3）构造会话工厂SqlSessionFactory</p><p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）MappedStatement 对象（处理对象的映射关系，参数映射和结果映射）：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p><p>7）执行数据库的命令。</p><h3 id="1-1-4-Mybatis内部对象的生命周期和作用域"><a href="#1-1-4-Mybatis内部对象的生命周期和作用域" class="headerlink" title="1.1.4 Mybatis内部对象的生命周期和作用域"></a>1.1.4 Mybatis内部对象的生命周期和作用域</h3><blockquote><p>这里指的是SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession、mapper接口的作用域</p></blockquote><p><strong>SqlSessionFactoryBuilder：</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory：</strong></p><ul><li><p>类似数据库连接池</p></li><li><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong> </p></li><li><p>因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的仅创建一个SqlSessionFactory 的单例对象</p></li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求！SqlSession就相当于一个数据库连接，你可以在一个事务里面执行多条SQL,然后通过它的commit、rollback等方法，提交或者回滚事务。所以它应该存活在一个业务请求中</li><li>SqlSession 的实例的最佳的作用域是请求或方法作用域。</li><li>处理完整个请求之后需要赶紧关闭，否则资源被占用！</li></ul><h2 id="1-2-Mybatis的特色功能"><a href="#1-2-Mybatis的特色功能" class="headerlink" title="1.2 Mybatis的特色功能"></a>1.2 Mybatis的特色功能</h2><blockquote><p>最重要的是参数映射和结果集映射、这里还介绍一些不同的执行器和批量update的操作</p></blockquote><h3 id="1-2-1-Mybatis的执行器Executor"><a href="#1-2-1-Mybatis的执行器Executor" class="headerlink" title="1.2.1 Mybatis的执行器Executor"></a>1.2.1 Mybatis的执行器Executor</h3><blockquote><p>Executor的作用范围：Executor 严格限制在 SqlSession 生命周期范围内。</p><p>指定Executor的方式：</p><p>1 在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，</p><p>2 手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p></blockquote><p>答：MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p><p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p><p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p><p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p><h3 id="1-2-2-扩展Mybatis的批量update操作"><a href="#1-2-2-扩展Mybatis的批量update操作" class="headerlink" title="1.2.2 扩展Mybatis的批量update操作"></a>1.2.2 扩展Mybatis的批量update操作</h3><blockquote><p>有人做过了两种实现对比<a href="https://blog.csdn.net/lixiaolian123/article/details/110112030">批量插入对比</a></p></blockquote><p>1 foreach方式插入：sql语句里面写循环代码</p><ul><li>mysql默认接受sql的大小是 1M，当使用foreach同时插入1w行左右时会因为sql长度超过mysql的限制而无法执行</li></ul><p>2  BATCH模式插入：直接在java代码中写循环调用插入的接口</p><ul><li>参考文章显示使用BatchExecutor执行器的batch模式没有foreach快（作者很不解）</li></ul><h3 id="1-2-3-Mybatis自动映射功能：参数映射和结果集映射"><a href="#1-2-3-Mybatis自动映射功能：参数映射和结果集映射" class="headerlink" title="1.2.3 Mybatis自动映射功能：参数映射和结果集映射"></a>1.2.3 Mybatis自动映射功能：参数映射和结果集映射</h3><p>参数映射（万能的map）</p><ul><li><p>Map传递参数，直接在sql中取出key即可！    【parameterType=”map”】#{userid},#{passWord}</p></li><li><p>对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】#{name}</p></li></ul><p>结果集映射resultMap</p><ul><li>可以在UserMapper.xml中单独写一个结果集的映射，其他sql语句的返回值的类型可以指定为该结果集</li></ul><h2 id="1-3-Mybatis中的SQL语句和缓存"><a href="#1-3-Mybatis中的SQL语句和缓存" class="headerlink" title="1.3 Mybatis中的SQL语句和缓存"></a>1.3 Mybatis中的SQL语句和缓存</h2><h3 id="1-Mybatis-的-XML-文件有哪些标签属性？"><a href="#1-Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="1 Mybatis 的 XML 文件有哪些标签属性？"></a>1 Mybatis 的 XML 文件有哪些标签属性？</h3><ul><li><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p></li><li><p><code>parameterType</code> 属性表示参数的数据类型，<code>resultType</code> 表示返回的结果类型</p></li><li><p>还有动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等</p></li></ul><h3 id="2-SQL分页的三种实现方式"><a href="#2-SQL分页的三种实现方式" class="headerlink" title="2 SQL分页的三种实现方式"></a>2 SQL分页的三种实现方式</h3><ul><li><p>1  在sql语句层实现，使用Limit分页</p></li><li><p>2 使用分页插件 PageHelper</p></li><li><p>3 在java代码层实现，使用RowBounds类分页</p><ul><li>使用RowBounds类分页是一种逻辑分页查询，一次性查出很多的数据，然后在查询结果中进行分页，明显的缺点就是消耗内存，存在内存溢出的风险</li></ul></li></ul><h3 id="3-和-区别"><a href="#3-和-区别" class="headerlink" title="3 #{} 和 ${} 区别"></a>3 #{} 和 ${} 区别</h3><ul><li><p>MyBatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ?，预编译 SQL，通过set()方法进行参数赋值。使用 #{} 可以有效地防止 SQL 注入。（能用尽用）</p></li><li><p>在处理 ${} 时，会直接把${} 替换为参数值，存在 SQL 注入的风险</p></li><li><p>${}一般用入传入数据库对象，比如数据库表名；还有使用动态参数的时候，不支持使用#{}，所以只能用${}</p></li></ul><h3 id="4-mybatis的两级缓存的机制"><a href="#4-mybatis的两级缓存的机制" class="headerlink" title="4 mybatis的两级缓存的机制"></a>4 mybatis的两级缓存的机制</h3><p>MyBatis默认定义了两级缓存：<strong>一级缓存</strong>、<strong>二级缓存</strong>和<strong>可自定义的二级缓存</strong></p><p><strong>一级缓存：</strong></p><ul><li><p><strong>默认开启一级缓存。SqlSession级别的缓存,存在于一次会话之间</strong></p></li><li><p>所有 select 语句的结果将会被缓存</p></li><li><p>执行insert、update 和 delete 语句会刷新缓存</p></li><li><p>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存（默认）。</p></li></ul><p><strong>二级缓存:</strong></p><ul><li>基于namespace级别的缓存，一个命名空间Mapper，对应一个二级缓存；（需要手动打开）</li><li>如果当前会话关闭了，这个会话对应的一级缓存就失效了；但是如果我们仍需要这个缓存数据，会话关闭时，我们将一级缓存中的数据被保存到二级缓存中；</li></ul><p><strong>缓存查找原理：</strong></p><p>查数据时，先看二级缓存中有没有，再看一级缓存中有没有，都没有再查询数据库。</p><h1 id="2-Spring"><a href="#2-Spring" class="headerlink" title="2 Spring"></a>2 Spring</h1><blockquote><p>什么是Spring? Spring的组成\不要</p><p>IOC 控制翻转、AOP 依赖注入   代理模式</p><p>Bean  Bean 的作用域  自动装配 </p><p>spring事务</p></blockquote><h2 id="2-1-什么是Spring"><a href="#2-1-什么是Spring" class="headerlink" title="2.1 什么是Spring?"></a>2.1 什么是Spring?</h2><p>Spring是一个具有控制反转(IoC)和面向切面(AOP)特点的容器（框架），旨在提高开发人员的开发效率以及系统的可维护性。</p><p>一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。Spring 最核心的思想就是不重新造轮子，开箱即用！</p><p>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态得以流行的一个杀手级的应用框架。</p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器(Spring Core)之上，其他分别有Spring 上下文(Spring Context)、Spring AOP、Spring DAO、Spring ORM、Spring Web 模块、Spring MVC 框架</p><h2 id="2-2-IOC-和-AOP"><a href="#2-2-IOC-和-AOP" class="headerlink" title="2.2 IOC  和 AOP"></a>2.2 IOC  和 AOP</h2><h3 id="1-IOC是什么"><a href="#1-IOC是什么" class="headerlink" title="1 IOC是什么"></a>1 IOC是什么</h3><p>控制反转(IoC)：一个对象的创建和管理不再由对象本身控制，而是将这个对象注入Ioc容器中，由spring 来管理对象的创建和初始化。</p><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法</strong>。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系 全在编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方也就是Spring容器。</p><p>将对象注入spring容器中的方式也很简单，在xml配置文件中写一个<bean>标签就好了。取用的时候用getBean()方法可以直接获得该注入的对象。除了使用XML配置，springboot中支持基于注解的配置更为方便和流行。</bean></p><p>DI(依赖注入)有三种实现方式：1构造方法、2set方式、3注解方式</p><h3 id="2-AOP是什么"><a href="#2-AOP是什么" class="headerlink" title="2 AOP是什么"></a>2 AOP是什么</h3><p>AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间<strong>动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>比如将共同调用的业务逻辑（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低耦合性。</p><h3 id="3-静态代理和动态代理"><a href="#3-静态代理和动态代理" class="headerlink" title="3 静态代理和动态代理"></a>3 静态代理和动态代理</h3><p><strong>代理模式几个组成部分</strong></p><ul><li>抽象角色： 一般会使用一个接口或者抽象类来实现（比如出<strong>租房子这件事</strong>）</li><li>真实角色：被代理的角色（这里指<strong>房东</strong>实现出租房子的接口）</li><li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作（这里指<strong>中介</strong>、帮房东出租房子，也要实现出租房子的接口、但有自己的一些其他方法）</li><li>客户：访问代理对象的人 （这里表示<strong>要租房子的人</strong>）</li></ul><p><strong>代理模式的好处：</strong></p><ul><li><p>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</p></li><li><p>公共业务交给代理角色去实现，实现业务的分工</p></li><li><p>公共业务发生扩展时，方便集中管理</p></li></ul><p><strong>静态代理：</strong></p><p>有一个真实角色就要对应写一个代理角色，代码量翻倍、效率较低</p><p><strong>动态代理：</strong></p><p>和静态代理最大的区别：动态代理的代理类是动态生成的，不是我们直接写好的</p><h2 id="2-3-Spring-bean"><a href="#2-3-Spring-bean" class="headerlink" title="2.3 Spring bean"></a>2.3 Spring bean</h2><p>bean 就是指的就是那些被 IoC 容器所管理的对象，被Ioc托管的对象都叫bean。</p><h3 id="1-bean的作用域"><a href="#1-bean的作用域" class="headerlink" title="1 bean的作用域"></a>1 bean的作用域</h3><ul><li><p>单例模式singleton </p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li></ul></li><li><p>原型模式prototype </p><ul><li> 每次请求都会创建一个新的 bean 实例。</li></ul></li><li><p><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p></li><li><p><strong>session</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p></li><li><p><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p></li></ul><h3 id="2-单例的线程安全"><a href="#2-单例的线程安全" class="headerlink" title="2 单例的线程安全"></a>2 单例的线程安全</h3><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><ul><li><p>常见的有两种解决办法：</p><ul><li><p>在 bean 中尽量避免定义可变的成员变量。</p></li><li><p>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p></li></ul></li></ul><h3 id="3-spring的自动装配原理"><a href="#3-spring的自动装配原理" class="headerlink" title="3 spring的自动装配原理"></a>3 spring的自动装配原理</h3><p>Bean 的自动装配指Spring会在上下文中自动寻找，并自动给bean装备属性。简单来讲，给一个复杂对象赋值属性的时候，如果要调用容器中已经存在的对象的话、spring会帮我们自动装配调用。一般来说有两种自动装配的方式ByName 和 ByType</p><ul><li><p>byNmae 会自动在容器上下文中查找和自己对象set方法后面的值对应的id</p></li><li><p>byType 会自动在容器上下文中查找和自己对象属性类型相同的bean</p></li></ul><p>@Autowired注解：自动装配，默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</p><p>@Resource 注解：自动装配，默认通过byname的方式实现，如果找不到名字，则通过byType实现</p><h2 id="2-4-Spring-事务（bd）"><a href="#2-4-Spring-事务（bd）" class="headerlink" title="2.4 Spring 事务（bd）"></a>2.4 Spring 事务（bd）</h2><h3 id="1-Spring-事务实现方式有哪些？"><a href="#1-Spring-事务实现方式有哪些？" class="headerlink" title="1 Spring 事务实现方式有哪些？"></a>1 Spring 事务实现方式有哪些？</h3><p>Spring支持编程式事务管理和声明式的事务管理。</p><p><strong>编程式事务管理：</strong></p><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><p><strong>声明式事务管理（更好用）：</strong></p><ul><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务 管理。</li></ul><h3 id="2-spring事务传播特性"><a href="#2-spring事务传播特性" class="headerlink" title="2 spring事务传播特性"></a>2 spring事务传播特性</h3><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这 个事务中，这是最常见的选择。 <strong>（默认）</strong></li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 </li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 </li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 </li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 </li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与</li></ul><p>需要手动实现：在配置文件中声明事务的传播特性（比如REQUIRED），然后以AOP的方式实现事务的织入</p><blockquote><p>编写Spring的辅助配置文件spring-dao.xml；在配置声明式事务，并结合AOP实现事务的织入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务通知；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给那些方法配置事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的传播特性：new  propagation= --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.mapper.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-SpringMVC"><a href="#3-SpringMVC" class="headerlink" title="3 SpringMVC"></a>3 SpringMVC</h1><blockquote><ul><li>springMVC</li></ul><p>MVC三层架构</p><p>SprincgMVC执行原理</p><p>拦截器、文件上传下载？</p></blockquote><p>3.1 什么是SpringMVC？</p><p>Spring MVC是一个基于Java的实现了MVC模式的一个的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><p>3.2 SprincgMVC执行原理</p><ul><li><p>SpringMVC的执行过程是围绕着前置（调度）控制器DispatcherServlet的调度来设计的。</p><ul><li><p>第一步，DispatcherServlet拦截请求，并调用 处理器映射HandlerMapping 和 解析控制器映射HandlerExecution。</p><ul><li>目的是根据url查找对应控制器，找到是哪个Controller应该处理这个请求，找到之后返回给DispatcherServlet</li></ul></li><li><p>第二步，DispatcherServlet调用HandlerAdapter处理器适配器，并让他调用那个Controller。</p><ul><li><p>接下来就是我们编写的代码逻辑，后端Controller调Service、Service调Mapper接口，mapper.xml做持久层的增删改查，得到一个JSON对象传递给前端</p></li><li><p>前端解析JSON为自己的js对象，然后得到视图和模型，通过HandlerAdapter处理器适配器传递给DispatcherServlet</p></li></ul></li><li><p>第三步，DispatcherServlet调用视图解析器(ViewResolver)来解析逻辑视图，最后得到视图，再呈现给用户！！</p></li></ul></li><li><p>总结：简单来讲的话就是三步：1通过url找到对应的Controller、然后2调用执行持久化层的查询获得逻辑视图或者model，最后3解析视图、并呈现给用户。</p></li></ul><p>3.3 SpringMVC常用的注解有哪些</p><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。(一般与@Controller标识控制器组合，成为@RestController使用，)</p><h1 id="4-Springboot"><a href="#4-Springboot" class="headerlink" title="4 Springboot"></a>4 Springboot</h1><h2 id="4-1-什么是Springboot"><a href="#4-1-什么是Springboot" class="headerlink" title="4.1 什么是Springboot?"></a>4.1 什么是Springboot?</h2><p>Spring Boot 主要是简化了使用 Spring 的开发难度，简省了繁重的配置，提供了各种启动器，是开发者能快速上手。约定大于配置。</p><h2 id="4-2-springboot常用注解"><a href="#4-2-springboot常用注解" class="headerlink" title="4.2 springboot常用注解"></a>4.2 springboot常用注解</h2><p><strong>1 @SpringBootApplication：</strong></p><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><p><strong>2 Spring Bean 相关</strong></p><ul><li><p>@Autowired 自动装配</p><ul><li>自动导入对象到Bean中，被注入进的类同样要被 Spring 容器管理</li><li>默认通过byType的方式实现，如果相同Type&gt;1,就用byName，而且必须要求这个对象存在【常用】</li></ul></li><li><p>几种声明实体类被Spring管理成为bean对象的注解</p><ul><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。一般pojo层</li></ul></li><li><p>@RestController</p><ul><li><code>@RestController</code>注解是<code>@Controller和</code>@<code>ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值以JSON的格式直接填入 HTTP 响应体中,是 REST 风格的控制器。</li></ul></li><li><p>@Scope()设置作用域的注解</p><ul><li>@Scope(“singleton”) //表示单例模式的注解</li><li>@Scope(“prototype”) //表示原型模式的注解</li></ul></li><li><p>@Configuration 声明配置类</p></li></ul><p><strong>3 http请求和前后端传值</strong></p><ul><li>四种http请求<ul><li>@GetMapping(“users”)</li><li>@PostMapping(“users”)</li><li>@PutMapping(“users”)</li><li>@DeleteMapping(“users”)</li><li>@PatchMapping(“/profile”) 更新数据</li></ul></li><li>`获取路径参数、获取查询参数<ul><li><code>@PathVariable</code>用于获取路径参数</li><li><code>@RequestParam</code>用于获取查询参数。</li></ul></li></ul><p><strong>4 读取配置信息</strong></p><p>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</p><ul><li><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p></li><li><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p></li></ul><h1 id="5-RabbitMQ"><a href="#5-RabbitMQ" class="headerlink" title="5 RabbitMQ"></a>5 RabbitMQ</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring框架面经。包括mubatis、spring、springMVC、springBoot，以理解为主。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="Spring" scheme="https://wukang555.github.io/tags/Spring/"/>
    
    <category term="后端开发" scheme="https://wukang555.github.io/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://wukang555.github.io/2021/07/30/%E9%9D%A2%E7%BB%8F_06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20/"/>
    <id>https://wukang555.github.io/2021/07/30/%E9%9D%A2%E7%BB%8F_06_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20/</id>
    <published>2021-07-30T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:36.412Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式。设计模式的原则和集中基本的设计模式。</p><a id="more"></a><h1 id="1-设计模式及原则"><a href="#1-设计模式及原则" class="headerlink" title="1 设计模式及原则"></a>1 设计模式及原则</h1><h2 id="1-1-设计模式是什么，有什么用？"><a href="#1-1-设计模式是什么，有什么用？" class="headerlink" title="1.1 设计模式是什么，有什么用？"></a>1.1 设计模式是什么，有什么用？</h2><p>设计模式就是构造弹性、可维护的面向对象系统的一些经验（用的多了就被整理命名为模式）</p><p>面向对象的基础是封装、继承和多态，设计模式就是以一定的策略去运用封装、继承和多态。</p><p><strong>设计模式的优点：</strong></p><ul><li>模式能让开发人员用更少的词汇做更充分的沟通；并且使交流保持在模式层次上、可以免去考虑具体对象的琐屑。</li><li>模式化开发给程序带来的是极高的可扩展性和可维护性。</li></ul><h2 id="1-2-Java设计模式的几大原则"><a href="#1-2-Java设计模式的几大原则" class="headerlink" title="1.2 Java设计模式的几大原则"></a>1.2 Java设计模式的几大原则</h2><blockquote><p>关于类和模块的三个原则：单一职责、迪米特、开放封闭</p><p>关于接口的三个原则：依赖倒置、接口隔离、合成复用</p><p>关于继承的一个原则：里氏替换原则</p></blockquote><p><strong>1 单一职责原则</strong></p><ul><li>一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。</li></ul><p><strong>2 迪米特原则</strong></p><ul><li>最少知道原则，每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。更有利于复用。</li></ul><p><strong>3 开放-封闭原则</strong></p><ul><li>代码对扩展是开放的，对更改是封闭的。在程序需要进行拓展的时候，不能去修改原有的代码。</li></ul><p><strong>4 依赖倒置原则</strong></p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 也就是要面向接口编程，不要面向实现编程。</li></ul><p><strong>5 接口隔离原则</strong></p><ul><li>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li></ul><p><strong>6 合成复用原则</strong></p><ul><li>尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</li></ul><p><strong>7 里氏替换原则</strong></p><ul><li><p>所有引用基类(父类)的地方必需能够透明地使用子类对象。也就是说，在程序里面，把父类都替换成它的子类，程序的行为没有变化.</p></li><li><p>里氏代换原则要求不能破坏继承体系，具体表现在：</p><ul><li><p>1 子类应该实现父类的所有抽象方法，不要覆盖父类的非抽象方法。</p></li><li><p>2 子类可以增加自己特有的方法。</p></li><li><p>3 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p></li><li><p>4 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p></li></ul></li></ul><h2 id="1-3-设计模式的分类"><a href="#1-3-设计模式的分类" class="headerlink" title="1.3 设计模式的分类"></a>1.3 设计模式的分类</h2><p>1 创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有<strong>工厂方法模式、抽象工厂模式、单例模式</strong>、建造者模式、原型模式。（用来创建系统中的对象）</p><p>2 结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有<strong>适配器模式、装饰器模式、代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。（用来表示系统间类和对象的结构）</p><p>3 行为型模式：通过类之间不同通信方式实现不同行为。有<strong>策略模式、模板方法模式、观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、<strong>状态模式</strong>、访问者模式、中介者模式、解释器模式。（用来表示系统间类和对象之间的行为）</p><h1 id="2-理解几种重要的设计模式"><a href="#2-理解几种重要的设计模式" class="headerlink" title="2 理解几种重要的设计模式"></a>2 理解几种重要的设计模式</h1><blockquote><p>工厂模式、单例模式、代理模式</p><p>策略模式、观察者模式、模板方法模式</p></blockquote><h2 id="2-1-三种工厂模式"><a href="#2-1-三种工厂模式" class="headerlink" title="2.1 三种工厂模式"></a>2.1 三种工厂模式</h2><blockquote><p>所有的工厂都是用来封装对象的创建</p><p>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</p><p>依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象（抽象工厂模式）</p></blockquote><p>1 静态工厂模式</p><ul><li><p><strong>专门写一个静态的工厂类来实例化对象</strong>，因为我们要创建的对象经常是可能发生改变的（比如披萨的种类不一样），我们把这些变化封装到静态的工厂类里面了。</p></li><li><p>创建新对象时直接用<strong>工厂类.方法</strong>，来创建对象，适用于工厂类负责创建对象较少的情况。</p></li></ul><p>2 工厂方法模式</p><ul><li><p>工厂方法模式<strong>指定义一个创建对象的接口（其中有一个工厂方法），让接口的实现类（重写工厂方法）来决定创建哪种对象</strong>，让类的实例化推迟到子类中进行。</p></li><li><p>静态工厂模式只做到了将对象的创建过程封装起来，而不具有弹性（要增加类就要改工厂类、增加if-else判断）。工厂方法模式具有弹性、要新增一个新的具体的对象、直接扩展再写一个类就好，无需改变超类中的“工厂方法”。其实这就是开放封闭原则的体现（对扩展开放、对修改封闭）</p></li></ul><p>3 抽象工厂模式</p><ul><li><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。说人话就是<strong>有一个抽象工厂类接口，实现这个接口的多个类都是具有不同功能的工厂类</strong></p></li><li><p>（让客户从具体产品中解耦了、决定创建何种产品的是实现了抽象工厂类的各种特别的工厂类）<strong>抽象工厂–地区工厂类</strong></p></li></ul><h2 id="2-2-单例模式"><a href="#2-2-单例模式" class="headerlink" title="2.2 单例模式"></a>2.2 单例模式</h2><blockquote><p>如果使用多个类加载器，可能导致单例失效而产生多是实例，一般建议指定类加载器</p></blockquote><p>==确保一个类只有一个实例，并提供一个全局访问点。==</p><p>一个类，没有公共的构造方法，只有<strong>一个私有的静态变量</strong>；<strong>一个私有的构造方法</strong>；外加<strong>一个公共的静态的getInstrance()方法</strong>，用来调用私有的构造方法、创建一个实例对象。</p><p><strong>1 线程不安全的懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//一个私有的静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123; uniqueInstance = <span class="keyword">new</span> Singleton();  &#125;         </span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：当多个线程同时调用getInstrnce()方法时，可能出现new出两个对象的情况，即是线程不安全的、不能确保一个类只有一个实例</p><p><strong>2 synchronized加锁的懒汉式</strong></p><p>对 getUniqueInstance() 方法加锁，只有该实例为null的时候才创建实例对象，保证了实例的唯一性。</p><p>问题：事实上只有第一次实例化该对象的时候才需要同步，创建之后用null判断即可，过多的同步（每次访问都要带锁）带来效率较低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//一个私有的静态变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的加锁的获取实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3 双重校验的懒汉式</strong></p><p>原理：</p><ul><li>uniqueInstance 采用 volatile 关键字修饰保证可见性、避免指令重排带来的并发问题</li><li>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</li><li>不再对获取实例的方法加锁了、只在创建对象的时候加锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;             </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4 饿汉式</strong></p><p>直接实例化静态变量保证线程安全</p><p>问题：直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个私有的静态变量 直接实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance= <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//一个私有的构造方法</span></span><br><span class="line">    <span class="comment">// 一个静态的公共的获取实例的方法 直接返回实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-代理模式"><a href="#2-3-代理模式" class="headerlink" title="2.3 代理模式"></a>2.3 代理模式</h2><blockquote><p>这里可以直接联系框架的AOP部分，学到的代理模式。举房东、中介、房客的例子</p></blockquote><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。</p><p>静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p>动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。</p><h2 id="2-4-策略模式"><a href="#2-4-策略模式" class="headerlink" title="2.4 策略模式"></a>2.4 策略模式</h2><p>定义一系列算法，分别封装起来，并使它们可以互换，成为一个算法族。策略模式让算法的变化独立于使用算法的客户。</p><p>每种行为（就是每个算法族）都是以实现接口的方式定义的类。也就是<strong>多用实现接口，少用继承</strong>的原则（合成复用原则）</p><p>使用场景： 现有 加/减/乘 几种算法，输入参数返回值都一样（可以理解成一类算法族）。现在需要在调用时动态配置算法策略，实现对不同算法的调用。就可以使用策略模式</p><h2 id="2-5-观察者模式（订阅、通知）"><a href="#2-5-观察者模式（订阅、通知）" class="headerlink" title="2.5 观察者模式（订阅、通知）"></a>2.5 观察者模式（订阅、通知）</h2><p>观察者模式表示的是一种对象与对象之间具有依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>使用场景：</p><ul><li>1比如 声音报警器和闪光灯报警器分别订阅热水器温度，热水器温度过高时，发出通知，两个报警器分别发声、闪光以实现报警。</li><li>2又比如很多人订阅微信公众号，该公众号有更新文章时，自动通知每个订阅的用户。</li></ul><p>实现条件：1,多个观察者要订阅这个对象 2，这个对象要发出通知</p><h2 id="2-6-模板方法模式"><a href="#2-6-模板方法模式" class="headerlink" title="2.6 模板方法模式"></a>2.6 模板方法模式</h2><p>模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。</p><p>（待完善和理解…）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;设计模式。设计模式的原则和集中基本的设计模式。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="设计模式" scheme="https://wukang555.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发浅析</title>
    <link href="https://wukang555.github.io/2021/07/29/%E9%9D%A2%E7%BB%8F_05_JAVA%E5%B9%B6%E5%8F%91/"/>
    <id>https://wukang555.github.io/2021/07/29/%E9%9D%A2%E7%BB%8F_05_JAVA%E5%B9%B6%E5%8F%91/</id>
    <published>2021-07-29T14:55:00.000Z</published>
    <updated>2022-05-17T12:18:14.522Z</updated>
    
    <content type="html"><![CDATA[<p>Java并发浅析面经。线程、线程池、悲观锁、乐观锁。</p><a id="more"></a><h1 id="Java并发浅析"><a href="#Java并发浅析" class="headerlink" title="Java并发浅析"></a>Java并发浅析</h1><blockquote><p>[1] 参考了《Java高并发程序设计》，但我觉得这本书写的很乱、章节间的逻辑不清晰（仅个人观点）</p><p>[2] 参考了JavaGuide的文章：<a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=%E4%BA%8C-executor-%E6%A1%86%E6%9E%B6">java线程池学习总结</a></p></blockquote><h1 id="1-并发编程和JMM"><a href="#1-并发编程和JMM" class="headerlink" title="1 并发编程和JMM"></a>1 并发编程和JMM</h1><blockquote><p>了解并发的前因后果（为什么？提高性能；怎么做？多线程）</p><p>了解JMM的作用和原理</p></blockquote><h2 id="1-1-并行和并发是什么？"><a href="#1-1-并行和并发是什么？" class="headerlink" title="1.1 并行和并发是什么？"></a>1.1 并行和并发是什么？</h2><p>并行则指同一时刻能运行多个指令。并发是指宏观上在一段时间内能同时运行多个程序，单个时间片仍然只运行一个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h2 id="1-2-为什么要使用并发（多线程）？"><a href="#1-2-为什么要使用并发（多线程）？" class="headerlink" title="1.2 为什么要使用并发（多线程）？"></a>1.2 为什么要使用并发（多线程）？</h2><blockquote><p>其实多线程就是并发编程的实现方式，无论在单核还是多核cpu上</p><p>之所以需要并发还在于cpu的速度、寄存器、缓存、内存、硬盘IO的速度存在较大差别</p><p>为了更好的利用CPU的性能，就需要并发调度来实现</p></blockquote><p>并发和并行它们最重要的两个目都是：1为了获得更好的性能；2业务模型确实需要多个执行的实体。</p><p>首先聊一聊：关于并行的两个定律：<strong>Amdahl （安达尔）定律</strong> 和 <strong>Gustafson（古斯塔夫森） 定律</strong></p><ul><li>Amdahl强调：当串行比例一定时，加速比是有上限的，不管你堆叠多少个CPU 参与计算，都不能突破这个上限！</li><li>Gustafson定律关心的是：如果可被并行化的代码所占比重足够多，那么加速比就能 随着CPU的数量线性增长。</li></ul><p>虽然一个说加速比存在上限、一个说加速比可以随CPU数量线性增长，但是说的都有道理。安达尔认为串行并行比例一定，仅增加CPU资源，性能并不会得到巨大提升。古斯塔夫森认为当并行代码足够多时，性能随CPU数量正比增长。所以这其实就说明了<strong>多核CPU的并行是一种提升效率的手段、但提高代码的并发量同样是十分重要的。这也是为什么要并发编程、尽可能的提高单核CPU的利用效率的原因</strong></p><p><strong>而并发编程的实现手段其实就是进程和线程，多线程进行切换轮流获取CPU的资源，以实现CPU利用率的最大化！！</strong>并发编程极大的提高了代码运行的效率、但也会带来线程安全的问题，所以学习并发编程也要懂如何避免和处理线程安全的问题。</p><h2 id="1-3-如何避免线程安全的问题"><a href="#1-3-如何避免线程安全的问题" class="headerlink" title="1.3 如何避免线程安全的问题"></a>1.3 如何避免线程安全的问题</h2><p>为了更高效的运行代码，所以需要并发编程技术，并发技术的实现就是利用多线程、轮流调度和执行cpu的资源。而并发编程时，极有可能照成线程安全的问题，（即多个线程同时对一个内存区域操作，例如堆区，造成读取数据不一致的问题），所以我们需要解决并发编程时造成的线程安全问题！！简略的讲一下下面5种方式：</p><ul><li><p>1 方式一：每一个线程，在堆区分配一份区域，每个线程自己认领一份，只能修改自己对应区域的数据。（数据还是在堆区，被线程认领了）<strong>这就是ThreadLocal的基本原理</strong></p></li><li><p>2 方式二：线程私有的栈区域，存取自己的数据（<strong>虚拟机栈</strong>）</p></li><li><p>3 方式三：比如final设置为常量，只能读取不能操作。</p></li><li><p>4 方式四：加锁，想要超过公共的数据、需要先获得锁（锁的类型有多种）<strong>悲观锁</strong></p></li><li><p>5 方式五：CAS(其中可能出现ABA问题)，适合于并发量不高的情况，也就是数据被意外修改的可能性较小的情况。<strong>这就是乐观锁的原理</strong></p></li></ul><h2 id="1-4-Java内存模型"><a href="#1-4-Java内存模型" class="headerlink" title="1.4 Java内存模型"></a>1.4 Java内存模型</h2><h3 id="1-4-1-JMM介绍"><a href="#1-4-1-JMM介绍" class="headerlink" title="1.4.1 JMM介绍"></a>1.4.1 JMM介绍</h3><p>JMM（Java Memory Model）是为了保证多个线程可以有效正确地协同地工作，实现在各种平台上都可以达到一致地内存访问的效果。</p><p>JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程有自己的工作内存（Working Memory）,线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p><p>（这里的主内存工作内存是一种逻辑的抽象，不对应具体的内存区域）JMM通过这种主内存和工作内存的机制来解决多线程对共享数据读写一致性的问题。</p><p>Java Memory Model(Java内存模型)， 围绕着在并发过程中如何处理<strong>可见性、原子性、有序性</strong>这三个特性而建立的模型。</p><ul><li><p>原子性：原子性是指一个操作是不可中断的。即使是在多线程的环境下，一个操作一旦开 始，就不会被其他线程干扰。</p></li><li><p>可见性：可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</p></li><li><p>有序性：程序执行时基于性能的考虑，对指令进行重排。多线程并发执行时可能出现有序性的问题</p></li></ul><h3 id="1-4-2-volatile关键字保证可见性【重点】"><a href="#1-4-2-volatile关键字保证可见性【重点】" class="headerlink" title="1.4.2 volatile关键字保证可见性【重点】"></a>1.4.2 volatile关键字保证可见性【重点】</h3><p>Java提供了volatile关键字来保证可见性。　当一个共享变量被volatile修饰时，能保证修改的值会立即更新到主存，当有其他线程需要读取时，它会去主内中读取新的值。</p><p>volatile在汇编代码层面的实现原理：“加入volatile关键字时，汇编代码会多出一个lock前缀指令”，</p><ul><li><p>1）lock前缀指令实际上相当于一个内存屏障，，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p></li><li><p>2）它会强制将对缓存的修改操作立即写入主存；</p></li><li><p>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p></li></ul><h3 id="1-4-3-as-if-serial-和-happens-before原则【重点】"><a href="#1-4-3-as-if-serial-和-happens-before原则【重点】" class="headerlink" title="1.4.3 as-if-serial 和 happens-before原则【重点】"></a>1.4.3 as-if-serial 和 happens-before原则【重点】</h3><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。</p><ul><li><p>as-if-serial原则</p><ul><li>不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。</li></ul></li><li><p>Happen-Before原则——先行发生原则</p><ul><li><p>程序顺序原则：一个线程内保证语义的串行性</p></li><li><p> volatile规则：volatile变量的写，先发生于读，这保证了 volatile变量的可见性</p></li><li><p>锁规则：解锁 （unlock) 必然发生在随后的加锁（lock) 前</p></li><li><p>传递性：A 先于B, B 先于C，那么A 必然先于C</p></li><li><p> 线程 的 start()方法先于它的每一个动作</p></li><li><p>线程的所有操作先于线程的终结（Threadjoin())</p></li><li><p>线程的中断（interrupt()) 先于被中断线程的代码</p></li><li><p>对象的构造函数执行、结束先于finalize()方法</p></li></ul></li></ul><h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2 线程"></a>2 线程</h1><blockquote><p>1 线程：线程创建、多线程、线程调度、线程协作</p></blockquote><h2 id="2-1-线程的生命周期和状态（6种）"><a href="#2-1-线程的生命周期和状态（6种）" class="headerlink" title="2.1 线程的生命周期和状态（6种）"></a>2.1 线程的生命周期和状态（6种）</h2><ul><li>新建状态NEW：创建后尚未启动。</li><li>可运行状态RUNABLE：该线程可以被运行，其实包括了Ready和Running两种状态<ul><li>线程调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（准备）</strong>状态</li><li>READY准备状态的线程获得了 CPU 时间片后就处于 <strong>RUNNING（运行）</strong> 状态。</li></ul></li><li>阻塞状态（Blocked）：请求锁而未得，进入阻塞状态，需要等待其他线程释放锁才能重新进入runnable状态</li><li>等待状态（WAITING）：当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态</li><li>限期等待状态（TIMED_WAITING）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</li><li>终止状态（TERMINATED）：可以是线程结束任务之后自己结束，或者产生了异常而结束。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212509.png" alt="image-20210819170721435" style="zoom:80%;"><h2 id="2-2-线程的创建和启动"><a href="#2-2-线程的创建和启动" class="headerlink" title="2.2 线程的创建和启动"></a>2.2 线程的创建和启动</h2><p><strong>1 有三种创建线程的方法【重要】：</strong></p><ul><li><p>① 继承 Thread 类并重写 run 方法。实现简单，但不符合里氏替换原则，不可以继承其他类。</p></li><li><p>② 实现 Runnable 接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。</p></li><li><p>③实现 Callable 接口并重写 call 方法。可以获取线程执行结果的返回值，并且可以抛出异常。</p></li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过new Thread(XX) 来调用。可以理解为任务是通过线程驱动从而执行的。</p><p><strong>2 启动线程的start()和run()方法的区别【重要】</strong></p><p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 </p><p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。（执行run()并没有开启一个新的线程）</p><p>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p><h2 id="2-3-线程之间的协作"><a href="#2-3-线程之间的协作" class="headerlink" title="2.3 线程之间的协作"></a>2.3 线程之间的协作</h2><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><p>调用 wait() 使线程挂起，当其他线程的运行时调用 notify() 或者 notifyAll() 来唤醒该挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。</p><p>wait() notify() 都只能用在同步方法或者同步控制块中使用，使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。一般使用 Lock 来获取一个 Condition 对象。</p><h3 id="join-和yield"><a href="#join-和yield" class="headerlink" title="join()和yield()"></a>join()和yield()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>Thread.yield() 是一个静态方法，一旦执行，它会使当前线程让出CPU。声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。让出CPU并不表 示当前线程不执行了。当前线程在让出CPU后，CPU根据优先级调度给优先级高的线程。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地调用时自行进行处理。</p><h3 id="wait-和sleep-的区别【重要】"><a href="#wait-和sleep-的区别【重要】" class="headerlink" title="wait()和sleep()的区别【重要】"></a>wait()和sleep()的区别【重要】</h3><ul><li><code>wait()</code> 是 Object 的方法，而 <code>sleep()</code> 是 Thread 的静态方法；</li><li><code>wait()</code> 会释放锁，<code>sleep()</code> 不会释放锁。</li><li><code>Wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。</li></ul><h2 id="2-4-ThreadLocal是什么？有什么用？"><a href="#2-4-ThreadLocal是什么？有什么用？" class="headerlink" title="2.4 ThreadLocal是什么？有什么用？"></a>2.4 ThreadLocal是什么？有什么用？</h2><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。</p><p>（数据在堆上面，然后每个线程分一小块自己特定的区域？）</p><h1 id="3-线程池【重要】"><a href="#3-线程池【重要】" class="headerlink" title="3 线程池【重要】"></a>3 线程池【重要】</h1><h2 id="3-1-为什么要使用线程池"><a href="#3-1-为什么要使用线程池" class="headerlink" title="3.1 为什么要使用线程池"></a>3.1 为什么要使用线程池</h2><blockquote><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。将活跃的线程放入线程池中，方便取用。<strong>创建线程和关闭线程的流程变为了：从线程池中获得空闲线程和向池子归还线程</strong></p><p>好处：</p><ul><li><p>提高响应速度、减少了创建新线程的时间</p></li><li><p>降低资源消耗、重复利用线程池中的线程，不需要每次都创建</p></li><li><p>便于线程的管理，<code>ThreadPoolExecutor</code>类方法中的参数</p><ul><li><code>corePoolSize</code> 核心池的大小</li><li><code>maximumPoolSize</code> 最大线程数</li><li><code>keepAliveTime</code>  当线程池线程数量超过<code>corePoolSize</code>时，多余的空闲线程的存活时间。 即，超过<code>corePoolSize</code>的空闲线程，在多长时间内，会被销毁。</li><li><strong><code>workQueue</code>: 任务队列，被提交但尚未被执行的任务。</strong></li><li><strong><code>handler</code>: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</strong></li></ul></li></ul><h2 id="3-2-建议使用ThreadPoolExecutor类"><a href="#3-2-建议使用ThreadPoolExecutor类" class="headerlink" title="3.2 建议使用ThreadPoolExecutor类"></a>3.2 建议使用<code>ThreadPoolExecutor</code>类</h2><blockquote><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><p> <code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code> </p></blockquote><h3 id="3-2-1-ThreadPoolExecutor类介绍"><a href="#3-2-1-ThreadPoolExecutor类介绍" class="headerlink" title="3.2.1 ThreadPoolExecutor类介绍"></a>3.2.1 <code>ThreadPoolExecutor</code>类介绍</h3><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。（这个参数在等待队列满了之后发挥作用，判断是否使用拒绝策略）</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212516.png" alt="线程池各个参数的关系" style="zoom:67%;"><h3 id="3-2-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#3-2-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="3.2.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>3.2.2 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3><blockquote><p>1《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供！</p><p>2《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable.java</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutorDemo.java</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h3 id="3-2-3-线程池执行原理分析"><a href="#3-2-3-线程池执行原理分析" class="headerlink" title="3.2.3 线程池执行原理分析"></a>3.2.3 线程池执行原理分析</h3><blockquote><p>分析上小节的执行结果</p></blockquote><p>核心线程是是5，当循环创建5个线程并执行之后，新创建的线程将进入等待队列。使用的拒绝策略是CallerRimsPolicy策略，类似于一直等核心核心线程空出来，出来了等待的线程就上去。</p><p>即每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p><p><strong>执行过程分析：</strong></p><ul><li>线程池会判断当前已创建的线程**是否小于 corePoolSize  (核心线程数)**，如果小于，就会选择创建一个新的线程来执行该任务。</li><li>当线程池中已创建的线程数等于核心核心线程数时，此时<strong>判断任务队列是否已满</strong>，如果未满，就加入等待队列</li><li>如果等待队列已满，<strong>再判断最大线程数</strong>，如果小于直接新建线程执行任务。大于就执行拒绝策略</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212523.png" alt="图解线程池实现原理"></p><h2 id="3-3-拒绝策略handler【重要】"><a href="#3-3-拒绝策略handler【重要】" class="headerlink" title="3.3 拒绝策略handler【重要】"></a>3.3 拒绝策略handler【重要】</h2><p>线程池中的线程数已经用完了，无法继续为新任务 服务，同时，等待队列中也己经排满了，再也塞不下新任务了。拒绝策略即系统超负荷运行时的补 救措施</p><p>四种拒绝策略如下：</p><ul><li><p> AbortPolicy策略：该策略会直接抛出异常，阻止该任务正常执行。【默认】</p></li><li><p>CallerRimsPolicy策略：调用线程直接运行新任务的run方法。这样做虽然不会丢弃新任务，但是，任务提交线程的性能极有可能会急剧下降。</p></li><li><p>DiscardOledestPolicy策略：丢弃任务队列中最先进入的任务。通常用于类似记录轨迹、偶尔丢失一些数据没有关系，烦希望最新的数据可以的得到保存。</p></li><li><p>DiscardPolicy策略：该策略默默地丢弃无法处理的任务，不予任何处理。通用用于期望保存旧数据的场景</p></li></ul><h2 id="3-4-线程池的几个方法对比"><a href="#3-4-线程池的几个方法对比" class="headerlink" title="3.4 线程池的几个方法对比"></a>3.4 线程池的几个方法对比</h2><p><strong>execute() VS submit()</strong></p><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功（可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。）</li></ul><p><strong>shutdown() VS shutdownNow()</strong></p><ul><li>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。<br>shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终</li></ul><p><strong>isTerminated() VS isShutdown()</strong></p><ul><li>isShutDown 当调用 shutdown() 方法后返回为 true。</li><li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li></ul><h2 id="3-5-几个常见的线程池"><a href="#3-5-几个常见的线程池" class="headerlink" title="3.5 几个常见的线程池"></a>3.5 几个常见的线程池</h2><blockquote><p>这几个类其实都是对ThreadPoolExecutor类的封装，不推荐使用哦</p></blockquote><p>newFixedThreadPool(int nThreads)</p><ul><li>返回一个固定线程数量的线程池。该线程池中的线 程数量始终不变。</li><li><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列</li><li>使用无界队列，不会拒绝任务，会导致内存溢出OOM</li></ul><p>newSingleThreadExecutor() </p><ul><li>返回一个只有一个线程的线程池</li><li>同样使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列，会导致OOM</li></ul><p>newCachedThreadPool() </p><ul><li>该方法返回一个可根据实际情况调整线程数量的线程池。 线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。</li><li><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><p>newScheduledThreadPool(int corePoolSize)</p><ul><li> 主要用来在给定的延迟后运行任务，或者定期执行任务。可以指定线程数量</li><li>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><h2 id="3-6-线程池大小的确定"><a href="#3-6-线程池大小的确定" class="headerlink" title="3.6 线程池大小的确定"></a>3.6 线程池大小的确定</h2><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N+1)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。<strong>我们大多数的业务，因为要操作数据库、一般都是IO密集的任务</strong>，只有大量排序、计算圆周率小数点后位数这种任务可以认为是CPU密集的。</p><p>其实对于IO密集型类型的应用，网上还有一个公式：<strong>线程数 = CPU核心数/(1-阻塞系数)</strong></p><p>引入了阻塞系数的概念，一般为0.8~0.9之间，如果取0.8就是5倍的核心数，如果取0.9就是10倍的核心数</p><h1 id="4-悲观锁：synchronized关键字和ReentrantLock可重入锁"><a href="#4-悲观锁：synchronized关键字和ReentrantLock可重入锁" class="headerlink" title="4 悲观锁：synchronized关键字和ReentrantLock可重入锁"></a>4 悲观锁：synchronized关键字和ReentrantLock可重入锁</h1><h2 id="4-1-synchronized关键字介绍"><a href="#4-1-synchronized关键字介绍" class="headerlink" title="4.1 synchronized关键字介绍"></a>4.1 synchronized关键字介绍</h2><p>功能：实现线程之间的同步，对同步的代码加锁，使得每一次、只有一个线程能进入同步块</p><p>三种使用方法（范围越来越大）</p><ul><li><p>指定加锁的对象：给指定的对象加锁</p></li><li><p>直接作用于实例方法：对当前实例加锁</p></li><li><p>直接所用于静态方法：对当前的类加锁</p></li></ul><h2 id="4-2-谈谈synchronized与ReentrantLock的区别？"><a href="#4-2-谈谈synchronized与ReentrantLock的区别？" class="headerlink" title="4.2 谈谈synchronized与ReentrantLock的区别？"></a>4.2 谈谈synchronized与ReentrantLock的区别？</h2><ul><li><p>底层实现上来说</p><ul><li><p>synchronized 是JVM层面的锁，是Java关键字，synchronized 的实现涉及到锁的升级和优化，具体为无锁、偏向锁、轻量级锁、自旋锁等。</p></li><li><p>ReentrantLock 是从jdk1.5以来提供的API层面的锁。</p></li></ul></li><li><p>从锁的对象来说</p><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li></ul></li><li><p>从操作步骤来说</p><ul><li><p>synchronized 不需要手动获取锁和释放锁，使用简单；</p></li><li><p>lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p></li></ul></li><li><p>ReentrantLock具有更多得功能</p><ul><li><p>ReentrantLock则可以设置中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法；</p></li><li><p>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p></li><li><p>ReentrantLock通过绑定Conditiont条件结合await()/singal()方法实现线程的精确唤醒</p></li></ul></li></ul><h2 id="4-3-Java虚拟机对锁优化（synchronized）"><a href="#4-3-Java虚拟机对锁优化（synchronized）" class="headerlink" title="4.3 Java虚拟机对锁优化（synchronized）"></a>4.3 Java虚拟机对锁优化（synchronized）</h2><p>方案一：锁的升级，无锁——&gt;锁偏向——&gt;轻量级锁——&gt;自旋锁</p><p>方案二： 锁消除</p><p><strong>1 锁偏向</strong></p><ul><li><p>如果一个线程获得了锁，那么 锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。</p></li><li><p>对于几乎没有锁竞争的场合，偏向锁有比较好 的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。</p></li><li><p>而对于锁竞争比较激烈的场合，其效果不佳</p></li></ul><p><strong>2 轻量级锁</strong></p><ul><li><p>如果偏向锁失败，虚拟机并不会立即挂起线程。而是使用轻量级锁。</p></li><li><p>轻量级锁简单地将对象头部作为指针，指向持有锁的线程堆栈的内部， 来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。</p></li><li><p>如果 轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p></li></ul><p><strong>3 自旋锁</strong></p><ul><li><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力 — 自旋锁</p></li><li><p>系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。</p></li><li><p>因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。</p></li><li><p>如果还不能获得锁，才会真实地将线程在操作系统层面挂起。</p></li></ul><p><strong>4 锁消除</strong></p><ul><li><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p></li><li><p>比如， 你很有可能在一个不可能存在并发竞争的场合使用Vector。</p><ul><li>如果Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到 这种情况，就会将这些无用的锁操作去除。</li></ul></li></ul><h1 id="5-乐观锁和CAS"><a href="#5-乐观锁和CAS" class="headerlink" title="5 乐观锁和CAS"></a>5 乐观锁和CAS</h1><h2 id="5-1-乐观锁与CAS算法"><a href="#5-1-乐观锁与CAS算法" class="headerlink" title="5.1 乐观锁与CAS算法"></a>5.1 乐观锁与CAS算法</h2><p>对于乐观锁，开发者认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。</p><p>到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。</p><p>乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。</p><p>CAS 算法的思路如下：</p><ul><li><p>包含三个参数C A S (V ，E ，N )。V 表示要更新的变量，E 表示预期值，N 表示新值。</p></li><li><p>仅当V 值等于E 值时，才会将V 的值设为N 。</p></li><li><p> 如果V 值和E 值不同，则说明己经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</p></li></ul><h2 id="5-2-ABA问题及解决方法简述"><a href="#5-2-ABA问题及解决方法简述" class="headerlink" title="5.2 ABA问题及解决方法简述"></a>5.2 ABA问题及解决方法简述</h2><p>CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。</p><p>juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。</p><h2 id="5-3-常见的Atomic类"><a href="#5-3-常见的Atomic类" class="headerlink" title="5.3 常见的Atomic类"></a>5.3 常见的Atomic类</h2><p>简述常见的Atomic类</p><p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。 基本数据类型的原子类有：</p><p>Atomic整形类型有：</p><ul><li>AtomicInteger 原子更新整形</li><li>AtomicLong 原子更新长整型</li><li>AtomicBoolean 原子更新布尔类型</li></ul><p>Atomic数组类型有：</p><ul><li>AtomicIntegerArray 原子更新整形数组里的元素</li><li>AtomicLongArray 原子更新长整型数组里的元素</li><li>AtomicReferenceArray 原子更新引用类型数组里的元素。</li></ul><p>Atomic引用类型有</p><ul><li>AtomicReference 原子更新引用类型</li><li>AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li><li>AtomicStampedReference 原子更新带有版本号的引用类型</li></ul><p>FieldUpdater类型：</p><ul><li>AtomicIntegerFieldUpdater 原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater 原子更新长整形字段的更新器</li><li>AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li></ul><h2 id="5-4-简述Atomic类基本实现原理"><a href="#5-4-简述Atomic类基本实现原理" class="headerlink" title="5.4 简述Atomic类基本实现原理"></a>5.4 简述Atomic类基本实现原理</h2><p>以AtomicIntger 为例： 方法getAndIncrement：以原子方式将当前的值加1，具体实现为：</p><ol><li>在 for 死循环中取得 AtomicInteger 里存储的数值</li><li>对 AtomicInteger 当前的值加 1</li><li>调用 compareAndSet 方法进行原子更新</li><li>先检查当前数值是否等于 expect</li><li>如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li><li>如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li></ol><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212530" alt="图片"></p><h2 id="5-5-悲观锁和乐观锁的区别【重要】"><a href="#5-5-悲观锁和乐观锁的区别【重要】" class="headerlink" title="5.5 悲观锁和乐观锁的区别【重要】"></a>5.5 悲观锁和乐观锁的区别【重要】</h2><p>悲观锁：总是假设最坏情况，每次取数据时都认为其他线程会修改数据，所以都会加锁，当其他线程想要访问数据时，都要挂起等待。</p><p>乐观锁：总是认为不会产生并发的问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般使用CAS机制来实现！</p><p>悲观锁和乐观锁分别有不同的使用场景，显然在高并发的场合或者重试代价特别大的场合，线程竞争激烈，适合用悲观锁、避免出现线程安全问题。在很少发生线程安全问题的场合，适合用乐观锁的思想，能提高程序运行的效率。</p><h1 id="6-AQS、并发容器"><a href="#6-AQS、并发容器" class="headerlink" title="6 AQS、并发容器"></a>6 AQS、并发容器</h1><blockquote><p>这部分不看了、直接说不知道吧</p></blockquote><p>AQS 队列同步器是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>AQS是实现锁的关键。AQS有两种模式：</p><ul><li><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p></li><li><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功，ReadLock 就采用共享模式。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java并发浅析面经。线程、线程池、悲观锁、乐观锁。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="并发" scheme="https://wukang555.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JVM思路大赏</title>
    <link href="https://wukang555.github.io/2021/07/28/%E9%9D%A2%E7%BB%8F_04_JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://wukang555.github.io/2021/07/28/%E9%9D%A2%E7%BB%8F_04_JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2021-07-28T14:55:00.000Z</published>
    <updated>2022-05-17T12:17:40.393Z</updated>
    
    <content type="html"><![CDATA[<p>JVM思路大赏。通俗易懂！极简。</p><a id="more"></a><h1 id="JVM思路大赏"><a href="#JVM思路大赏" class="headerlink" title="JVM思路大赏"></a>JVM思路大赏</h1><blockquote><p>[1] 主要参了Guide得 JVM文章，原文作者：<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a>原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p><p>[2] 参考了cys2018的文章 <a href="http://www.cyc2018.xyz/Java/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java虚拟机</a></p></blockquote><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><blockquote><p>我首先要理解JAVA虚拟机是什么、有什么用，然后才能去讨论JVM一些功能的具体实现。</p></blockquote><h2 id="0-1-JAVA虚拟机是什么？"><a href="#0-1-JAVA虚拟机是什么？" class="headerlink" title="0.1 JAVA虚拟机是什么？"></a><strong>0.1 JAVA虚拟机是什么？</strong></h2><p>我们知道JDK由编译器、JRE和常用类库组成，而JRE运行时环境是由JVM和核心类库组成的。java文件经由编译器编译成字节码，字节码在虚拟机上运行，所以：JVM其实就是为编译后的class字节码代码提供一种运行的环境（加上核心库）。</p><p>说白了，JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下。它直接和操作系统进行交互，与硬件不直接交互，操作系统完成和硬件的交互部分。然后我们写的java代码都运行再JVM提供的环境上，JVM通过在实际的计算机上仿真模拟了一种虚拟的计算机运行环境。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212353.png" alt="img"></p><h2 id="0-2-JAVA虚拟机有什么用？"><a href="#0-2-JAVA虚拟机有什么用？" class="headerlink" title="0.2 JAVA虚拟机有什么用？"></a><strong>0.2 JAVA虚拟机有什么用？</strong></h2><p>首先我们知道Java语言有以下的几个有优点</p><ul><li>它摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想；</li><li>提供了一个相对安全的内存管理和访问 机制，避免了绝大部分的内存泄露和指针越界问题</li><li>它实现了热点代码检测和运行时编译及优化，这使得Java应用 能随着运行时间的增加而获得更高的性能</li><li>它有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第 三方类库</li></ul><p>那么Java为什么具有以上几个优点呢？答案就再JVM之中！！</p><p><strong>1 平台无关性</strong></p><blockquote><p>字节码文件可以在不同机器上的JVM上运行，因此java才具有平台无关性</p></blockquote><ul><li>java编译的字节码文件 class文件是平台无关的，class文件再由JVM动态转换就可以变为本地的机器代码。。也就是说虽然JVM是平台有关的（不同操作系统、机器上的jvm版本是不同的），但对开发人员来说是平台无关的。编译生成的字节码文件是可以到处运行的</li><li>java数据结构的统一性，基本数据类型的大小有明确的规定，比如int永远是32位。。。但c/c++里面可以是16也可以是32</li></ul><p><strong>2 内存管理和访问机制</strong></p><blockquote><p>JVM的内存管理、类加载机制和GC也是重点中的重点！！</p><p>Java 虚拟机有自动内存管理机制，如果出现内存泄漏和溢出方面的问题，想要排查错误就必须要了解虚拟机是怎样使用内存的。</p></blockquote><ul><li>这里就包括jvm运行时的数据区域、类加载器、垃圾回收等相关内容</li><li>内存泄漏的原因和解决</li></ul><p><strong>3 热点代码检测和运行时编译及优化</strong></p><blockquote><p>热点代码的解释执行是《深入理解JVM》的第四部分内容，我是菜鸡我还不懂。</p></blockquote><ul><li>JIT（Just In Time）。在运行时按需编译的方式就是Just In Time。运行时编译分为两种方式：<strong>解释执行和热点方法</strong></li><li>解释执行指的是逐条执行。javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是<strong>解释执行。</strong></li><li><strong>热点方法</strong>就是把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。让CPU直接执行。这样编出来的代码效率会更高。</li><li>JIT线程与垃圾回收线程都是守护线程中的一种，守护线程提供一些系统性的功能服务，与普通线程不同，当一个java应用内只有守护线程时，java虚拟机会自然退出。</li></ul><h2 id="0-3-java文件是如何在JVM上运行的"><a href="#0-3-java文件是如何在JVM上运行的" class="headerlink" title="0.3 java文件是如何在JVM上运行的"></a>0.3 java文件是如何在JVM上运行的</h2><p>比如我们现在写了一个 HelloWorld.java，其实就类似于一个文本文件，只是有一定的缩进而已。</p><p>而我们知道java代码需要先经过编译器编译，然后才能在JVM上运行。而运行步骤的第一步就是：通过类加载器将所有的 <strong>.class</strong> 文件全部搬进JVM里面来</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212357.png" alt="img" style="zoom:80%;"><p><strong>接下来就要考虑.class文件放进jvm之后是如何存放的？也就是要了解JVM的内存区域</strong>（第一节会详细介绍！！）</p><p>首先是各线程所共享的：方法区、堆，然后是各线程私有的：程序计数器、栈。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212400.png" alt="img" style="zoom:67%;"><p>将class文件通过类加载器再在到JVM中，在事实上是将HelloWord.java这个类的纤细加载到了方法区中（这个过程就叫类的加载），然后JVM会找到程序的主入口，执行mian方法。后面需要什么类就加载什么类、进行对象的实例化等等，最后在栈中运行方法！！</p><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找（某个类方法表位于方法区该类的类信息中）。</p><h1 id="1-内存分配和回收策略"><a href="#1-内存分配和回收策略" class="headerlink" title="1 内存分配和回收策略"></a>1 内存分配和回收策略</h1><blockquote><p>内存区域、内存分配（堆）、回收策略（堆），每一个都是重点</p></blockquote><h2 id="1-1-运行时数据区域【重点】"><a href="#1-1-运行时数据区域【重点】" class="headerlink" title="1.1 运行时数据区域【重点】"></a>1.1 运行时数据区域【重点】</h2><p>由各个线程共享的方法区和堆，还有各线程私有的程序计数器和栈。四个区域的功能如下：</p><ul><li>方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。（运行时常量池就在方法区里面，String对象都在里面哦）</li><li>Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。堆用于存放对象实例，如数组、复杂对象等。</li><li>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li><li>虚拟机栈 这是我们的代码运行空间。我们编写的每一个方法都会放到栈里面运行。<strong>局部变量、基本类型的变量、和对象的引用也存放在栈中。</strong></li></ul><p>简单来说就是：方法区放类信息、常量和静态变量；然后栈管方法的运行、堆管对象的储存；最后程序计数器，指向下一行需要执行的命令；</p><h2 id="1-2-栈和堆的生命周期"><a href="#1-2-栈和堆的生命周期" class="headerlink" title="1.2 栈和堆的生命周期"></a>1.2 栈和堆的生命周期</h2><h3 id="虚拟机栈的执行"><a href="#虚拟机栈的执行" class="headerlink" title="虚拟机栈的执行"></a>虚拟机栈的执行</h3><p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212404.png" alt="img" style="zoom:67%;"><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；<ul><li>线程的栈空间被耗尽，无法创建新的栈帧。（无限的递归调用会产生这个问题）</li></ul></li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。？<ul><li>请求创建一个超大对象，通常是一个大数组。</li><li>超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动</li><li>过度使用终结器（Finalizer），该对象没有立即被 GC</li><li>内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。</li></ul></li></ul><h3 id="栈和堆的生命周期"><a href="#栈和堆的生命周期" class="headerlink" title="栈和堆的生命周期"></a>栈和堆的生命周期</h3><p>栈的生命周期和所处的线程是一致的。所以对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。</p><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。堆内存中存放的是对象，这些对象也就是垃圾回收器主要的回收对象，故堆也称为GC堆。下节将讲如何堆中的对象是如何分配内存的，然后讲如何对其进行回收。</p><h2 id="1-3-堆内存的分配【重点】"><a href="#1-3-堆内存的分配【重点】" class="headerlink" title="1.3 堆内存的分配【重点】"></a>1.3 堆内存的分配【重点】</h2><blockquote><p>方法区在JDK7及之前是属于永久代；但JDK8之后，HotSpot 的永久代被彻底移除了，取而代之是元空间，元空间使用的是直接内存。</p></blockquote><h3 id="1-堆内存的分代分配"><a href="#1-堆内存的分代分配" class="headerlink" title="1 堆内存的分代分配"></a>1 堆内存的分代分配</h3><p>Java堆内存中划分为<strong>年轻代</strong>和<strong>老年代</strong>，年轻代又会分为<strong>Eden</strong>（英[ˈiːdn] 伊甸园）和<strong>Survivor</strong>区。（Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。）</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212407.png" alt="img" style="zoom:67%;"><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212410.png" alt="JVM堆内存结构-JDK8"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图示：Eden 区、Survivor 区都属于新生代（这两个 Survivor 区域按照顺序被命名为from和to）</center> <h3 id="2-Minor-GC-和-Full-GC"><a href="#2-Minor-GC-和-Full-GC" class="headerlink" title="2 Minor GC 和 Full GC"></a>2 Minor GC 和 Full GC</h3><p><strong>Minor GC 和 Full GC的触发条件</strong></p><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p><p><strong>当Eden空间满了之后，会触发一个叫做Minor GC（英[ˈmaɪnə(r)] 次要的）（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，</strong>此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。<strong>经过多次的 Minor GC后仍然存活的对象会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，</strong>期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212414.png" alt="img" style="zoom:80%;"><p><strong>Minor GC 和 Full GC的定义</strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="1-4-垃圾回收算法【重点】"><a href="#1-4-垃圾回收算法【重点】" class="headerlink" title="1.4 垃圾回收算法【重点】"></a>1.4 垃圾回收算法【重点】</h2><h3 id="1-对象是生存还是死亡"><a href="#1-对象是生存还是死亡" class="headerlink" title="1 对象是生存还是死亡"></a>1 对象是生存还是死亡</h3><p><strong>判断一个对象是否需要回收</strong></p><ul><li>引用计数法：添加引用计数器：当引用他时，计数器值加一，当失效时，减一，计数器为0的对象不可再被使用<ul><li>（很难解决对象之间循环引用的问题）</li></ul></li><li>可达性分析：通过一系列的称为“GC Roots”的 对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots没有任何引用链相连（<strong>用图论的话来说，就是从GC Roots到这个对象不可达</strong>）时，则证明此对象是不可用的。<ul><li>能够解决循环引用的问题，可它的实现需要耗费大量资源和时间（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</li></ul></li></ul><p><strong>宣告一个对象的死亡：至少需要两次标记</strong></p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。<ul><li>finalize()就是一个对象最后的自救过程</li><li>finalize()已经不被推荐使用了，对象的四种引用在逐渐代替它的功能</li></ul></li></ol><h3 id="2-再谈引用"><a href="#2-再谈引用" class="headerlink" title="2 再谈引用"></a>2 再谈引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型。</p><ul><li>强引用：被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</li><li>软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。</li><li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</li><li>虚引用：又称为幽灵引用，有没有都一样，唯一作用是回收时可以收到一条系统通知。</li></ul><h3 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3 垃圾回收算法"></a>3 垃圾回收算法</h3><p><strong>标记-清除算法</strong></p><ul><li><p>是最基础的收集算法。算法分为“标记”和“清 除”两个阶段：</p></li><li><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p></li><li><p>缺点</p><ul><li>一个是效率问题，标记和清除两个过程的效率都不高</li><li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212420.png" alt="img" style="zoom: 67%;"><p><strong>复制算法</strong></p><ul><li>为了解决效率问题的改进，将可用内存按容量划分为两块，每次只使用其中的一块。</li><li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li><li>缺点<ul><li>这种算法的代价是将内存缩小为原来的一半（也不一定是一半，可指定），堆内存的利用率不高。</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212422.png" alt="img" style="zoom:67%;"><p><strong>标记-整理算法</strong></p><ul><li>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212425.png" alt="img" style="zoom:67%;"><p><strong>分代收集算法</strong></p><ul><li>一般是把Java堆分为新生代和老年代，这样就可以根据 各个年代的特点采用最适当的收集算法。</li><li>新生代一般使用复制算法，（新生代清理频率高）</li><li>老年代使用“标记—清理”或者“标记—整理”算法 （老年代清理频率低）</li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212428.png" alt="img"></p><h4 id="Serial-（Old）收集器"><a href="#Serial-（Old）收集器" class="headerlink" title="Serial （Old）收集器"></a>Serial （Old）收集器</h4><p>Serial 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进<strong>行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</strong></p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><p>Serial Old是 Serial 收集器的老年代版本，它同样是一个单线程收集器。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212431.jpg" alt="img" style="zoom: 80%;"><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集。新生代采用标记-复制算法，老年代采用标记-整理算法。同样垃圾回收会停止其他线程。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212434.jpg" alt="img" style="zoom:80%;"><h4 id="Parallel-Scavenge-Old-收集器"><a href="#Parallel-Scavenge-Old-收集器" class="headerlink" title="Parallel Scavenge/Old 收集器"></a>Parallel Scavenge/Old 收集器</h4><p>Parallel Scavenge 看上去和ParNew 很像，但是其关注点是吞吐量（高效率的利用 CPU）。新生代采用标记-复制算法，老年代采用标记-整理算法。JDK8的默认收集器</p><p>Parallel Old是 Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h4 id="CMS收集器【重点】"><a href="#CMS收集器【重点】" class="headerlink" title="CMS收集器【重点】"></a>CMS收集器【重点】</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。CMS收集器是基于“标记—清除”算法实现的。</p><p>实现的四个步骤：</p><ul><li>初始标记（CMS initial mark）<ul><li>初始标记仅仅只是标记一下GC Roots能 直接关联到的对象，速度很快</li></ul></li><li><strong>并发标记（CMS concurrent mark）</strong><ul><li>并发标记阶段就是进行GC RootsTracing的过程，在整个回收过程中耗时最长、不需要停顿 （耗时较长）</li></ul></li><li>重新标记（CMS remark）<ul><li>重新标记阶段则是为了修正并 发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿</li></ul></li><li><strong>并发清除（CMS concurrent sweep）</strong><ul><li>需要停顿</li></ul></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212437.jpg" alt="img" style="zoom:80%;"><p>CMS是一款优秀的收集器，并发收集、低停顿但是CMS还远达不到完美的程度，它有以 下3个明显的缺点：</p><ul><li>1、CMS收集器对CPU资源非常敏感。吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>2、无法处理浮动垃圾，可能出现 Concurrent Mode Failure。</li><li>3、标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="G1收集器【重点】"><a href="#G1收集器【重点】" class="headerlink" title="G1收集器【重点】"></a>G1收集器【重点】</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212441.png" alt="img" style="zoom:67%;"><h3 id="5-方法区和常量池的回收（了解）"><a href="#5-方法区和常量池的回收（了解）" class="headerlink" title="5 方法区和常量池的回收（了解）"></a>5 方法区和常量池的回收（了解）</h3><ul><li><p>字符串常量池主要回收的是废弃的常量。</p><ul><li>如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</li></ul></li><li><p>方法区：回收无用的类，类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li></ul><h1 id="2-类的加载机制"><a href="#2-类的加载机制" class="headerlink" title="2 类的加载机制"></a>2 类的加载机制</h1><blockquote><p>类加载过程、类加载器、双亲委派模型，东西挺多的</p><p>[1] 参考了 zenjian_的文章:<a href="https://blog.csdn.net/javazejian/article/details/73413292">深入理解java类加载器ClassLoader</a></p><p>[2] 参考了 程序员刘先森的文章:<a href="https://zhuanlan.zhihu.com/p/33509426">面试官：请你谈谈java的类加载过程</a></p></blockquote><p>类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。一个类只在首次使用时加载并且仅加载一次。</p><p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p><h2 id="2-1-类加载的过程【重点】"><a href="#2-1-类加载的过程【重点】" class="headerlink" title="2.1 类加载的过程【重点】"></a>2.1 类加载的过程【重点】</h2><p>类加载的过程主要分为三个部分：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212445.jpg" alt="img"></p><p><strong>1 加载：</strong></p><p>将class文件加载到内存（类加载器），生成一个代表该类的class对象，然后将静态的数据结构转化为方法区中运行时的数据结构（我们知道方法区中保存着类的信息嘛）</p><p><strong>2 验证：</strong></p><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><ul><li>文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</li><li>元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</li><li>字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</li><li>符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</li></ul><p><strong>3 准备：</strong></p><p>为类变量(即static修饰的字段变量，静态变量)（在方法区中）分配内存，并且设置该类变量的初始默认值即0或null，如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值</p><ul><li>如果类变量是常量（static final修饰），那么它将初始化为表达式所定义的值。比如public static final int j = 123; 初始化为123。</li><li>这里也不会为实例变量分配初始化，实例变量是会随着对象一起分配到Java堆中，在创建实例的时候才会初始化</li></ul><p><strong>4 解析：</strong></p><p>将常量池内的符号引用替换为直接引用的过程。</p><ul><li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。（比如 import java.util.ArrayList就是一个全类名的符号引用）</li><li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li></ul><p><strong>5 初始化：</strong></p><p>执行类构造器的过程，目的是将类变量（static静态变量）显式的初始化，比如在准备阶段赋值默认0的变量，此时可以赋值指定的初始值。但要注意：</p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li></ul><h2 id="2-2-类加载器的分类"><a href="#2-2-类加载器的分类" class="headerlink" title="2.2 类加载器的分类"></a>2.2 类加载器的分类</h2><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。其实类加载器就是在第一个加载阶段工作的。</p><p>JVM虚拟机提供了4种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器、自定义类（custom）加载器。</p><p><strong>启动（Bootstrap）类加载器</strong></p><p>启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分。它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中。</p><p><strong>扩展（Extension）类加载器</strong></p><p>用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 </p><p><strong>系统（System）类加载器</strong></p><p>它根据 Java 应用的类路径（classpath）来加载 Java 类。一般情况下系统类加载是程序中默认的类加载器。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212449" alt="img" style="zoom:80%;"><blockquote><p>双亲委派模式要求除了BootStrap ClassLoader启动类加载器没有父类加载器之外，其余的类加载其都应当有“父类加载器”，双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，</p></blockquote><p><strong>类加载器之间的关系（了解）：</strong></p><p>启动类加载器，由C++实现，没有父类。</p><p>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</p><p>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</p><p>自定义类加载器，父类加载器肯定为AppClassLoader。</p><h2 id="2-3-双亲委派机制【重点】"><a href="#2-3-双亲委派机制【重点】" class="headerlink" title="2.3 双亲委派机制【重点】"></a>2.3 双亲委派机制【重点】</h2><p><strong>定义：</strong></p><p><strong>类加载器的双亲委派机制：当要加载一个类时，总是先请求父类加载器去处理，也就是说不管哪个类，最后都会委托到BootStrap ClassLoader（启动类加载器）进行加载。</strong></p><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。（通俗来讲就是，每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子才会自己想办法去完成，）</p><p><strong>优点：</strong></p><ul><li>1 Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，即当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li><li>2 考虑到安全因素，使java核心api中定义类型不会被随意替换。比如自己写的Object类并不会替代核心类库中的Object类<ul><li>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</li></ul></li></ul><h2 id="2-4-类加载的时机【了解】"><a href="#2-4-类加载的时机【了解】" class="headerlink" title="2.4 类加载的时机【了解】"></a>2.4 类加载的时机【了解】</h2><blockquote><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p></blockquote><h3 id="1-主动引用"><a href="#1-主动引用" class="headerlink" title="1. 主动引用"></a>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li>遇到 <strong>new</strong>、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</li><li>使用 java.lang.reflect 包的方法对类<strong>进行反射调用</strong>的时候，如果类没有进行初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要<strong>先触发其父类的初始化</strong>。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <strong>main() 方法的那个类</strong>），虚拟机会先初始化这个主类；</li><li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</li></ul><h3 id="2-被动引用"><a href="#2-被动引用" class="headerlink" title="2. 被动引用"></a>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h1 id="3-对象创建和内存溢出异常"><a href="#3-对象创建和内存溢出异常" class="headerlink" title="3 对象创建和内存溢出异常"></a>3 对象创建和内存溢出异常</h1><blockquote><p>参考《深入理解Java虚拟机》</p></blockquote><h2 id="3-1-new一个对象"><a href="#3-1-new一个对象" class="headerlink" title="3.1 new一个对象"></a>3.1 new一个对象</h2><h3 id="3-1-1-new一个对象的过程【背诵】"><a href="#3-1-1-new一个对象的过程【背诵】" class="headerlink" title="3.1.1 new一个对象的过程【背诵】"></a>3.1.1 new一个对象的过程【背诵】</h3><p>1 类加载检查</p><p> 当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能在常量池中能否定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、连接和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>2 在堆区分配对象需要的内存</p><ul><li>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</li><li>分配堆内存有两种方式：分别是 指针碰撞和空闲列表（根据使用何种垃圾回收器而定）</li><li>解决分配堆内存时可能出现的并发问题，两种方式解决：CAS+失败重试保证原子性 和 TLAB本地线程分配缓冲</li></ul><p>3 将分配到的内存空间初始化为零值（不包括对象头），然后将对象类的元信息、哈希码、GC分代年龄等信息放入对象头中（即JVM设置对象头）</p><p>4 最后才将对象初始化，将对象按程序员的意愿赋值，完成对象的创建</p><p>5 最后，如果还用对象的引用的话，就在栈区定义引用变量，将堆区对象的地址赋值给它</p><h3 id="3-1-2-分配堆内存的方式和并发问题"><a href="#3-1-2-分配堆内存的方式和并发问题" class="headerlink" title="3.1.2 分配堆内存的方式和并发问题"></a>3.1.2 分配堆内存的方式和并发问题</h3><p><strong>1 分配堆内存的方式</strong></p><p>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式：</p><ul><li><p>1.指针碰撞（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p></li><li><p>2.空闲列表（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。</p></li></ul><p>Java堆是否规整由采用何种垃圾回收器决定：</p><ul><li>使用Serial、ParNew垃圾回收器时，使用复制算法时一般是指针碰撞</li><li>使用CMS基于标记-清除的算法时，一般时空闲列表</li></ul><p><strong>2 解决分配堆内存时可能出现的并发问题</strong></p><p>除了如何划分可用空间外，在并发情况下划分不一定是线程安全的，有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，解决这个问题两种方案：</p><ul><li><p>1.分配内存空间的动作进行同步处理：实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。</p></li><li><p>2.内存分配的动作按照线程划分在不同的空间中进行：为每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。</p></li></ul><h3 id="3-1-3-对象的内存布局"><a href="#3-1-3-对象的内存布局" class="headerlink" title="3.1.3 对象的内存布局"></a>3.1.3 对象的内存布局</h3><p>  在HotSpot虚拟机中，对象在内存中的存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）.</p><p><strong>对象头</strong></p><ul><li><p>1 第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。</p></li><li><p>2 类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象的哪个实例。</p></li></ul><p><strong>实例数据</strong></p><p>对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p><strong>对齐填充</strong></p><p>对齐填充不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</p><h2 id="3-2-内存溢出-out-of-menmery【重点】"><a href="#3-2-内存溢出-out-of-menmery【重点】" class="headerlink" title="3.2 内存溢出 out of menmery【重点】"></a>3.2 内存溢出 out of menmery【重点】</h2><blockquote><p>内存溢出（OutOfMemory）：没有足够的空间来供jvm分配新的内存块<br>内存泄露（Memory Leak）：已经分配好的内存或对象，当不再需要，没有得到释放</p></blockquote><p>在java虚拟机规范的描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有可能发生内存溢出异常的可能。分别有：Java堆的溢出、虚拟机栈和本地方法栈的溢出、方法区和运行时常量池的溢出、本机直接内存的溢出。</p><h3 id="1-Java堆的溢出"><a href="#1-Java堆的溢出" class="headerlink" title="1 Java堆的溢出"></a>1 Java堆的溢出</h3><p><strong>定义：</strong></p><ul><li>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机 制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</li></ul><p><strong>解决：</strong></p><p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，一般先用工具判断到底是出现了内存泄漏还是内存溢出问题</p><ul><li>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。判断哪些对象无法自动回收，定位出泄漏代码的位置</li><li>如果不存在泄露，那就应当检查虚拟机的<strong>堆参数（-Xmx 与-Xms）</strong>，与机器物理内存对比看是否还可以调大</li></ul><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2 虚拟机栈和本地方法栈溢出"></a>2 虚拟机栈和本地方法栈溢出</h3><p><strong>原因：</strong></p><ul><li><p>1 栈溢出的原因一般是循环调用方法导致栈帧不断增多，栈深度不断增加，最终没有内存可以分配，出现StackOverflowError。</p></li><li><p>2 也有可能是建立了过多的线程导致的内存溢出</p></li></ul><p><strong>解决：</strong></p><ul><li>如果是单线程递归照成的栈溢出，需要检查代码的循环调用是否有问题</li><li>如果是多线程导致的溢出，在不能减少线程数或者更换64位 虚拟机的情况下，就只能通过<strong>减少最大堆和减少栈容量</strong>来换取更多的线程（即增多栈内存的个数）。</li></ul><h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3 方法区和运行时常量池溢出"></a>3 方法区和运行时常量池溢出</h3><p><strong>原因：</strong></p><ul><li>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。分配内存不够时会溢出</li></ul><p><strong>解决：</strong></p><ul><li>手动设置最大永久代（MaxPermSize）大小</li></ul><h1 id="4-JVM调优"><a href="#4-JVM调优" class="headerlink" title="4 JVM调优"></a>4 JVM调优</h1><blockquote><p>调优这里暂时就先不看了，先了解一些常用的参数</p><p>详细请参考<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a>的第四部分</p></blockquote><h2 id="4-1-JVM常用参数"><a href="#4-1-JVM常用参数" class="headerlink" title="4.1 JVM常用参数"></a>4.1 JVM常用参数</h2><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><strong>-Xms</strong></td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td><strong>-Xmx</strong></td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置永久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td><strong>-XX:MaxPermSize</strong></td><td>设置永久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td><strong>-Xss</strong></td><td>每个线程的（堆）栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr></tbody></table><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值 和 初始java堆最小值</p><p>（Xmx默认值是物理内存的1/4(&lt;1GB)）（Xms默认值是物理内存的1/64(&lt;1GB))</p><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，默认空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。（40% 70%的比例也是可以指定的）</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整Survivor区和Eden区的比值"><a href="#4-3-调整Survivor区和Eden区的比值" class="headerlink" title="4.3 调整Survivor区和Eden区的比值"></a>4.3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值 （一般8：1：1）</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><h3 id="4-7-JVM的栈参数调优"><a href="#4-7-JVM的栈参数调优" class="headerlink" title="4.7 JVM的栈参数调优"></a>4.7 JVM的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JVM思路大赏。通俗易懂！极简。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="JVM" scheme="https://wukang555.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java集合初探</title>
    <link href="https://wukang555.github.io/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://wukang555.github.io/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/</id>
    <published>2021-07-27T14:55:00.000Z</published>
    <updated>2022-05-17T12:17:19.282Z</updated>
    
    <content type="html"><![CDATA[<p>Java集合初探面经。</p><a id="more"></a><h1 id="Java集合初探"><a href="#Java集合初探" class="headerlink" title="Java集合初探"></a>Java集合初探</h1><blockquote><p>集合值得花单独的一篇来讲</p><p>先要了解整个集合的而体系，由什么接口或者父类实现继承而来</p><p>几个常用集合如何分类、底层原理、扩容原理、线程安全</p></blockquote><h1 id="1-java中的集合体系"><a href="#1-java中的集合体系" class="headerlink" title="1 java中的集合体系"></a>1 java中的集合体系</h1><blockquote><p>[1] 此小节参考了库森的<a href="https://github.com/cosen1024/Java-Interview">面试小抄</a></p><p>简单的来讲分为Collection和Map两个体系，list、set、queue都是实现Collection接口的集合类。</p><p><strong>注意：Collection是一个接口，Map不是Collection的子接口</strong>。Collections是一个静态工具类，里面包含对集合的各种操作方法。</p></blockquote><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。</p><p><strong>List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</strong></p><p><strong>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</strong></p><p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212339.png" alt="img"></p><p><img src="/2021/07/27/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E9%9B%86%E5%90%88/image-20210403163751501.png" alt="image-20210403163751501"></p><h1 id="2-讲讲ArrayList和LinkedList"><a href="#2-讲讲ArrayList和LinkedList" class="headerlink" title="2 讲讲ArrayList和LinkedList"></a>2 讲讲ArrayList和LinkedList</h1><p>ArrayList和LinkedList都是实现了List接口的类，他们都是元素的容器，用于存放对象的引用，并可以对存放的元素进行增删改查的操作，还可以进行排序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,(o1,o2)-&gt;(o2-o1)); <span class="comment">//list数组，递减排序</span></span><br></pre></td></tr></table></figure><h2 id="2-1-ArrayList介绍"><a href="#2-1-ArrayList介绍" class="headerlink" title="2.1 ArrayList介绍"></a>2.1 ArrayList介绍</h2><p>1 实现机制</p><ul><li>内部使用数组的形式实现存储，实现了RandomAccess接口，利用数组的下标进行元素的访问，因此对元素的随机访问速度特别快。</li><li>但是进行元素插入的时候，需要移动插入位置之后的所有元素，位置越靠前，需要位移的元素越多，开销越大；</li></ul><p>2 适用场景</p><ul><li>ArrayList适用在查找多,增删少的场景。如果元素的增删总是发生在数组的尾部，那么也可以选择ArrayList</li></ul><p>3 扩容机制</p><ul><li>ArrayList在初始化的时候，有初始大小10，插入新元素的时候，会判断是否需要扩容，扩容的步长是0.5倍原容量，扩容方式是利用数组的复制，因此有一定的开销；</li></ul><h2 id="2-2-LinkedList介绍"><a href="#2-2-LinkedList介绍" class="headerlink" title="2.2 LinkedList介绍"></a>2.2 LinkedList介绍</h2><p>1 实现机制</p><ul><li>内部使用双向链表的结构实现存储。因此对元素增删改速度更快，直接操作链表指针即可。</li><li>LinkedList的随机访问速度惨不忍睹，因为无论你要访问哪一个元素，都需要从head起步正向或反向的进行元素遍历；</li><li>之所以采用双向链表而非单链表实现，也是采用了空间换性能的方式，来降低查询操作的时间复杂度。如果采用单链表实现只能从头至尾遍历查找，时间复杂度是O(n)；但采用双链表实现，根据当前链表中实际结点个数size和要查找的索引进行比较，选择正向或者反向遍历。这种查找算法会比单链表从头至尾遍历减少一半的查找时间，提高了查找性能</li></ul><p>2 适用场景</p><ul><li>LinkedList适用在增删多,查找少的场景。（长链表情景下查询尤其缓慢）</li></ul><p>3 扩容机制</p><ul><li>LinkedList的元素并不需要连续存放，但是每个存放元素的单元比元素本身需要更大的空间，因此LinkedList对空间的要求比较大，但是扩容的时候不需要进行数组复制，因此没有这一环节的开销。</li></ul><h2 id="2-3-ArrayList-与-Vector-区别？"><a href="#2-3-ArrayList-与-Vector-区别？" class="headerlink" title="2.3 ArrayList 与 Vector 区别？"></a>2.3 ArrayList 与 Vector 区别？</h2><ul><li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了synchronized关键字，来保证线程的安全性。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li></ul><h1 id="3-讲讲HashMap和ConcurrentHashMap"><a href="#3-讲讲HashMap和ConcurrentHashMap" class="headerlink" title="3 讲讲HashMap和ConcurrentHashMap"></a>3 讲讲HashMap和ConcurrentHashMap</h1><blockquote><p>JDK8在JDK7的基础上做了较大的调整，以JDK7为基础讲解，然后提及JDK8的改进</p></blockquote><h2 id="3-1-JDK7中的Map集合"><a href="#3-1-JDK7中的Map集合" class="headerlink" title="3.1 JDK7中的Map集合"></a>3.1 JDK7中的Map集合</h2><p><strong>1 HashMap</strong></p><ul><li>在JDK8以前的HashMap是通过数组 + 链表的数据结构实现的。数组中的每一个元素都是一个包含键值对以及一个next指针的Entry对象，通过int index =key.hashCode()&amp;(length-1) （与运算）得到数组的下标索引，从而将键值对映射到数组的不同槽位。当发生哈希碰撞时（就是键的hash值相等），新节点经过头插法插入链表中。</li><li>但是当具体相同Hash值的Key较多的时候，链表的长度将会很长，导致查询效率极其低下</li><li>扩容机制：hashmap的初始容量16，当需要执行Resize()扩容时，会执行一个ReHash操作，ReHash在并发的情况下有可能使链表成环，因此是线程不安全的。</li></ul><p><strong>2 ConcurrentHashMap</strong></p><ul><li><p>ConcurrentHashMap就是为了解决hashmap线程不安全的问题，JDK8之前的ConcurrentHashMap是采用锁分段技术实现了线程安全。相当于将HashMap中的table数组拆分成若干个分段数组，每一个Segment管理table数组的一个区间。Segment继承了ReentrantLock可重入锁，一个Segment就是一把锁。当对table数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p></li><li><p>这种方式是一种粗粒度的并发控制方案，当两个操作位于不同的两个段时可以不受线程安全的影响，但是位于同一个数组段的不同槽位的更新操作依然会受到并发控制的互斥限制</p></li></ul><h2 id="3-2-JDK8中的Map集合"><a href="#3-2-JDK8中的Map集合" class="headerlink" title="3.2 JDK8中的Map集合"></a>3.2 JDK8中的Map集合</h2><blockquote><p>HashMap和ConcurrentHashMap的实现都做了大的调整</p></blockquote><p><strong>1 HashMap</strong></p><ul><li>HashMap主要对长链表时查询缓慢的问题进行了改进，主要就是将长链表换成了红黑树。因此JDK8的HashMap采用了数组+短链表+红黑树的数据结构实现，在链表的长度超过8个节点的时候，将会将链表通过旋转的方式直接转换成红黑树（称之为树化），红黑树的引入在查询效率上至少提升了2倍以上。</li><li>JDK8的HashMap的table数组元素是由一个个Node或TreeNode节点组成，红黑树对应的数组槽位中始终存储其根节点，对于链表结构，每一次新元素采用“尾插法”插入链表</li><li>JDK8的HashMap对以前版本扩容可能造成环形链的问题进行了修复。但依然可能存在数据覆盖的问题出现，因此依然不是线程安全的。多线程环境下依然需要使用ConcurrentHashMap</li></ul><p><strong>2 ConcurrentHashMap</strong></p><ul><li>JDK8的ConcurrentHashMap则将分段锁的概念细划到单个的数组槽位上，即一个table数组槽位一个锁，因此只有更新操作具有相同hash值的线程之间才会存在竞争。JDK8抛弃分段锁不但节省了不必要的空间消耗，而且用回了传统的synchronized关键字的重量级锁。</li><li>ConcurrentHashMap内部维护了一个0.75的加载因子，也就是每当内部的数组占用率达到75%的时候就会将数组扩容至原来的2倍大小，并将原来的所有元素拷贝到新数组中，拷贝的时候为了充分利用里面多出来的空间，和提高查询搜索速度，会将一些长链表或红黑树拆分成两个体积更小的链表或红黑树分别存放于新数组的原位置和原位置+原数组长度的位置</li><li>ConcurrentHashMap的优化使扩容可以由多个参与线程一起辅助完成，从而减小时间消耗，但扩容本身还是是开销比较大操作，尽量在使用之前就确定大概需要的容量</li></ul><h2 id="3-3-ConcurrentHashMap的并发"><a href="#3-3-ConcurrentHashMap的并发" class="headerlink" title="3.3 ConcurrentHashMap的并发"></a>3.3 ConcurrentHashMap的并发</h2><p><strong>1 ConcurrentHashMap 的 get 方法是否要加锁，为什么？</strong></p><ul><li>get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</li></ul><p><strong>2 哈希桶<code>table</code>用volatile修饰的原因？</strong></p><ul><li>哈希桶<code>table</code>用volatile修饰主要是保证在数组扩容的时候保证可见性。</li></ul><p><strong>3 ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？</strong></p><ul><li>我们先来说value 为什么不能为 null ，因为<code>ConcurrentHashMap </code>是用于多线程的 ，如果<code>map.get(key)</code>得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。而用于单线程状态的<code>HashMap</code>却可以用<code>containsKey(key)</code> 去判断到底是否包含了这个 null 。</li><li>（不支持key为null，是规定，就这么设计的）</li></ul><h2 id="3-4-其他map集合和Set集合"><a href="#3-4-其他map集合和Set集合" class="headerlink" title="3.4 其他map集合和Set集合"></a>3.4 其他map集合和Set集合</h2><p><strong>1 TreeMap和LinkedHashMap区别</strong></p><ul><li>LinkedHashMap 拥有 HashMap 的所有特性，它比 HashMap 多维护了一个双向链表，保证了元素是按照插入的顺序排列。是有序的，</li><li> TreeMap 的底层就是一颗红黑树，它的 containsKey , get , put and remove 方法的时间复杂度是 log(n) ，并且它是按照 key 的自然顺序（或者指定排序）排列</li></ul><p><strong>2 ConcurrentHashMap与HashTable的区别</strong></p><ul><li>都是线程安全的Map集合类，都用synchronized关键字来实现同步</li><li>ConcurrentHashMap锁的方式是稍微细粒度的，锁一个数组元素；</li><li>HashTable直接锁整个数组，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</li></ul><p><strong>3 HashSet的实现</strong></p><ul><li>HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。</li><li>HashMap的K值本身就不允许重复，就可以实现set集合的不重复的性质</li></ul><h1 id="4-集合的遍历"><a href="#4-集合的遍历" class="headerlink" title="4 集合的遍历"></a>4 集合的遍历</h1><blockquote><p>[1] 参考了这篇<a href="https://blog.csdn.net/scgyus/article/details/79105211?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-11.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-11.searchformbaiduhighlight">HashMap遍历的四种方式</a></p></blockquote><p>这里主要介绍map集合的4种遍历方式。list集合的遍历大概三种：1用索引get(i)方法遍历、2用增强for遍历、3用迭代器遍历。后两种map中都有体现、而第一种比较简单，不需要讲。</p><p><strong>1 map集合的三种遍历方式</strong></p><p>map集合的三种遍历方式分别是：1 keySet()搜索value、 2 entrySet()遍历键和值 3迭代器Iterator。三种方法各有优缺点（建议第二种）</p><ul><li>1 keySet()搜索value，在使用上更简单，但是通过key来查找value是耗时的操作。所以是一个低效的遍历（不推荐）</li><li>2 entrySet()遍历键和值，一般情况下推荐使用这种。</li><li>3迭代器Iterator，迭代器使用上虽然复杂，但是是老版本遍历map的唯一选择。并且<strong>只有使用迭代器才可以在迭代的时候从map中删除entry</strong>（通过调用iterator.remover()方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>,<span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;bb&quot;</span>,<span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 keySet()增强for遍历、实际上keySet()出来就是一个set集合</span></span><br><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只遍历value,可以用values()获得值得集合</span></span><br><span class="line"><span class="keyword">for</span> (Integer i:map.values())&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 entrySet()遍历键和值、实际上map.entrySet()出来就是一个Entry对象得set集合</span></span><br><span class="line"><span class="comment">//Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 迭代器遍历 实际上是迭代器遍历set集合（迭代器可以遍历所有的集合）</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    Integer value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;,&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 foreach和Iterator的关系</strong></p><p>foreach是jdk5新增加的一个循环结构，其本身就是由iterator实现的。相当于是做了一层简单的封装，使遍历的语法更简洁了，但是并不是继承了iterator的所有方法。</p><p>foreach和iterator最大的不同之处就在于remove()方法上</p><ul><li>iterator的remove()方法，不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态。比如不能连续两次调用remove()，至少间隔一次next()方法</li><li>foreach中删除元素、直接报错。即<strong>快速失败（fail—fast）</strong> 机制</li></ul><p><strong>3 使用for循环与使用迭代器iterator的对比</strong></p><ul><li>for循环适合于支持随机访问的集合，比如ArrayList。效率更高</li><li>iterator迭代适合于链式的顺序结构，比如LinkedList。效率更高</li></ul><h1 id="5-其他数据结构"><a href="#5-其他数据结构" class="headerlink" title="5 其他数据结构"></a>5 其他数据结构</h1><h2 id="5-1-各种树形结构及其特点"><a href="#5-1-各种树形结构及其特点" class="headerlink" title="5.1 各种树形结构及其特点"></a>5.1 各种树形结构及其特点</h2><ul><li><p>二叉查找树</p></li><li><p>左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大</p></li><li><p>缺点：正常的情况下，查找的时间复杂度为 O（logn）。但极端情况退化为链表，时间复杂度为O(n)</p></li><li><p>平衡二叉树</p><ul><li><p>是二叉查找树，并且要求左右子树树高差严格不超过1。</p></li><li><p>缺点：查询效率很高，但插入和删除的效率低，因为需要通过旋转来保证严格的平衡，过多的旋转是耗时的</p></li></ul></li><li><p>红黑树</p><ul><li>红黑树是一种弱平衡二叉树，通过对各个结点着色，仅保证没有一条路径会比其它路径长出两倍。相对于要求严格的AVL树来说，它的旋转次数少，适合增删多的场景。红黑树高度是O(log(n)).</li></ul></li><li><p>B树</p><ul><li><p>平衡多路查找树：有j个孩子的非叶结点恰好有j-1个关键码，关键码按递增次序排列</p></li><li><p>适用场景</p><ul><li>B树多用于做文件系统的索引。文件太大的话无法一次加载到内存，使用B树可以多路储存，每次只加载一个结点来查找。</li></ul></li><li><p>B+树，类似于B树的升级版本，数据都存放在叶子节点上。适合做索引、特别是顺序查找和范围查找</p></li></ul></li></ul><h2 id="5-2-位图"><a href="#5-2-位图" class="headerlink" title="5.2 位图"></a>5.2 位图</h2><blockquote><p>其实就是桶数组的思想，每一个bit位作为一个桶。01表示存在或者不存在。</p><p> int的范围是-21亿到21亿之间，用位图的话 其实就是桶数组，存int相当于至少要42亿的坑位，42亿/32  相当于 1.2亿个byte。大约600Mb左右的内存。（10亿 1e9个byte约10G）</p><p>long范围-9200亿亿到9200亿亿，位图不可能放的下。所以数据的状态不能过多！！</p></blockquote><p><strong>位图，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</strong></p><p>，数组的每一个元素的每一个二进制位都可以表示一个数据在或者不在，0表示数据存在，1表示数据不存在。因为比特位只有两种状态，要不是0，要不就是1，所以位图其实就是一种直接定址法的哈希，只不过位图只能表示这个值在或者不在。</p><p>赋值操作：（和该位为1的数）按位或将对应比特位置为1</p><p>删除操作：先取反，然后（和0）按位与，将对应比特位置0</p><p>判断是否存在：（和该位为1的数）按位与，结果不为0，说明对应位置存在！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java集合初探面经。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="集合" scheme="https://wukang555.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java基础小解</title>
    <link href="https://wukang555.github.io/2021/07/26/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://wukang555.github.io/2021/07/26/%E9%9D%A2%E7%BB%8F_03_JAVA%E4%B9%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-26T14:55:00.000Z</published>
    <updated>2022-05-17T12:16:56.043Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础小解面经。</p><a id="more"></a><h1 id="Java基础小解"><a href="#Java基础小解" class="headerlink" title="Java基础小解"></a>Java基础小解</h1><blockquote><p>面完网易，发现自己整个知识体系还没没完全搭建起来，java基础这块差的太多了。赶紧补回来！！</p><p>主要参考库森的面经（真的非常全面且细致）、再看了一下Guide和Cyc2018的笔记，其实java基础也是分模块并且可以成为体系来记忆的。所以先整理：</p><p>Cyc2018的分类：数据类型（基本、包装）、String、关键字、Object方法、继承、反射、异常、泛型、注解、新版本特性</p><p>简单的对库森面经的分类做了一点调整：java语言特点（字节码编译）、面向对象（特性、重载重写、抽象类、接口）、Object类的方法（equals hashcode）、基本语法（修饰符、关键字final/static、数据类型）、String相关、反射、泛型、序列化、异常、IO、新版本特性</p></blockquote><p>总体可以分为几部分：</p><p>1 java语言的特点 特别是面向对象的思想</p><p>2 java语言的一些基本类和基本语法，如Object类、关键字、修饰符、String类、基本数据类型</p><p>3 还要java的泛型、序列化、IO的定义和原理</p><p>4 最后是java的异常体系、反射功能还有新版本特性的简单介绍</p><h1 id="1-java语言概述"><a href="#1-java语言概述" class="headerlink" title="1 java语言概述"></a>1 java语言概述</h1><blockquote><p>这里直接摘一个百度百科的介绍解释什么是java</p></blockquote><p><strong>Java是一门面向对象编程语言</strong>，Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p><p>显而易见关键字就是“面向对象”、“静态语言”。面向对象的在本节中介绍、提高静态语言灵活性的反射机制将在本文最后介绍。</p><h2 id="1-1-面向对象的语言"><a href="#1-1-面向对象的语言" class="headerlink" title="1.1 面向对象的语言"></a>1.1 面向对象的语言</h2><p><strong>1 面向对象和面向过程的区别？</strong></p><p>面向对象指考虑问题时，以对象为单位。 将一般的客观事物和它们之间的关系抽象为具体的类，考虑他们的属性和方法。目的主要是模块化开发和拥抱程序可能发生的变化，更适合大型复杂的系统。但因为类的调用需要实例化，性能较面向过程低。</p><p>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 。面向过程一般适用于系统简单对性能要求高的场景。（单片机、嵌入式开发等）</p><p><strong>2 面向对象的三大特性？</strong></p><p>面向对象的三大特性指：封装、继承和多态</p><p>1 封装：用大白话来讲就是，封装就是将自己类内部的变量、方法设为私有、不允许外部类直接访问。要想访问、就必须通过我指定的get() set()方法来访问。封装和private直接相关。 </p><p>封装好处：</p><ul><li><p>通过方法来控制成员变量的操作，提高了代码的安全性</p></li><li><p>把代码用方法进行封装，提高了代码的复用性</p></li></ul><p>2 继承：用大白话来讲就是，将多个对象共同的部分抽象为一个父类，这些共同的属性直接在父类中定义就可以了，子类继承父类，代码更简洁。比如猫、老虎、豹子都是属于猫科动物，我就直接定义一个猫科动物的父类，这三个家伙直接继承之。</p><ul><li><p>继承好处</p><ul><li><p>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</p></li><li><p>提高了代码的可维护性(如果方法的代码需要修改，只需修改一处即可)</p></li></ul></li></ul><p>3 多态：指同一个对象，在不同时刻表现出来的不同状态。</p><ul><li><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定（set方法可以改变行为）</p></li></ul></li><li><p>运行时多态有三个条件</p><ul><li><p>继承</p><ul><li>狗和猫都继承动物类</li></ul></li><li><p>覆盖（重写）</p><ul><li>狗和猫都重写动物类的eat方法</li></ul></li><li><p>向上转型</p><ul><li><p>在main方法中使用动物对象的引用来调用狗和猫对象</p></li><li><p>调用动物的eat()方法时，实际会执行狗和猫的eat()方法</p></li><li><p>例子：花木兰替父从军</p></li></ul></li></ul></li></ul><p><strong>3 重载和重写的区别</strong></p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：指在一个类里面，方法名字相同，而参数不同。每个重载的方法都必须有一个独一无二的参数类型列表。（最常用的就是构造器的重载）</p><p>重写：指子类重写父类的方法（形参和返回值都不能变），一般子类需要重写父类的抽象方法。</p><blockquote><p>构造器只能重载而不能重写（覆盖），子类不能覆盖父类的构造函数、因为在类加载是子类需要先加载调用父类的构造方法</p></blockquote><p><strong>4 抽象类和接口的区别</strong></p><ul><li>从设计上来说，抽象类是为了继承而存在的，继承是一个 “是不是”的is关系。而 接口的实现则是 “有没有”的has关系。一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>从语法层面上讲：<ul><li>抽象类可以有普通成员变量、构造方法、非抽象的方法、静态方法；而接口只能有抽象方法</li><li>抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型的静态变量，方法只能是public abstract类型的</li></ul></li></ul><p><strong>5 java创建对象的四种方式</strong></p><p>java中提供了以下四种创建对象的方式: <strong>1 new创建新对象；2 通过反射机制；3 采用clone机制；4 通过序列化机制。</strong></p><p>前两者都需要显式地调用构造方法。对于clone机制，需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在java中序列化可以通过实现Externalizable或者Serializable来实现。</p><p><strong>6 深拷贝和浅拷贝、深复制和浅复制？？</strong></p><p>浅拷贝是指在拷贝对象时，对于基本数据类型的变量会重新复制一份，而对于引用类型的变量只是对引用进行拷贝，没有对引用指向的对象进行拷贝。</p><p>深拷贝是指在拷贝对象时，同时会对引用指向的对象进行拷贝。</p><p>浅复制：被复制对象的所有变量都含有与原来对象相同的值，而所有对其他对象的引用仍然指向原来的对象，及浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p><p>深复制：把复制对象所引用的对象都复制了一遍</p><h2 id="1-2-java语言的优点及其实现"><a href="#1-2-java语言的优点及其实现" class="headerlink" title="1.2 java语言的优点及其实现"></a>1.2 java语言的优点及其实现</h2><blockquote><p>java文件编译成字节码，字节码加载到JVM上生成机器代码，然后执行</p><p>java语言的优点其实大多是都是基于JVM的特性。JVM那篇文章将的更底层一些</p><p>三个特点：平台无关性、内存管理垃圾处理、热点代码监测和编译</p></blockquote><p><strong>1 java语言的优点</strong></p><ul><li><p>“一次编译，到处执行” 平台无关性。</p></li><li><p>相对安全的内存管理和访问机制、避免大部分内存泄露和指针越界</p></li><li><p>Java具有热点代码检测和运行时编译优化的功能、能够使程序运行时获得更高的性能</p></li><li><p>完善的API接口、支持第三方类库</p></li></ul><p><strong>2 java如何实现平台无关</strong></p><ul><li>1 java编译的字节码文件 class文件是平台无关的，class文件再由JVM动态转换就可以变为本地的机器代码。。也就是说虽然JVM是平台有关的（不同操作系统、机器上的jvm版本是不同的），但对开发人员来说是平台无关的。编译生成的字节码文件是可以到处运行的</li><li>2 java数据结构的统一性，基本数据类型的大小有明确的规定，比如int永远是32位。但c/c++里面可以是16也可以是32</li></ul><p><strong>3 java如何实现运行时按需编译</strong></p><p>在运行时按需编译的方式就是Just In Time，通过JIT线程实现。运行时编译分为两种方式：解释执行和热点方法</p><ul><li><p>解释执行指的是逐条执行。JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p></li><li><p>热点方法就是把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。让CPU直接执行。这样编出来的代码效率会更高。</p></li><li><p>JIT线程与垃圾回收线程都是守护线程中的一种，守护线程提供一些系统性的功能服务，与普通线程不同，当一个java应用内只有守护线程时，java虚拟机会自然退出。</p></li></ul><h1 id="2-java用语言的基本语法"><a href="#2-java用语言的基本语法" class="headerlink" title="2 java用语言的基本语法"></a>2 java用语言的基本语法</h1><blockquote><p> java语言的一些基本类和基本语法，如Object类、关键字、修饰符、String类、基本数据类型</p></blockquote><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><blockquote><p>Java 语言的数据类型分为两种：基本数据类型和引用数据类型。</p></blockquote><p><strong>1 八大基本数据类型</strong></p><p>1 整型：byte 1、short 2、int 4、long 8</p><p>2 浮点型：float 4、double 8</p><p>3 字符型：char 2</p><p>4 非数值型（布尔型）：boolean 1</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212315.png" alt="image-20210907131202579" style="zoom: 67%;"><p><strong>2 数据类型的转换</strong></p><ul><li>自动类型转换：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</li><li>强制类型转换：强制显示的把一个数据类型转换为另外一种数据类型。（超过范围会无意义）</li></ul><h2 id="2-2-包装类型"><a href="#2-2-包装类型" class="headerlink" title="2.2 包装类型"></a>2.2 包装类型</h2><p><strong>1 包装类型是什么？基本类型和包装类型有什么区别？</strong></p><p>包装类型实质上是一个对象的引用，Java 为每一个基本数据类型都引入了对应的包装类型。</p><ul><li><p>原始类型: boolean，char，byte，short，int，long，float，double</p></li><li><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></li></ul><p>基本类型和包装类型的区别：</p><ul><li>包装类型可以为 null，而基本类型不可以。容器中一般只能放包装类型</li><li>包装类型可用于泛型，而基本类型不可以。泛型在编译时会进行类型擦除</li><li>基本类型比包装类型更高效，<strong>基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用</strong>。</li></ul><p><strong>2 两个Integer对象的对比（==）</strong></p><ul><li><p>两个new生成的Integer变量的对比：不等</p><ul><li>都指向堆中的对象，比较的是地址，所以一定不等</li><li>非要比较，引用类型推荐用 equals()</li></ul></li><li><p>非new生成的Integer变量和 new Integer()生成变量的对比：不相等</p><ul><li>非new得Integer指向常量池；而new出来得Integer指向堆中那个新建的Integer对象</li></ul></li><li><p>两个非new生成的Integer对象的对比：在-128-127范围内相等、范围外不等</p><ul><li>因为会缓存-128-127范围内Integer对象的值</li><li>超过范围将重新new一个Integer给新建的对象</li></ul></li><li><p>Integer对象和int比较：相等</p><ul><li>因为会自动拆箱之后在比较大小</li></ul></li></ul><h2 id="2-3-String类【重要】"><a href="#2-3-String类【重要】" class="headerlink" title="2.3 String类【重要】"></a>2.3 String类【重要】</h2><p>String 被声明为 final，是一个不可变的字符串类型。在 Java 8 中，String 内部使用 char 数组存储数据。在 Java 9 之后，String 类的实现改用 byte 数组存储字符串。</p><p><strong>1 不可变的好处（4 个好处）</strong></p><p>可以缓存 hash 值</p><ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得hash 值也不可变，因此只需要进行一次计算。</li></ul><p>String Pool 的需要</p><ul><li>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul><p>安全性</p><ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，收到改变后 String 对象的那一方会以为现在连接的是其它主机，而实际情况却不一定是。</li></ul><p>线程安全</p><ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul><p><strong>2 String Pool</strong></p><p>jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护一个字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中（防止永久代溢出）。JDK8之后，永久代被元空间取代了。</p><p><strong>3 new String（“aaa”）</strong></p><ul><li>使用<code>String a = “aaa” ;</code>，程序运行时会在常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。</li><li>使用<code>String b = new String(&quot;aaa&quot;);</code>，程序会在堆内存中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。</li><li>intern()函数的作用是将对应的符号常量进入特殊处理。在JDK1.6以前是将字符串放入常量池 ；JDK1.7以后如果存在引用就将改字符串的引用放入常量池，下次取得时候其实取得是引用地址。</li></ul><p><strong>4 String，StringBuffer 和 StringBuilder</strong></p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuffer 字符串变量，线程安全，内部使用synchronized关键字进行同步</li><li>StringBuilder 字符串变量 线程不安全 效率比StringBuffer高</li></ul><h2 id="2-4-Object类【重要】"><a href="#2-4-Object类【重要】" class="headerlink" title="2.4 Object类【重要】"></a>2.4 Object类【重要】</h2><blockquote><p>所有类的老老老老祖宗，一些通用方法十分重要</p><p>**hashCode()、equals(Object obj)、clone()、toString()**、getClass()、finalize()</p><p><strong>notify()、notifyAll()、wait()</strong></p></blockquote><p><strong>1 hashCode()方法</strong></p><p>hashCode() 的作用是获取对象的哈希码，也称为散列码；它实际上是返回一个int整数。</p><p>一般要求等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p><strong>2 equals(Object obj)方法</strong></p><p>equals方法主要用于两个对象之间，检测一个对象是否等于另一个对象。一般有两种使用情况：</p><ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象（比较引用对象的地址值，基本类型的大小值）。</li><li>情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来判断两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li></ul><p>java语言规范要求equals方法具有以下特性：</p><ul><li>自反性 x.equals(x); // true</li><li>对称性。当且仅当x.equals(y)是true时，y.equals(x)也是true。</li><li>传递性。如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。</li><li>一致性。如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)返回值一致</li><li>与 null 比较为false ，x.equals(null); // false;</li><li>一般重写equals()方法是，要求也重写hashcode()方法</li></ul><p><strong>3 何时需要重写hashcode和equls方法?【重要】</strong></p><p>a 使用自定义的对象作为key时，重写了hashcode后要重写equls</p><ul><li><p>当用自己定义的对象作为key时，通常需要属性相同就认为这两个键相等</p></li><li><p>如果不重写hashcode，两个属性相同的key，永远不可能映射要一个数组槽位上面(map集合中)</p></li><li><p>如果只重写了hashcode不重写equals，那么映射到正确数组槽位中之后无法找到链表中相等的那个元素</p></li></ul><p>b 重写了equls也要重写hashcode</p><ul><li><p>因为规定equals相等的两个对象要hashcode也要一定相同</p></li><li><p>所以我们一般会先用hashcode计算hash值，来实现快速判重！！</p></li><li><p>如果hashcode相同了我们再判断equals的逻辑</p></li></ul><p><strong>4 toString()方法</strong></p><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列值的无符号十六进制<br>表示。</p><h2 id="2-5-访问修饰符"><a href="#2-5-访问修饰符" class="headerlink" title="2.5 访问修饰符"></a>2.5 访问修饰符</h2><blockquote><p>访问修饰符: public、private、protected、默认</p></blockquote><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212319.png" alt="image-20210907161619357" style="zoom:80%;"><h2 id="2-6-Java关键字"><a href="#2-6-Java关键字" class="headerlink" title="2.6 Java关键字"></a>2.6 Java关键字</h2><blockquote><p>static、abstract、final、</p></blockquote><h3 id="2-6-1-static关键字【重点】"><a href="#2-6-1-static关键字【重点】" class="headerlink" title="2.6.1 static关键字【重点】"></a>2.6.1 static关键字【重点】</h3><p><strong>“static”关键字表明一个成员变量或者是成员方法可以在没有创建该实例对象的情况下被访问。</strong></p><p>因为静态对象在虚拟机加载所属类的对象时，就已经分配了储存空间并且初始化。（联系类的加载过程）</p><p><strong>问题一：static方法是否可以被重写</strong></p><ul><li>static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。</li></ul><p><strong>问题二：static环境为什么不能访问非static变量</strong></p><ul><li>当类被Java虚拟机载入的时候，会对static变量进行初始化。而此时非静态变量的实例还没有被创建出来（new了之后才有啊），如果不用实例访问非静态变量，编译器就会报错</li></ul><p><strong>问题三：类中代码块执行顺序是什么？【重要】</strong></p><ul><li>基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块</li><li>代码块执行顺序<strong>静态代码块——&gt; 构造代码块（除了{}什么都没加的代码块） ——&gt; 构造函数——&gt; 普通代码块</strong> </li><li>继承中代码块执行顺序：<strong>父类静态块——&gt;子类静态块——&gt;父类代码块——&gt;父类构造器——&gt;子类代码块——&gt;子类构造器</strong></li></ul><h3 id="2-6-2-final关键字"><a href="#2-6-2-final关键字" class="headerlink" title="2.6.2 final关键字"></a>2.6.2 final关键字</h3><p><strong>final关键字：</strong></p><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写、但子类可以直接使用该方法。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><p><strong>随便了解一下：finally、finalize</strong></p><ul><li>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行，经常用于释放资源。（<code>System.exit (0)</code> 可以阻断其执行）</li><li>finalize 是在 <code>java.lang.Object</code> 里定义的方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</li></ul><h1 id="3-泛型、序列化和IO"><a href="#3-泛型、序列化和IO" class="headerlink" title="3 泛型、序列化和IO"></a>3 泛型、序列化和IO</h1><blockquote><p>还要了解java的泛型、序列化、IO的定义和原理</p><p>java IO好像时挺重要的一块内容，要单独开篇文章来讲….但现在我还一点都不了解、先简单看看</p></blockquote><h2 id="3-1-泛型"><a href="#3-1-泛型" class="headerlink" title="3.1 泛型"></a>3.1 泛型</h2><p>泛型是 JDK1.5 的一个新特性，<strong>泛型就是将类型参数化，其在编译时才确定具体的参数。</strong></p><p>根据《Java 编程思想》中的描述，泛型出现的动机在于：有许多原因促成了泛型的出现，而最引人注意的一个原因，就是<strong>为了创建容器类</strong>。</p><p><strong>1 使用泛型的好处</strong></p><p>先来看看不使用泛型，利用Object来实现不同类型的处理，存在两个缺点：</p><ul><li>每次使用时都需要强制转换成想要的类型</li><li>在编译时编译器并不知道类型转换是否正常，运行时才知道，不够安全。</li></ul><p>所以泛型的好处如下：</p><ol><li><p>类型安全 </p><ul><li>泛型的主要目标是提高 Java 程序的类型安全</li><li>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常，符合越早出错代价越小原则</li></ul></li><li><p>消除强制类型转换 </p><ul><li>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换</li><li>所得即所需，这使得代码更加可读，并且减少了出错机会</li></ul></li><li><p>潜在的性能收益 </p><ul><li>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改</li><li>所有工作都在编译器中完成（编译期间就确定了真正的类型）</li><li>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已</li></ul></li></ol><p><strong>2 泛型的原理是什么 ? 什么是类型擦除 ?</strong></p><p>泛型的基本原理就是类型擦除。类型擦除指：使用泛型的时候加上的不确定的类型参数(比如<code>&lt;T&gt;</code>这种不确定的类型），编译器在编译的时候去掉类型参数。一般情况下类型擦除时，会用Object类进行替换。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&lt;T&gt; &#123;</span><br><span class="line">    private T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型<code>&lt;T&gt;</code>，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。反编译一下这个 Caculate 类：<strong>发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。</strong>即将类型T差出，并变为了Object类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Caculate&#123;</span><br><span class="line">    public Caculate()&#123;&#125;</span><br><span class="line">    private Object num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3 泛型中的限定通配符和非限定通配符</strong></p><ul><li>限定通配符<ul><li><? extends T>它通过确保类型必须是T的子类来设定类型的上界</li><li><? super T>它通过确保类型必须是T的父类来设定类型的下界</li></ul></li><li>非限定通配符<code>&lt;?&gt;</code><ul><li>可以用任意类型来替代。如<code>List&lt;?&gt;</code> 的意思是这个集合是一个可以持有任意类型的集合</li></ul></li></ul><p><strong>4 判断<code>ArrayList&lt;String&gt;</code>与<code>ArrayList&lt;Integer&gt;</code>是否相等？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">Class c1 = a.getClass();</span><br><span class="line">Class c2 = b.getClass();</span><br><span class="line">System.out.println(c1 == c2); </span><br></pre></td></tr></table></figure><p>输出的结果是 true。因为无论对于 ArrayList 还是 ArrayList，它们的 Class 类型都是一直的，都是 ArrayList.class。</p><p>那它们声明时指定的 String 和 Integer 到底体现在哪里呢？</p><p><strong>答案是体现在类编译的时候。</strong>当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。</p><h2 id="3-2-序列化"><a href="#3-2-序列化" class="headerlink" title="3.2 序列化"></a>3.2 序列化</h2><blockquote><p>序列化和反序列化</p></blockquote><h3 id="1-什么是序列化和反序列化"><a href="#1-什么是序列化和反序列化" class="headerlink" title="1 什么是序列化和反序列化"></a>1 什么是序列化和反序列化</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p><ul><li><p><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是对象状态的保存与重建。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。</p><p>而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p></li><li><p><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h3 id="2-为什么需要序列化与反序列化？"><a href="#2-为什么需要序列化与反序列化？" class="headerlink" title="2 为什么需要序列化与反序列化？"></a>2 为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p><p>深入描述：</p><ul><li><strong>1 对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li></ul><p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p><ul><li><strong>2 java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong></li></ul><p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行<strong>对象的”深复制”**，即复制对象本身及引用的对象本身。</strong>序列化一个对象可能得到整个对象序列。**</p><ul><li><strong>3 对象序列化可以实现分布式对象。</strong></li></ul><p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p><h3 id="3-序列化实现的方式有哪些？"><a href="#3-序列化实现的方式有哪些？" class="headerlink" title="3 序列化实现的方式有哪些？"></a>3 序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p><p><strong>1 Serializable</strong>接口</p><p>类通过实现 <code>java.io.Serializable</code> 接口以启用其序列化功能。可序列化类的所有子类型本身都是可序列化的。<strong>序列化接口没有方法或字段，仅用于标识可序列化的语义。</strong></p><p><strong>2 Externalizable</strong>接口</p><p><code>Externalizable</code>继承自<code>Serializable</code>，该接口中定义了两个抽象方法：<code>writeExternal()</code>与<code>readExternal()</code>。</p><p>当使用<code>Externalizable</code>接口来进行序列化与反序列化的时候需要开发人员重写<code>writeExternal()</code>与<code>readExternal()</code>方法。否则所有变量的值都会变成默认值。</p><p><strong>3 两种序列化的对比</strong></p><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><h3 id="4serialVersionUID是什么？为什么要显示指定它的值"><a href="#4serialVersionUID是什么？为什么要显示指定它的值" class="headerlink" title="4serialVersionUID是什么？为什么要显示指定它的值?"></a>4serialVersionUID是什么？为什么要显示指定它的值?</h3><p>在实际开发中, 我们的类会不断迭代, 一旦类被修改了，那么旧对象的反序列化就会出现问题。serialVersionUID 就是用来表明类的不同版本间的兼容性！！</p><ul><li><p>如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID；在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID。如果此时两个类因版本和属性的不同，那么新旧serialVersionUID不相等，那么将无法完成反序列化。</p></li><li><p>如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.</p></li></ul><p>至于应当什么时候显示的指定其值，阿里巴巴Java开发手册》中有以下规定：</p><ul><li>序列化类新增属性时，请不要修改serialVersionUID，避免反序列化失败</li><li>如果是完全不兼容的升级、请修改serialVersionUID，避免反序列化混乱</li></ul><h3 id="5-不想序列化的字段和静态变量"><a href="#5-不想序列化的字段和静态变量" class="headerlink" title="5 不想序列化的字段和静态变量"></a>5 不想序列化的字段和静态变量</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。在被反序列化后，<code>transient</code> 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰变量，不能修饰类和方法。</p><p>静态变量不会被序列化。因为序列化是针对对象而言的, 而静态变量优先于对象存在, 随着类的加载而加载, 所以不会被序列化.</p><h2 id="3-3-java-IO体系"><a href="#3-3-java-IO体系" class="headerlink" title="3.3 java IO体系"></a>3.3 java IO体系</h2><h3 id="1-Java-中-IO-流分为几种？"><a href="#1-Java-中-IO-流分为几种？" class="headerlink" title="1. Java 中 IO 流分为几种？"></a>1. Java 中 IO 流分为几种？</h3><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。（实际应用分别还有字节缓冲流、字符缓冲流）</p><ul><li>字节流按 8 位传输以字节为单位输入输出数据。非纯文本文件，比如图片、视频等应该优先使用字节流。</li><li>字符流按 16 位传输以字符为单位输入输出数据。存文本文件优先使用字符流。</li></ul><h3 id="2-同步-异步-阻塞-非阻塞-IO-的区别？"><a href="#2-同步-异步-阻塞-非阻塞-IO-的区别？" class="headerlink" title="2 同步/异步/阻塞/非阻塞 IO 的区别？"></a>2 同步/异步/阻塞/非阻塞 IO 的区别？</h3><blockquote><p>同步和异步是通信机制（服务端线程本身不处理IO，交由操作系统底层处理IO），阻塞和非阻塞是调用状态（某个连接请求无事干的时候是否可以切除到其他连接请求）。</p></blockquote><ul><li><p>同步 IO 是用户线程发起 IO 请求后需要等待或轮询内核 IO 操作完成后才能继续执行。</p></li><li><p>异步 IO 是用户线程发起 IO 请求后可以继续执行，当内核 IO 操作完成后会通知用户线程，或调用用户线程注册的回调函数。</p></li><li><p>阻塞 IO 是 IO 操作需要彻底完成后才能返回用户空间 。</p></li><li><p>非阻塞 IO 是 IO 操作调用后立即返回一个状态值，无需等 IO 操作彻底完成。</p></li></ul><p>BIO：Block IO 同步阻塞式 IO，传统的IO模型。</p><p>NIO：Non IO 同步非阻塞 IO，实现了多路复用。</p><p>AIO：Asynchronous IO异步非堵塞 IO，基于事件和回调机制。</p><h3 id="3-什么是-BIO？"><a href="#3-什么是-BIO？" class="headerlink" title="3 什么是 BIO？"></a>3 什么是 BIO？</h3><p><strong>BIO</strong> 是同步阻塞式 IO，JDK1.4 之前的 IO 模型。<strong>服务器实现模式为一个连接请求对应一个线程</strong>，服务器需要为每一个客户端请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。适用连接数目少且服务器资源多的场景。</p><h3 id="4-什么是-NIO？"><a href="#4-什么是-NIO？" class="headerlink" title="4 什么是 NIO？"></a>4 什么是 NIO？</h3><p><strong>NIO</strong> 是 JDK1.4 引入的同步非阻塞 IO。<strong>服务器实现模式为多个连接请求对应一个线程</strong>，客户端连接请求会注册到多路复用器 Selector中 ，Selector 轮询到某个连接有 IO 请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p><p>同步是指线程还是要不断接收客户端连接并处理数据，非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道（一个管道对应一个请求）。</p><p>核心组件：</p><ul><li><strong>Buffer：</strong> 缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer 三个重要属性：position 下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。</li><li><strong>Channel：</strong> 双向通道，替换了 BIO 中的 Stream 流，用来存放IO连接请求，要通过 Buffer 来读写数据，也可以和其他 Channel 交互。</li><li><strong>Selector：</strong> 多路复用器，轮询检查多个 Channel 的状态，判断注册事件是否发生，即判断 Channel 是否处于可读或可写状态。使用前需要将 Channel 注册到 Selector，注册后会得到一个 SelectionKey，通过 SelectionKey 获取 Channel 和 Selector 相关信息。</li></ul><h3 id="5-什么是-AIO？-没看太懂"><a href="#5-什么是-AIO？-没看太懂" class="headerlink" title="5 什么是 AIO？(没看太懂)"></a>5 什么是 AIO？(没看太懂)</h3><p>AIO 是 JDK7 引入的异步非阻塞 IO。服务器实现模式为<strong>一个有效请求对应一个线程</strong>，客户端的 IO 请求都是由操作系统先完成 IO 操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p><p><strong>异步是指服务端线程接收到[客户端]管道后就交给底层处理IO通信</strong>，自己可以做其他事情，非阻塞是指[客户端]有数据才会处理，处理好再通知服务器。</p><p>实现方式包括通过 Future 的 <code>get</code> 方法进行阻塞式调用以及实现 CompletionHandler 接口，重写请求成功的回调方法 <code>completed</code> 和请求失败回调方法 <code>failed</code>。</p><h1 id="4-异常体系和反射"><a href="#4-异常体系和反射" class="headerlink" title="4 异常体系和反射"></a>4 异常体系和反射</h1><h2 id="4-1-异常体系"><a href="#4-1-异常体系" class="headerlink" title="4.1 异常体系"></a>4.1 异常体系</h2><p> Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。</p><p>1 <strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。<code>Exception</code> 又可以分为运行时异常(RuntimeException)和非运行时异常。</p><ul><li>RuntimeException：<ul><li>ArithmeticException 算术条件异常。譬如：整数除零等</li><li>NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时</li><li>IndexOutOfBoundsException 索引越界异常。</li></ul></li><li>非运行时异常<ul><li>IOException IO异常</li><li>ClassNotFoundEcxeption 类未找到异常</li></ul></li></ul><p>2 <strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</p><ul><li>StackOverflowError 栈溢出错误。</li><li>OutOfMemoryError 内存不足错误。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212326.png" alt="img"></p><h2 id="4-2-捕获异常"><a href="#4-2-捕获异常" class="headerlink" title="4.2 捕获异常"></a>4.2 捕获异常</h2><p>1）对代码块用try..catch..finally进行异常捕获处理；</p><ul><li>当然如果没有发生异常，则catch块不会执行。但是finally块无论在什么情况下都是会执行的（这点要非常注意，因此部分情况下，都会将释放资源的操作放在finally块中进行）。</li></ul><p>2）在 该代码的方法体外用throws进行抛出声明</p><ul><li>在调用该方法时再用try..catch捕获</li></ul><p>3）在代码块直接用throw手动抛出一个异常对象</p><h2 id="4-3-反射机制"><a href="#4-3-反射机制" class="headerlink" title="4.3 反射机制"></a>4.3 反射机制</h2><h3 id="4-3-1-什么是反射"><a href="#4-3-1-什么是反射" class="headerlink" title="4.3.1 什么是反射"></a>4.3.1 什么是反射</h3><p>Reflection反射机制允许程序在执行期间借助于Reflection API取得任何类内部的信息，并能直接操作任意对象的内部属性及方法（包括private修饰的）</p><p>加载完类之后，在内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p><p>由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完全确定，在运行期仍然可以扩展</p><p>java属于一种静态语言，而反射的功能使得java成为可以在运行时改变其结构的准动态语言</p><h3 id="4-3-2-反射机制的优缺点"><a href="#4-3-2-反射机制的优缺点" class="headerlink" title="4.3.2 反射机制的优缺点"></a>4.3.2 反射机制的优缺点</h3><p>优点：能够运行时动态获取类的实例，提高灵活性；</p><p>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；</p><h3 id="4-3-3-如何获取反射中的Class对象？"><a href="#4-3-3-如何获取反射中的Class对象？" class="headerlink" title="4.3.3 如何获取反射中的Class对象？"></a>4.3.3 如何获取反射中的Class对象？</h3><ul><li>1 Class.forName(“类的路径”)；当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>2 类名.class。这种方法只适合在编译前就知道操作的 Class。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = String.class;</span><br></pre></td></tr></table></figure><ul><li>3 对象名.getClass()。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Class clz = str.getClass();</span><br></pre></td></tr></table></figure><ul><li>4 如果是基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象。</li></ul><p>==4.3.4 反射机制的应用==</p><p>==4.3.5 反射机制的原理==</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java基础小解面经。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="java基础" scheme="https://wukang555.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统大赏</title>
    <link href="https://wukang555.github.io/2021/07/25/%E9%9D%A2%E7%BB%8F_02_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://wukang555.github.io/2021/07/25/%E9%9D%A2%E7%BB%8F_02_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-25T14:55:00.000Z</published>
    <updated>2022-05-17T12:16:34.753Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统面经，分为基础、进程管理、内存管理三个部分讲解。</p><a id="more"></a><blockquote><p>[1] 参考《现代操作系统》</p><p>[2] 参考了JavaGuide的<a href="https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis">操作系统文章</a>]</p><p>[3] 参考了cyc2018的<a href="http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.html#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">操作系统文章</a></p><p>[4] 参考了小牛的<a href="http://interviewtop.top/#/list">面经网站</a></p></blockquote><p>之前看《现代操作系统》的时候，看了前四章分别是引论、进程线程、内存管理、文件系统。似乎针对面试而言，进程线程、内存管理比较重要。Guide的总结恰好也是如此，面向面试学习主要就是弄懂Guide的文章、总结好自己能够理解的回答然后背下来，所以文章的主要结果分别是基础、进程和线程、内存管理、虚拟内存。</p><h2 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1 操作系统基础"></a>1 操作系统基础</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>操作系统是管理计算机硬件和软件资源的计算机程序。本质上讲，操作系统也是一个软件，向上对用户程序提供接口，向下接管硬件资源。</p><p>作为最接近硬件的系统软件，操作系统存在屏蔽了硬件层的复杂性，操作系统内核（Kernel）负责的基本功能有进程管理、内存管理、设备管理、文件管理。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212155.png" alt="Kernel_Layout" style="zoom:50%;"><h3 id="1-2-操作系统的基本特征"><a href="#1-2-操作系统的基本特征" class="headerlink" title="1.2 操作系统的基本特征"></a>1.2 操作系统的基本特征</h3><p><strong>并发</strong></p><ul><li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，在单个周期内只运行了一个指令。</p></li><li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。</p></li></ul><p><strong>共享</strong></p><ul><li>共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。</li><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li></ul><p><strong>虚拟</strong></p><ul><li>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li><li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li><li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，==地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。== </li></ul><p><strong>异步</strong></p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h3 id="1-3-什么是内核态和用户态？"><a href="#1-3-什么是内核态和用户态？" class="headerlink" title="1.3 什么是内核态和用户态？"></a>1.3 什么是内核态和用户态？</h3><p>为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。</p><p>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</p><p>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</p><p>操作系统内核运行在内核态，用户程序运行在用户态。</p><h3 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h3><p><strong>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</strong>系统调用就是为了使用操作系统内核的功能，如进程管理、内存管理、文件管理、设备管理等 (操作系统内核现在也分为宏内核和微内核，微内核将部分功能模块化需要频繁的进行用户态和内核态的切换)</p><ul><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li></ul><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th align="center">Task</th><th>Commands</th></tr></thead><tbody><tr><td align="center">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td align="center">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td align="center">文件操作</td><td>open(); read(); write();</td></tr><tr><td align="center">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td align="center">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td align="center">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h3 id="1-5-用户态向内核态切换的三种方式（也叫中断分类）"><a href="#1-5-用户态向内核态切换的三种方式（也叫中断分类）" class="headerlink" title="1.5 用户态向内核态切换的三种方式（也叫中断分类）"></a>1.5 用户态向内核态切换的三种方式（也叫中断分类）</h3><p>处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p><ol><li>用户程序使用系统调用，陷入内核态。系统调用本身是一种软中断。</li><li>异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。</li><li>外部中断，由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li></ol><h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2 进程和线程"></a>2 进程和线程</h2><h3 id="2-1-线程-进程的区别"><a href="#2-1-线程-进程的区别" class="headerlink" title="2.1 线程/进程的区别"></a>2.1 线程/进程的区别</h3><p>进程是资源分配的基本单位，而线程是任务调度和执行的基本单位。简单来说，进程就是一个正在运行的程序，并且一个进程中包含多个并发执行的线程（CPU调度，分配时间片给不同的线程）。</p><p>多个线程共享进程的资源（如堆和方法区），同时线程也拥有自己的程序计数器、虚拟机栈和本地方法栈。</p><p>总结来说 进程之间的执行和调度需要分配内存空间、开销较大。而线程之间的切换，开销较小</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212205.png" alt="img" style="zoom:50%;"><h3 id="2-2-进程的5种状态"><a href="#2-2-进程的5种状态" class="headerlink" title="2.2 进程的5种状态"></a>2.2 进程的5种状态</h3><p>进程一共有5种状态，分别是创建、就绪、运行（执行）、阻塞、终止。 （线程也是类似的5种状态）</p><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212209.png" alt="A61F5B5322ED49038C64BDD82D341987"></p><h3 id="2-3-进程间通信的方式"><a href="#2-3-进程间通信的方式" class="headerlink" title="2.3 进程间通信的方式"></a>2.3 进程间通信的方式</h3><blockquote><p>我还不懂，后面原理还是要看书</p><p>Guide推荐:<a href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》</a> 推荐阅读，总结的非常不错。</p></blockquote><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212212.png" alt="进程间通信模型"></p><p>进程间通信主要包括 管道、命名管道FIFO、消息队列、信号量、信号、共享内存、以及套接字socket。</p><ul><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。调用pipe系统函数即可创建一个管道。</li></ul><blockquote><p>管道本质是一个伪文件(实为内核缓冲区)，使用环形队列机制实现</p><p>管道的局限性：</p><ol><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</li><li>只能公共祖先的进程间可以使用管道。</li></ol></blockquote><ul><li><strong>有名管道(Names Pipes)</strong> : 管道只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li></ul><blockquote><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</p><p>有名管道的名字存在于文件系统中，内容存放在内存中。</p></blockquote><ul><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。</li></ul><blockquote><p>消息队列允许一个或多个进程向它写入与读取消息.</p><p>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</p><p>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</p></blockquote><ul><li><strong>信号量（Semaphores）</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。</li><li><strong>共享内存(Shared memory)</strong> ：允许多个进程共享访问同一块内存空间，因为数据不需要在进程之间复制，所以这是最快的一种 IPC。这种方式需要依靠同步操作，如信号量来同步对共享内存的访问。</li></ul><blockquote><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。（这里没懂）</p></blockquote><ul><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ul><h3 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3* 进程同步"></a>2.3* 进程同步</h3><blockquote><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul></blockquote><p>操作系统中，进程是具有不同的地址空间。有时候，需要多个进程来协同完成一些任务。 进程的互斥是解决进程间竞争关系的方法，即同一个时刻只有一个进程可以进入临界区。同步可以认为是一中更高级的互斥，指多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p><p>进程的同步主要有个两种方式：信号量和管程</p><p><strong>信号量</strong>：用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作（减操作）和V操作（加操作）。基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。特别的当信号量只能是0和1时就是一个互斥量</p><p> <strong>管程</strong>：是由一个或多个过程、一个初始化序列和局部数据组成的软件模块</p><ul><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li><li>一个进程通过调用管程的一个过程进入管程。</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</li></ul><h3 id="2-4-进程的调度算法"><a href="#2-4-进程的调度算法" class="headerlink" title="2.4 进程的调度算法"></a>2.4 进程的调度算法</h3><p>进程调度的原因</p><ul><li><p>在操作系统中，由于进程总数多于CPU的数量，它们必然会竞争CPU资源。</p></li><li><p>进程调度是指按照某种调度算法（或原则）从就绪队列中选取进程分配CPU。</p></li><li><p>通常有以下两种进程调度方式：非抢占方式、抢占方式</p><p>进程调度的常见算法</p></li></ul><p><strong>1 先来先服务调度算法（FCFS，First Come First Server）</strong></p><blockquote><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业</p></blockquote><p><strong>2 短作业优先调度算法（SJF，Short Job First）</strong></p><blockquote><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死</p></blockquote><p><strong>3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><blockquote><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。新作业少就挂起当前线程</p></blockquote><p><strong>4 优先级调度算法</strong></p><blockquote><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></blockquote><p><strong>5 时间片轮转法（RR，Round Robin）</strong></p><blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系</p></blockquote><p><strong>6 多级反馈队列调度算法（MLFQ，Multi-Level Feedback Queue）</strong></p><blockquote><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p></blockquote><h3 id="2-5-死锁的四个必要条件"><a href="#2-5-死锁的四个必要条件" class="headerlink" title="2.5 死锁的四个必要条件"></a>2.5 死锁的四个必要条件</h3><p>死锁：两个或两个以上进程在执行过程中，陷入一种循环等待资源的阻塞状态的现象。死锁的四个必要条件如下</p><ul><li>互斥条件: 一个资源每次只能被一个进程使用</li><li>不可剥夺条件:进程已获得的资源，在末使用完之前，不能被强行剥夺</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源仍然保持不放</li><li>循环等待条件：多个线程之间存在一种首尾相接、循环等待资源的关系.</li></ul><h3 id="2-6-出现死锁如何处理"><a href="#2-6-出现死锁如何处理" class="headerlink" title="2.6 出现死锁如何处理"></a>2.6 出现死锁如何处理</h3><ul><li><strong>预防——及时破环四个必要条件</strong><ul><li>破坏互斥条件、让资源共享。（比如假脱机打印技术允许若干个进程同时输出，但实际只有一个真正请求物理打印机的进程）</li><li>破坏不可剥夺条件，可能造成前段工作失效——效率很低</li><li>破坏请求和保持条件，采用预先分配资源的方法，一次性分配一个进程所需的所有资源——过于消耗资源</li><li>破坏循环等待条件，采用顺序资源分配法，就是给资源编号、顺序取用——资源数量很多时、找不到这样的一个完美的顺序的</li></ul></li><li><strong>避免——维持一个安全的系统状态</strong><ul><li>安全的系统状态一定不会导致死锁，不安全的系统状态可能导致死锁。如果资源分配不会进入不安全的系统状态就给进程分配资源</li><li>银行家算法：动态的进行资源分配，使之不进入不安全状态</li></ul></li><li><strong>检测和解除</strong><ul><li>画出资源分配图，圆圈表示进程，框表示一类资源。如果出现环路，说明死锁了。（资源重复采用矩阵的方法）</li><li>①资源剥夺法：挂起某些死锁进程并剥夺其资源。②撤销进程法：撤销一个甚至全部死锁进程并剥夺其 资源。③进程回退法：让一个或多个进程回到不至于造成死锁的状态。</li></ul></li></ul><h2 id="3-操作系统的内存管理基础"><a href="#3-操作系统的内存管理基础" class="headerlink" title="3 操作系统的内存管理基础"></a>3 操作系统的内存管理基础</h2><h3 id="3-1-什么是虚拟内存？为什么要引入虚拟内存【自用】"><a href="#3-1-什么是虚拟内存？为什么要引入虚拟内存【自用】" class="headerlink" title="3.1 什么是虚拟内存？为什么要引入虚拟内存【自用】"></a>3.1 什么是虚拟内存？为什么要引入虚拟内存【自用】</h3><p>虚拟内存是计算机系统内存管理的一种技术。每个程序拥有自己的虚拟地址空间，这些虚拟地址一般以分页的方式被映射到物理内存，但不需要映射到连续的物理内存，当程序引用到不在物理内存中的页时，就发生缺页中断修改映射关系，操作系统将再需要访问的页面映射到物理内存中以便程序顺利进行。这样造成的效果将物理内存扩充成了更大的虚拟内存，进程看起来像是拥有了更多的可用内存。</p><p>说到虚拟内存，其实也可以提一下当不使用抽象储存的情景。比如上世纪60年代的IBM360机器。直接简单粗暴的使用物理内存地址，从0到某个上限值。这样会带来两个问题：1当在一个物理内存中运行多道程序时，会出现“保护和重定位”的问题，就是一个进程的指令可能跳转到另一个进程的地址中去了（之前是使用保护键、基址寄存器和界限寄存器的解决方案来区分不同的进程）。2 就是内存的大小问题，一个现代操作系统动辄就是几十个甚至几百个进程，而内存的大小受价格等现实因素的约束一般是无法满足一些软件对内存的需求的。</p><p>所以说白了虚拟内存就是解决了这两个问题，1首先每个进程拥有私有的地址空间，进程的虚拟地址空间是独立于其他进程了，解决了保护和重定位的问题。 2其次，虚拟内存技术使用了空分复用技术，使物理内存抽象为地址空间，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。解决了内存大小不够用的问题</p><h3 id="3-2-虚拟地址和物理地址及其转换原理？"><a href="#3-2-虚拟地址和物理地址及其转换原理？" class="headerlink" title="3.2 虚拟地址和物理地址及其转换原理？"></a>3.2 虚拟地址和物理地址及其转换原理？</h3><p>虚拟地址：页面号+偏移量；物理地址：页框号+偏移量</p><p>程序或进程自己的地址称为虚拟地址，它们构成了虚拟地址空间。虚拟地址通过<strong>内存管理单元（Memory Management Unit， MMU）</strong> 映射到物理内存地址上，从而被执行。</p><p><strong>MMU是CPU里面专门用来完成地址转换的单元。MMU通过查找页表来完成虚拟地址到物理地址的转换。</strong>有两种情况：1一种是该虚拟地址存在于物理内存中时直接查出物理地址；2该虚拟地址没有映射到物理内存中，那就需要缺页中断，利用页面置换算法，将该页面置换到物理内存中，然后重新查页表得到物理地址。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212226.png" alt="image-20210728110226493"></p><p>通过页表查询物理地址具体的过程：1 通过虚拟地址的页号作为索引找到对应的“页框号”和“在不在”位，2 如果在不在位为1，就将页框号拼接上偏移量得到物理地址。如果在不在为0，就先缺页中断进行页面的调度，最后也是获得页框号后拼接上偏移量的到物理地址。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212229.png" alt="image-20210728110242076" style="zoom:80%;"><h3 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="3.3 快表和多级页表"></a>3.3 快表和多级页表</h3><blockquote><p>普通的分页和MMU查询页表进行地址的转换还存在着两个问题：</p><ul><li>1)虚拟地址到物理地址的映射必须非常快。 ——使用TLB</li><li>2)如果虚拟地址空间很大，页表也会很大——使用多级页表、倒排页表<ul><li>每个进程都需要有自己的页表，，</li><li>32位的电脑、每页4k个地址的话，，就是100万个页，，太多了</li><li>页表太大 查询的就会慢</li></ul></li></ul></blockquote><p><strong>快表TLB</strong></p><p>快表其实就是使用<strong>转换检测缓冲区（TLB）</strong>，为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。TLB一般位于MMU中，TLB中包换少量频繁使用的表项，当要转换的虚拟地址位于TLB中时、直接获取对应的物理地址，而无需再查询页表了！</p><p>TLB的实现其实是基于局部性原理：大多数程序总是对少量的页面进行多次的访问，而不是相反的。因此，只有很少的页表项会 被反复读取，而其他的页表项很少被访问。。所以我们将这些常用的访问页面的映射存在TLB中，将极大提高转换效率。</p><p><strong>多级页表</strong></p><p>引入多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。</p><ul><li>引入多级页表的原因是避免把全部页表一直保存在内存中。特别是那些从不需要的页表就不应该保留。</li><li>比如一个程序只需要12M的内存，，但虚拟内存的空间有4G。这4GB被分为1024个4MB的块，，真正是需要将3个虚拟内存块映射的物理内存加入到内存中间就好了！！</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212233.png" alt="image-20210728122507555" style="zoom:67%;"><h3 id="3-4-常用的页面置换算法"><a href="#3-4-常用的页面置换算法" class="headerlink" title="3.4 常用的页面置换算法"></a>3.4 常用的页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>包括以下算法：</p><ul><li><strong>最佳算法</strong>：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</li><li><strong>先进先出</strong>：选择换出的页面是最先进入的页面。该算法将那些经常被访问的页面也被换出，从而使缺页率升高。</li><li><strong>LRU</strong>：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。<code>LRU</code> 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 <code>LRU</code> 代价很高。</li><li><strong>时钟算法</strong>：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。它将整个环形链表的每一个页面做一个标记，如果标记是<code>0</code>，那么暂时就不会被替换，然后时钟算法遍历整个环，遇到标记为<code>1</code>的就替换，否则将标记为<code>0</code>的标记为<code>1</code>。</li></ul><h3 id="3-5-分段和段页式管理机制"><a href="#3-5-分段和段页式管理机制" class="headerlink" title="3.5 分段和段页式管理机制"></a>3.5 分段和段页式管理机制</h3><p>分段：</p><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><p>段页式：</p><p>段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p><h2 id="4-操作系统磁盘IO"><a href="#4-操作系统磁盘IO" class="headerlink" title="4 操作系统磁盘IO"></a>4 操作系统磁盘IO</h2><blockquote><p>[1] 完全参考小林coding的文章<a href="https://mp.weixin.qq.com/s/P0IP6c_qFhuebwdwD8HM7w">原来 8 张图，就可以搞懂「零拷贝」了</a> 建议阅读文章理解</p></blockquote><p>磁盘由核心态管理，用户程序想要访问磁盘数据，一般要经过系统调用，陷入核心态，进而获取数据。磁盘IO相比内存存储和cpu寄存器，是相当耗时的操作，所以要尽可能地提高磁盘IO操作的速度。</p><h3 id="4-1-三种IO方式"><a href="#4-1-三种IO方式" class="headerlink" title="4.1 三种IO方式"></a>4.1 三种IO方式</h3><blockquote><p>忙等待是阻塞的。一般来说普通异步IO和DMA模式的IO都是非阻塞的。它们的区别在于：</p><ul><li>普通异步IO在磁盘IO处理完之后就发起中断，交由CPU拷贝数据。</li><li>DMA模式的IO在DMA将磁盘数据拷贝到内核内存上之后，再发起中断，占用CPU</li></ul></blockquote><p>《现代操作系统》中介绍了实现输入输出（IO）的三种方式：忙等待、异步IO 中断、DMA中断。</p><ul><li><strong>忙等待</strong>：用户程序发出一个系统调用，然后就执行I/O过程，CPU一直等待I/O的数据，直到得到数据后处理，处理完以后返回结果，CPU才继续处理其他事情。这种方式称为忙等待。</li><li><strong>异步IO</strong>：第二种是通过异步IO和中断机制，需要I/O时，先让I/O设备执行对应操作，这个时候CPU不需要等待，继续做其他事情，如果I/O执行完，拿到数据了，这个时候由中断控制器对CPU发起一个中断，处理这个I/O得到的数据。大白话就是先让CPU处理其他事情，当得到I/O数据后，告诉CPU，你先停一下现在手头上的事儿，你刚刚要的数据准备好了，现在给你，你处理下。</li><li><strong>DMA的异步IO</strong>：使用直接存储器访问芯片(DMA,Direct Memory Access)，直接控制位流，DMA得到数据时，也会对CPU发起中断。（DMA模式的IO在DMA将磁盘数据拷贝到内核内存上之后，再发起中断，占用CPU）</li></ul><h4 id="1-传统的忙等待IO过程"><a href="#1-传统的忙等待IO过程" class="headerlink" title="1 传统的忙等待IO过程"></a><strong>1 传统的忙等待IO过程</strong></h4><ul><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器（内核缓冲区PageCache），然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212239.png" alt="6401" style="zoom:50%;"><h4 id="2-异步IO过程"><a href="#2-异步IO过程" class="headerlink" title="2 异步IO过程"></a>2 异步IO过程</h4><blockquote><p>DMA和异步IO一般都是非阻塞的IO</p></blockquote><p>异步IO用于处理cpu阻塞的问题。 当不使用PageCache 内核缓存时也称为直接IO</p><p>过程如下：</p><ul><li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li><li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212242.png" alt="6403" style="zoom:50%;"><h4 id="3-DMA中断IO过程"><a href="#3-DMA中断IO过程" class="headerlink" title="3 DMA中断IO过程"></a>3 DMA中断IO过程</h4><p><strong>DMA直接内存访问</strong>（Direct Memory Access）在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p><p>简单来讲就是，传统IO由CPU负责将数据的拷贝搬运：从磁盘缓存器—&gt;到内核缓存区—&gt;再到用户缓冲区。。而使用DMA之后，<strong>磁盘缓存器—&gt;到内核缓存区</strong>过程由DMA负责，此时cpu可以处理其他的事情也可以闲置等待….</p><p>过程如下：</p><ul><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务（这其实就是一种的异步IO）；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212246.png" alt="6402" style="zoom:50%;"><h3 id="4-2-零拷贝技术（传输小文件）"><a href="#4-2-零拷贝技术（传输小文件）" class="headerlink" title="4.2 零拷贝技术（传输小文件）"></a>4.2 零拷贝技术（传输小文件）</h3><p>传统的文件传输模式：read+write：4次上下文切换和4次数据拷贝过程。要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。零拷贝有两种方式：</p><ul><li>mmap + write：4 次上下文切换，和 3 次数据拷贝过程</li><li>sendfile： 2 次上下文切换，和 3/2 次数据拷贝过程</li></ul><h4 id="1-传统的文件传输模式（4次切换、4次拷贝）"><a href="#1-传统的文件传输模式（4次切换、4次拷贝）" class="headerlink" title="1 传统的文件传输模式（4次切换、4次拷贝）"></a>1 传统的文件传输模式（4次切换、4次拷贝）</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。如下两个系统调用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212250.png" alt="6404" style="zoom:50%;"><p>期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>分别对应着两次系统调用：一次是 <code>read()</code> ，一次是 <code>write()</code>，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的。</p><h4 id="2-mmap-write（4-次切换，和-3-次拷贝）"><a href="#2-mmap-write（4-次切换，和-3-次拷贝）" class="headerlink" title="2 mmap + write（4 次切换，和 3 次拷贝）"></a>2 mmap + write（4 次切换，和 3 次拷贝）</h4><p><code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">buf</span> = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212253.png" alt="6405" style="zoom:50%;"><p><strong>数据不用来回从内核态拷贝到用户态（只进行一个映射），减少了一次拷贝的过程</strong></p><h4 id="3-sendfile（2-次切换，和-3-次拷贝-2次拷贝）"><a href="#3-sendfile（2-次切换，和-3-次拷贝-2次拷贝）" class="headerlink" title="3 sendfile（2 次切换，和 3 次拷贝/2次拷贝）"></a>3 sendfile（2 次切换，和 3 次拷贝/2次拷贝）</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="attribute">ssize_t</span> sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br></pre></td></tr></table></figure><p><code>sendfile()</code>可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212257.png" alt="6405" style="zoom:50%;"><p>对于支持网卡支持 SG-DMA 技术的情况下，还可以直接通过SG-DMA拷贝，将内核缓存区的数据直接拷贝到网卡上，可以再省一次的拷贝过程：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212259.png" alt="6405" style="zoom:50%;"><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面（内核内存和用户内存）去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h3 id="4-3-传输大文件（异步直接IO）"><a href="#4-3-传输大文件（异步直接IO）" class="headerlink" title="4.3 传输大文件（异步直接IO）"></a>4.3 传输大文件（异步直接IO）</h3><blockquote><p>零拷贝使用了内核缓存区PageCache（一种高速缓存）来缓存磁盘数据，提高了效率，但显然不适用于大文件的传输（高速缓存区放不下大文件）</p></blockquote><p>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p><p><strong>传输大文件应当使用：异步IO+直接IO</strong>（即不使用PageCache内核高速缓存）</p><p>直接 I/O 应用场景常见的两种：</p><ul><li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li><li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li></ul><p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /video/ &#123; </span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>; </span><br><span class="line">    <span class="attribute">aio</span> <span class="literal">on</span>; </span><br><span class="line">    <span class="attribute">directio</span> <span class="number">1024m</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当文件大小大于 directio 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;操作系统面经，分为基础、进程管理、内存管理三个部分讲解。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://wukang555.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络大赏</title>
    <link href="https://wukang555.github.io/2021/07/20/%E9%9D%A2%E7%BB%8F_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://wukang555.github.io/2021/07/20/%E9%9D%A2%E7%BB%8F_01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-07-20T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:59.771Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络面经，极简共22个问题。</p><a id="more"></a><blockquote><p>[1] <a href="http://www.cyc2018.xyz/">参考了cyc2018的总结（偏理解）</a></p><p>[2] <a href="https://snailclimb.gitee.io/javaguide/">参考了JavaGuide的一些总结</a>]</p><p>[3] <a href="https://mp.weixin.qq.com/mp/homepage?__biz=Mzg4MjUxMTI4NA==&hid=1&sn=991fdb47b57f5a276873f5c4d976f59f&scene=18&uin=&key=&devicetype=Windows+10+x64&version=6302019c&lang=zh_CN&ascene=7&fontgear=2">参考了公众号程序员库森的面经总结</a></p></blockquote><h2 id="1-计算机网络的各层协议及作用？"><a href="#1-计算机网络的各层协议及作用？" class="headerlink" title="1. 计算机网络的各层协议及作用？"></a>1. 计算机网络的各层协议及作用？</h2><p>计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型。</p><p>五层网络体系结构各层的主要功能：</p><ul><li>应用层：通过不同主机上应用进程之间的交互来完成特定的网络功能，例如 HTTP、DNS 等协议。数据单位为报文。</li><li>运输层：负责为两台主机进程之间的通信提供通用的数据传输服务。运输层主要有两种协议：<ul><li>TCP：提供面向连接的、可靠的数据传输服务；数据单位为报文段</li><li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。数据单位为用户数据报</li></ul></li><li>网络层：选择合适的路由和交换结点，确保数据及时传送。网络层把传输层传递下来的报文段或者用户数据报封装成分组进行传输。主要包括IP协议。</li><li>数据链路层：将网络层传下来的IP分组封装成帧，并再相邻节点的链路上传送帧。</li><li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212117.png" alt="图片"></p><h2 id="2-TCP和UDP的区别？"><a href="#2-TCP和UDP的区别？" class="headerlink" title="2. TCP和UDP的区别？"></a>2. TCP和UDP的区别？</h2><p>TCP\UDP都是传输层的协议，TCP指传输控制协议，UDP指用户数据报协议</p><ul><li><p>TCP 保证数据的可靠传输，UDP 只尽最大努力交付，即不保证可靠交付。</p></li><li><p>TCP 是面向连接的，而 UDP 是无连接的，发送数据之前不需要建立连接，减少了开销和发送数据之前 的时延。</p></li><li><p>TCP 是面向字节流的，UDP 是面向报文的。UDP 对应用层交下来的报文既不拆分也不合并，传输整个报文。当报文过短或过长都会影响网络层的传输效率。</p></li><li><p>TCP 有拥塞控制，UDP 没有拥塞控制，因此网络中出现的拥塞不会降低源主机的发送速率。</p></li><li><p>TCP 是点到点之间的一对一通信，UDP 支持一对一、一对多和多对多的交互通信。</p></li><li><p>UDP 的首部开销很小，只有 8 字节，TCP 的首部开销为20个字节。</p></li></ul><p>适应场景的区别：</p><ul><li>TCP：适应用于传输效率要求较低，但准确率要求较高的场景，例如：文件传输、接收邮件、HTTP。</li><li>UDP：适用于效率要求相对较高，但准确性相对较低的场景， 例如：QQ聊天、在线视频、语音电话、DNS等</li></ul><h2 id="3-详细介绍一下-TCP-的三次握手机制？"><a href="#3-详细介绍一下-TCP-的三次握手机制？" class="headerlink" title="3. 详细介绍一下 TCP 的三次握手机制？"></a>3. 详细介绍一下 TCP 的三次握手机制？</h2><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212121.png" alt="image-20210616092718682" style="zoom: 50%;"><ul><li>SYN同步字段：用来建立连接，需要消耗一个序号；ACK确认字段：是确认报文段的标识，确认报文须设置ACK为1。</li><li>假设A是客户端，B是服务器；初始都是CLOSED状态，B会先创建一个连接控制块TCB并进入LISTEND收听状态，监听端口是否收到了连接请求、以便及时响应</li><li>第一次握手：A主动打开，发送建立连接的请求报文、其中SYN同步字段=1，并且消耗一个序号；假设A此时的发送序号为x。发送完之后A处于SYN_SENT同步已发送的状态；</li><li>第二次握手：B收到A发送过来的请求连接的报文，发送给A一个确认收到的报文。其中SYN同步字段=1，ACK确认字段=1；假设此时B的发送序号为y，确认号为x+1。发送完之后B处于SYN_RCVD同步已收到的状态；</li><li>第三次握手：A收到B的确认报文之后，还要给B发送一个确认报文。其中ACK确认字段=1；发送序号为x+1，确认号为y+1；发送完之后A处于连接已建立的状态；当B收到这个确认报文后、也进入连接已建立的状态。服务器要比客户端稍晚一点进入已连接的状态</li></ul><h2 id="4-为什么需要三次握手，而不是两次？"><a href="#4-为什么需要三次握手，而不是两次？" class="headerlink" title="4. 为什么需要三次握手，而不是两次？"></a>4. 为什么需要三次握手，而不是两次？</h2><p>三次握手的两个主要原因：信息对等和防止超时</p><ul><li>信息对等指客服端服务器都需要确认自己和对方有接受和发送报文段的能力。如果只有两次握手，那么站在服务器的角度、就不确定对方是否有接受报文段的能力。</li><li>三次握手也防止失效连接突然到达导致脏连接。客服端的某个超时连接突然到达，服务器以为A发送了连接请求，就发送确认报文，建立连接。如果是两报文握手连接就建立了、浪费了资源。。三报文握手A收到确认报文时并非处于同步已发送状态，所以并不会向B发送确认报文，不会建立连接。</li></ul><h2 id="5-三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#5-三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="5. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a>5. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？</h2><p><strong>服务端：</strong></p><ul><li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为同步已收到SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送对A的确认报文（SYN+ACK包），以便客户端重新发送第三次握手的确认报文（ACK包）。</li><li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li></ul><p><strong>客户端：</strong></p><p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p><h2 id="6-详细介绍一下-TCP-的四次挥手机制？"><a href="#6-详细介绍一下-TCP-的四次挥手机制？" class="headerlink" title="6. 详细介绍一下 TCP 的四次挥手机制？"></a>6. 详细介绍一下 TCP 的四次挥手机制？</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212125.png" alt="image-20210616102556722"></p><ul><li>FIN指终止字段，释放连接时用来同步序号、需要消耗一个序号</li><li>第一次挥手：当A已经没有要发送的数据就会释放连接，A发送一个请求终止连接的报文，其中FIN终止字段=1，发送序号假设等于x；x等于A发送的上一个报文的序号+1；发送完毕后A进入终止等待1状态。</li><li>第二次挥手：当B收到A的终止连接报文后，向A发送一个确认报文，其中ACK确认字段=1，发送序号假设为y，确认序号为x+1；发送完毕后B进入关闭等待的状态，A收到确认报文后就进入终止等待2的状态。。。此时整个连接处于半关闭状态，B向上通知应用层结束A到B的连接。</li><li>第三次挥手：当B的数据发送完毕后准备释放连接，就向A发送终止连接报文，其中FIN终止字段=1，发送序号设为z，此时z=y+n，n表示这个期间B发送的字节数。。确认号为x+1；发送完之后B进入最后确认阶段。</li><li>第四次挥手：当A收到B的终止报文后，再向B发送一个确认报文，其中确认字段ACK=1，发送序号=x+1，确认号为z+1；发送完之后，A进入时间等待状态，等2MSL（最大报文寿命）之后进入关闭状态；B收到确认后，进入关闭状态。一般服务器先于客服端关闭。</li></ul><h2 id="7-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？"><a href="#7-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？" class="headerlink" title="7. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？"></a>7. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</h2><ul><li>1、保证A的最后一个确认报文能够到达B，然后B能够正常关闭。如果该确认报文丢失，B这边没有收到就会超时重传一次终止连接的报文，重传的报文能够在2MSL时间内到达A，然后A就可以重传确认关闭的报文了。</li><li>2、2MSL时间之后本连接所有的报文都会消失，可以防止已失效的连接请求与正常的连接请求相混淆。</li></ul><h2 id="8-如果已经建立了连接，但是客户端出现故障了怎么办？"><a href="#8-如果已经建立了连接，但是客户端出现故障了怎么办？" class="headerlink" title="8. 如果已经建立了连接，但是客户端出现故障了怎么办？"></a>8. 如果已经建立了连接，但是客户端出现故障了怎么办？</h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p><p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p><p>保活计时器：使客服端挂掉之后，服务器端能够主动终止连接</p><ul><li>服务器每收到一次客户端的数据就重置保活器为两小时，如果两小时内没有收到就每间隔75秒发送一次探测报文，连续发10次客服端还没响应，就关闭连接。</li></ul><h2 id="9-TCP流量控制"><a href="#9-TCP流量控制" class="headerlink" title="9 TCP流量控制"></a>9 TCP流量控制</h2><ul><li>利用滑动窗口实现流量控制，即让发送方的速率不要太快、以便接收方能够来得及接收</li><li>主要流程：接受方的确认字段含 reverse Windows 大小的信息：”rwnd=x”，并确认字段要带ACK=1标识</li><li>如果确认字段rwnd=x丢失，可能会出现相互等待的死锁情况。为此设置一个持续计时器、按时发送零窗口探测报文。</li></ul><h2 id="10-TCP拥塞控制"><a href="#10-TCP拥塞控制" class="headerlink" title="10 TCP拥塞控制"></a>10 TCP拥塞控制</h2><p>拥塞指对资源的需求大于可用的资源，，拥塞是一个全局动态的过程、仅仅增加资源可能并不会解决拥塞。</p><p>通过拥塞窗口（是一个变量）控制：发送方一般让自己的发送窗口的大小等于拥塞窗口的大小。然后动态修改之，当没有出现拥塞时，就增大拥塞窗口；当可能出现拥塞时，就缩减拥塞窗口值；</p><p>拥塞控制的算法：</p><ul><li>1慢开始算法<ul><li>由小逐渐间增大拥塞窗口cwnd的值，每经过一个传输轮次、窗口值就加倍。。为防止指数增长、设置一个慢开始门限ssthresh，当cwnd值大于门限时，启用拥塞避免算法。</li></ul></li><li>2拥塞避免算法<ul><li>cwnd以线性规律增长</li></ul></li><li>3快重传算法<ul><li>接收方只要发现有缺失，无论下一个接受到的是什么报文段，总是立即返回丢失报文的上一个报文段的确认。</li><li>一旦发送方收到三个重复的确认，就能尽早的知道发生了失序。然后立刻重传（那个重复确认报文段的）下一个报文段</li></ul></li><li>4快恢复算法<ul><li>当仅丢失个别失序报文段时，启动快速重传、、此时重传没必要从最开始的慢开始算法启动，而是直接执行拥塞避免算法，即调整慢开始门限值和当前拥塞窗口值为原先拥塞窗口的一半，直接启动拥塞避免算法。</li></ul></li></ul><h2 id="11-TCP可靠传输"><a href="#11-TCP可靠传输" class="headerlink" title="11 TCP可靠传输"></a>11 TCP可靠传输</h2><p>TCP打包传输过程：</p><ul><li>报文被分割成 TCP 认为最适合发送的报文段，然后把每个报文段打包传输。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li>检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</li><li>序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</li></ul><p>TCP的两个重传协议：</p><ul><li>超时重传协议：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的</li><li>连续ARQ（自动重传请求）协议：<ul><li>发送方维持一个发送窗口、窗口内的分组都可以连续发送出去，而不必等待确认重传；</li><li>如果窗口按序收到了一个“确认”、窗口就向后滑动一格</li><li>这里的确认机制指累计确认方式、接收方对按序收到的最后一个分组发送确认，确认一旦接受、就认为这个分组之前的确认都收到了</li></ul></li></ul><h2 id="12-浏览器输入url地址-到显示页面的过程"><a href="#12-浏览器输入url地址-到显示页面的过程" class="headerlink" title="12 浏览器输入url地址,到显示页面的过程"></a>12 浏览器输入url地址,到显示页面的过程</h2><ul><li><p>1 DNS解析：实现了网址到IP地址的转换</p><ul><li><p><strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。</p></li><li><p>若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p></li></ul></li><li><p>2 TCP连接：发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 <strong>80</strong> 端口发起 tcp 的连接。</p></li><li><p>3 建立 tcp 连接后客户端发起 http 请求</p></li><li><p>4 服务器处理请求并返回HTTP报文</p><ul><li>服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。</li></ul></li><li><p>5 浏览器解析解析 html 代码，并对页面进行渲染，呈现给用户。</p></li><li><p>6 连接结束</p></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212131.png" alt="20210616124706"></p><h2 id="13-介绍一下HTTP协议"><a href="#13-介绍一下HTTP协议" class="headerlink" title="13 介绍一下HTTP协议"></a>13 介绍一下HTTP协议</h2><p>HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP定义了浏览器怎样向万维网服务器请求文档、以及服务器怎样把文档传输给浏览器</p><p>HTTP在运输层使用TCP协议，TCP 为 HTTP 提供可靠的数据传输服务。</p><p>HTTP 是一种无状态的协议，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何区别。一般靠cookie和session来保存状态</p><h2 id="14-HTTP常见的状态码有哪些？"><a href="#14-HTTP常见的状态码有哪些？" class="headerlink" title="14 HTTP常见的状态码有哪些？"></a>14 HTTP常见的状态码有哪些？</h2><p>常见状态码：</p><ul><li>200：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li><li>301 ：(永久移动) 请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li><li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>400 ：客户端请求有语法错误，不能被服务器所理解。</li><li>403 ：服务器收到请求，但是拒绝提供服务。</li><li>404 ：(未找到) 服务器找不到请求的网页。</li><li>500：(服务器内部错误) 服务器遇到错误，无法完成请求。</li></ul><p>状态码开头代表类型：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212135.png" alt="图片"></p><h2 id="15-HTTP-常用的请求方式？"><a href="#15-HTTP-常用的请求方式？" class="headerlink" title="15 HTTP 常用的请求方式？"></a>15 HTTP 常用的请求方式？</h2><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体</td></tr><tr><td align="left">PUT</td><td align="left">上传文件</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件</td></tr><tr><td align="left">HEAD</td><td align="left">和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td align="left">PATCH</td><td align="left">对资源进行部分修改</td></tr><tr><td align="left">OPTIONS</td><td align="left">查询指定的URL支持的方法</td></tr><tr><td align="left">CONNECT</td><td align="left">要求用隧道协议连接代理</td></tr><tr><td align="left">TRACE</td><td align="left">服务器会将通信路径返回给客户端</td></tr></tbody></table><p>为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。</p><ul><li>PUT：上传文件，向服务器添加数据，可以看作增。</li><li>DELETE：删除文件。</li><li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li><li>GET：获取资源，查询服务器资源。</li></ul><h2 id="16-post和get区别"><a href="#16-post和get区别" class="headerlink" title="16 post和get区别"></a>16 post和get区别</h2><ul><li>GET 用于获取资源，而 POST 用于传输实体主体。</li><li>GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。<ul><li>因此GET 只支持 ASCII 码，且参数长度有限制&lt;2kb</li><li>POST 参数支持标准字符集多种编码方式。</li></ul></li><li>GET和POST本质上就是TCP链接，并无差别。</li><li>GET请求会被浏览器主动缓存，GET在浏览器回退/刷新时是无害的，而POST会再次提交请求。</li></ul><h2 id="17-HTTP请求报文和响应报文的格式？"><a href="#17-HTTP请求报文和响应报文的格式？" class="headerlink" title="17 HTTP请求报文和响应报文的格式？"></a>17 HTTP请求报文和响应报文的格式？</h2><p><strong>请求报文格式</strong>：</p><ol><li>请求行（请求方法+URI协议+版本）</li><li><strong>请求头部（具体几个参数还要看一看）</strong></li><li>空行</li><li>请求主体</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET&#x2F;sample.jspHTTP&#x2F;1.1 请求行</span><br><span class="line">Accept:image&#x2F;gif.image&#x2F;jpeg, 浏览器可以接收的内容类型</span><br><span class="line">Accept-Language:zh-cn  浏览器接收的语言</span><br><span class="line">Connection:Keep-Alive 是否开启长连接</span><br><span class="line">Host:localhost  被服务器的域名或IP地址，如果不是通用端口，还包含该端口号</span><br><span class="line">User-Agent:Mozila&#x2F;4.0(compatible;MSIE5.01;Window NT5.0)</span><br><span class="line">Accept-Encoding:gzip,deflate 浏览器可以处理的编码方式</span><br><span class="line">&#x2F;&#x2F;还可以有cookie等...</span><br><span class="line"></span><br><span class="line">username&#x3D;jinqiao&amp;password&#x3D;1234 请求主体</span><br></pre></td></tr></table></figure><p><strong>响应报文</strong>：</p><ol><li>状态行（版本+状态码+原因短语）</li><li>响应首部</li><li>空行</li><li>响应主体</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server:Apache Tomcat&#x2F;5.0.12</span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;HTTP响应示例&lt;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Hello HTTP!</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="18-解释一下HTTP长连接和短连接？"><a href="#18-解释一下HTTP长连接和短连接？" class="headerlink" title="18 解释一下HTTP长连接和短连接？"></a>18 解释一下HTTP长连接和短连接？</h2><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p><strong>在HTTP/1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 <strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><h2 id="19-http和https的区别"><a href="#19-http和https的区别" class="headerlink" title="19 http和https的区别"></a>19 http和https的区别</h2><ul><li>端口 ：HTTP默认使用端口80，而HTTPS使用端口443。</li><li>安全性和资源消耗：HTTP 安全性没有 HTTPS高，但是 HTTP 比HTTPS耗费的服务器资源更少。<ul><li> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</li><li>HTTPS所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。<ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ul></li></ul><h2 id="20-Cookie、Session的区别"><a href="#20-Cookie、Session的区别" class="headerlink" title="20 Cookie、Session的区别"></a>20 Cookie、Session的区别</h2><p><strong>Cookie通过在客户端记录信息确定用户身份</strong></p><p>类似给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。Cookie实际上是一小段的文本信息，储存在浏览器中。服务器还可以根据需要修改Cookie的内容。</p><p><strong>Session通过在服务器端记录信息确定用户身份</strong></p><p>Session相当于程序在服务器上建立的一份客户档案，类似于一份“客户明细表”，客户来访的时候只需要查询客户档案表就可以了。Session会增加一些服务器端的存储压力。</p><p><strong>cookie和session的区别</strong></p><ul><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上.</p></li><li><p>一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</p></li><li><p>session会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie，考虑到安全应当使用session。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p></li></ul><h2 id="21-SQL注入是什么，如何避免SQL注入？"><a href="#21-SQL注入是什么，如何避免SQL注入？" class="headerlink" title="21 SQL注入是什么，如何避免SQL注入？"></a>21 SQL注入是什么，如何避免SQL注入？</h2><p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。</p><p><strong>SQL注入的原理主要有以下 4 点</strong></p><ul><li>恶意拼接查询</li><li>利用注释执行非法命令</li><li>传入非法参数</li><li>添加额外条件</li></ul><p><strong>避免SQL注入的一些方法</strong>：</p><ul><li>限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。</li><li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）转义处理。</li><li>提供参数化查询接口，不要直接使用原生SQL。</li><li>${} #{}都是进行动态传参的标记符，尽量用#{}进行传参<ul><li>${}在动态解析SQL阶段就直接替换为一个字符串</li><li>#{}是先用一个占位符?占位，然后在SQL执行的时候进行变量替换</li><li>#{}可以避免sql注入，能用#{}的应该尽量用#{}。表名参数的传递必须用${}</li></ul></li></ul><h2 id="22-负载均衡算法有哪些？"><a href="#22-负载均衡算法有哪些？" class="headerlink" title="22 负载均衡算法有哪些？"></a>22 负载均衡算法有哪些？</h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p><ul><li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li><li>随机法：随机获取一台，和轮询类似。</li><li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li><li>加权轮询：根据服务器性能不同加权。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络面经，极简共22个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="面经" scheme="https://wukang555.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="计算机网络" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="计算机基础" scheme="https://wukang555.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/07/10/%E6%A1%86%E6%9E%B6_09_RabbitMQ_wukang/"/>
    <id>https://wukang555.github.io/2021/07/10/%E6%A1%86%E6%9E%B6_09_RabbitMQ_wukang/</id>
    <published>2021-07-10T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:39.338Z</updated>
    
    <content type="html"><![CDATA[<p>狂神RabbitMQ教学视频学习笔记，包括消息队列介绍、RabbitMQ安装、RabbitMQ的5中订阅和发布的模式Demo等内容</p><a id="more"></a><blockquote><p>[1] 主体是狂神说系列的RabbitMQ教程<a href="https://www.bilibili.com/video/BV1dX4y1V73G?p=1">https://www.bilibili.com/video/BV1dX4y1V73G?p=1</a></p><p>[2] 参考了cyc2018关于消息中间件的文章<a href="http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">http://www.cyc2018.xyz</a></p><p>[3] 参考了JavaGuide主页的链接文章<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/distributed-system/message-queue/RabbitMQ%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86">https://snailclimb.gitee.io/javaguide/#/</a></p></blockquote><h1 id="1-消息队列和RabbitMQ"><a href="#1-消息队列和RabbitMQ" class="headerlink" title="1 消息队列和RabbitMQ"></a>1 消息队列和RabbitMQ</h1><h2 id="1-1-消息队列介绍"><a href="#1-1-消息队列介绍" class="headerlink" title="1.1 消息队列介绍"></a>1.1 消息队列介绍</h2><p>消息系统允许软件、应用相互连接和扩展．这些应用可以相互链接起来组成一个更大的应用。通俗来讲，<strong>消息队列用来处理分布式应用各个系统之间的通信问题。</strong>（举几个例子？搞项目之后回来再看）</p><p>消息模型一般分两种：点对点 和 发布/订阅</p><ul><li><strong>点对点</strong></li></ul><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211919.png" alt="img"></p><ul><li><strong>发布/订阅</strong></li></ul><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。（发布/订阅和设计模式中的观察者模式不同，是异步的并且通过频道通信）</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211922.png" alt="img"></p><h2 id="1-2-消息队列使用场景【重要】"><a href="#1-2-消息队列使用场景【重要】" class="headerlink" title="1.2 消息队列使用场景【重要】"></a>1.2 消息队列使用场景【重要】</h2><p>消息队列带来的优点就是 异步、削峰和解耦，这三点同样也是它的应用场景</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><blockquote><p>举个🌰，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信和邮件。</p><p>省略中间的网络通信时间消耗，假设购票系统处理需要 150ms ，短信系统处理需要 200ms，邮件系统处理需要 200ms</p></blockquote><ul><li>如果采用同步的处理：需要等待短信、邮件都处理啊完毕后，才表示购票成功<ul><li>所需时间150ms + 200ms + 200ms = 550ms</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211925.jpg" alt="img"></p><ul><li>如果采用异步的处理，在购票系统和短信、邮件系统中增加一个中间件——消息队列。我们将消息存入消息队列之后，就代表购票成功、<ul><li>150ms + 10ms = 160ms。</li></ul></li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211928.jpg" alt="img"></p><h3 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><blockquote><p>还是购票系统的栗子：</p><p>主业务购票系统的流量承受能力较强、但短信和邮件系统一般配备的硬件资源不会太高，无法承受和购票系统一样的流量压力。</p><p>使用消息队列可以将购买完成的信息发送到消息队列中，短信、邮件系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> </p></blockquote><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211931.jpg" alt="img"></p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p><em>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</em></p><h2 id="1-3-RabbitMQ介绍"><a href="#1-3-RabbitMQ介绍" class="headerlink" title="1.3 RabbitMQ介绍"></a>1.3 RabbitMQ介绍</h2><blockquote><p>ActiveMQ、 RabbitMQ、 Kafka、RocketMQ都是不同的消息中间件</p></blockquote><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，用于在分布式系统中存储转发消息。</p><h3 id="RabbitMQ的优点"><a href="#RabbitMQ的优点" class="headerlink" title="RabbitMQ的优点"></a>RabbitMQ的优点</h3><ul><li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由</strong>：消息在到达队列前是通过交换机进行路由的。RabbitMQ为典型的路由逻辑提供了多种内置交换机类型。</li><li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li><li><strong>高可用性：</strong> 在同一个集群里，队列可以被镜像到多个机器中，以确保当其中某些硬件出现故障后，你的消息仍然安全。</li></ul><h3 id="RabbitMQ-的整体架构"><a href="#RabbitMQ-的整体架构" class="headerlink" title="RabbitMQ 的整体架构"></a>RabbitMQ 的整体架构</h3><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211935.jpg" alt="图1-RabbitMQ 的整体模型架构"></p><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。</p><ul><li><p><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</p></li><li><p><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</p></li><li><p><strong>Exchange(交换器)</strong> ：用来接收生产者发送的消息并将这些消息路由给服务器中的队列中。RabbitMQ 有四种交换器类型。</p></li><li><p><strong>Queue(消息队列)</strong> ：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。</p></li><li><p><strong>RabbitMQ Broker</strong> 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。</p></li></ul><h1 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2 RabbitMQ安装"></a>2 RabbitMQ安装</h1><blockquote><p>RabbitMQ官网查看版本支持：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a>  </p><p>erlang 官网：<a href="https://www.erlang.org/">https://www.erlang.org</a>   (不要在这里下载)</p><p>下载rabbitmq-server-3.8.19-1.el7.noarch.rpm：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.19">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.19</a></p><p>下载erlang-solutions-2.0-1.noarch.rpm <a href="https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm">https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm</a></p><p>环境准备：CentOS7.x    安装路径 /usr/rabbitmq</p></blockquote><h2 id="2-1-安装Erlang和RabbitMQ"><a href="#2-1-安装Erlang和RabbitMQ" class="headerlink" title="2.1 安装Erlang和RabbitMQ"></a>2.1 安装Erlang和RabbitMQ</h2><p>Erlang</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/rabbitmq <span class="comment">#再安装路径下创建文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /usr/rabbitmq <span class="comment">#进入安装文件夹</span></span><br><span class="line"><span class="comment">#使用 XFTP将两个安装包拷贝进rabbitmq文件夹下</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># erlang-solutions-2.0-1.noarch.rpm  </span></span><br><span class="line"><span class="comment"># rabbitmq-server-3.8.19-1.el7.noarch.rpm</span></span><br><span class="line">rpm -Uvh erlang-solutions-2.0-1.noarch.rpm </span><br><span class="line">yum install -y erlang</span><br><span class="line">erl -v</span><br></pre></td></tr></table></figure><p>RabbitMQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install -y socat</span><br><span class="line">rpm -Uvh rabbitmq-server-3.8.19-1.el7.noarch.rpm <span class="comment">#没用？</span></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start rabbitmq-server</span><br><span class="line"><span class="comment"># 查看服务状态，如图</span></span><br><span class="line">systemctl status rabbitmq-server.service</span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211941.png" alt="image-20210708005845710" style="zoom:67%;"><h2 id="2-2-RabbitMQWeb管理界面"><a href="#2-2-RabbitMQWeb管理界面" class="headerlink" title="2.2 RabbitMQWeb管理界面"></a>2.2 RabbitMQWeb管理界面</h2><blockquote><p>1 安装web端插件</p><p>2 重启服务，开放阿里云的安全组和防火墙</p><p>3 浏览器访问初始界面</p><p>4 授权新的账号和密码</p><ul><li>新增用户</li><li>设置用户的操作权限</li><li>为用户添加资源权限</li></ul><p>5 网页登录成功</p></blockquote><p>1 默认情况下，是没有安装web端的客户端插件，需要安装才可以生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment"># 说明：rabbitmq有一个默认账号和密码是：`guest`默认情况只能在 localhost本计下访问，所以需要添加一个远程登录的用户</span></span><br></pre></td></tr></table></figure><p>2 安装完毕以后，重启服务即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server #重启服务</span><br></pre></td></tr></table></figure><ul><li>一定要记住，在对应服务器（阿里云）的安全组、防火墙中开放<code>15672</code>端口</li></ul><p>3 在浏览器访问 <a href="http://47.98.220.123:15672/">http://47.98.220.123:15672/</a></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211948.jpg"></p><p>4 <strong>授权账号和密码</strong></p><ul><li>新增用户</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><ul><li>设置用户分配操作权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="comment"># 用户级别：</span></span><br><span class="line"><span class="comment"># administrator：可以登录控制台、查看所有信息、可以对 rabbitmq进行管理</span></span><br><span class="line"><span class="comment"># monitoring：监控者 登录控制台，查看所有信息</span></span><br><span class="line"><span class="comment"># policymaker：策略制定者 登录控制台，指定策略</span></span><br><span class="line"><span class="comment"># managment 普通管理员 登录控制台,只能看自己的信息</span></span><br></pre></td></tr></table></figure><ul><li>为用户添加资源权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin &quot;.*&quot;&quot;.*&quot;&quot;.*&quot;</span><br></pre></td></tr></table></figure><p>5 网页登录成功 设置的账号密码均为admin</p><ul><li>访问 <a href="http://47.xx.xxx.xx:15672/">http://47.XX.XXX.XX:15672/</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211952.png" alt="image-20210708010313311" style="zoom:67%;"><h1 id="3-RabbitMQ五种工作模式"><a href="#3-RabbitMQ五种工作模式" class="headerlink" title="3 RabbitMQ五种工作模式"></a>3 RabbitMQ五种工作模式</h1><p>生产者、消费者是分别两个项目、通过RabbitMQ这个消息中间件的通道进行连接。RabbitMQ的后台页面上显示队列等中间件里面所有的全部信息。</p><p>先搭建项目环境</p><p>1 新建一个空项目rabbitmq</p><p>2 空项目下新建一个springboot项目rabbitmq-provider，勾选Web 和 RabbitMQ支持</p><p>3 配置rabbitmq-provider的配置文件application.yaml</p><p>4 导入依赖lombok\fastjson，编写实体类Vehicle表示车辆</p><p>5 重复234的操作，新建一个rabbitmq-consumer项目</p><p>6 阿里云开启防火墙和安全组的5672和5673端口！！【重要】</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#我这里仅写了ip 其余端口账号密码由于是演示 采用默认即可，不必要写</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">47.98</span><span class="number">.220</span><span class="number">.123</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><h2 id="1、简单队列（Easy"><a href="#1、简单队列（Easy" class="headerlink" title="1、简单队列（Easy)"></a>1、简单队列（Easy)</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211957.png" alt="img"></p><p>　　<strong>一个生产者对应一个消费者！！！</strong></p><blockquote><p>生产者：</p><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><p>2 写EasyProviderServer类，发送JSON格式的信息</p><p>3 测试类中调用Server类中的方法，运行之。查看rabbitMQ后台页面</p></blockquote><p>1 建easy包 下写EasyRabbitConfig配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">easyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_easy_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写EasyProviderServer类，业务实现后发送JSON格式的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sendEasyMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            String s = JSON.toJSONString(<span class="keyword">new</span> Vehicle(i, i + <span class="string">&quot;easy车车&quot;</span>));</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;rabbit_easy_queue&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类中调用Server类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProviderApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EasyProviderServer easyProviderServer;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        easyProviderServer.sendEasyMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212001.png" alt="image-20210708105408993"></p><blockquote><p>消费者：</p><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><p>2 写EasyConsumer类，接受message信息，打印车辆信息</p><p>3 运行项目，消费队列中的信息</p><p>// 如果报错记得去rabbitmq控制页面Admin下设置admin的权限，点一下就好！！</p></blockquote><p>1 建easy包 下写EasyRabbitConfig配置文件，给队列命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">easyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_easy_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写EasyConsumer类，接受message信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_easy_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;easy模式：消费者接收到车辆消息: &quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行项目，发现队列清空了</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212005.png" alt="image-20210708124038722" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212008.png" alt="image-20210708124053092" style="zoom:67%;"><h2 id="2、work-模式"><a href="#2、work-模式" class="headerlink" title="2、work 模式"></a>2、work 模式</h2><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212011.png" alt="img"></p><p>　　<strong>一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息！！！</strong></p><blockquote><p>生产者：和easy的完全一致，这里新建一个work包</p></blockquote><p>1 WorkRabbitConfig配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//work的神生产者和easy一样</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">workQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_work_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写WorkProviderServer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//work模式的生产者和easy的一样</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWorkMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;rabbit_work_queue&quot;</span>, JSON.toJSONString(<span class="keyword">new</span> Vehicle(i,i+<span class="string">&quot;work车车&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类中增加一个workTest()方法，运行之</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WorkProviderServer workProviderServer;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    workProviderServer.sendWorkMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212015.png" alt="image-20210708130550835"></p><blockquote><p>消费者：与easy中也很相似，就是WorkConsumer类下多写几个消费方法！！很简单</p></blockquote><p>1 写WorkRabbitConfig配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">workQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_work_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写WorkConsumer类，下面含三个方法即三个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work1</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者2--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_work_queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work3</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者3--work--接收到车辆消息: &quot;</span> + JSON.parseObject(message.getBody(),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行项目，发现队列清空了</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212020.png" alt="image-20210708130948085" style="zoom:67%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212023.png" alt="image-20210708131013920" style="zoom:67%;"><h2 id="3、发布-订阅模式（Fanout）"><a href="#3、发布-订阅模式（Fanout）" class="headerlink" title="3、发布/订阅模式（Fanout）"></a>3、发布/订阅模式（Fanout）</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212026.png" alt="img"></p><p><strong>一个消费者将消息首先发送到交换器，交换器绑定到多个队列，然后被监听该队列的消费者所接收并消费。</strong></p><p>ps:X表示交换器，在RabbitMQ中，交换器主要有四种类型:direct、fanout、topic、headers，这里的交换器是 fanout。</p><p>这里演示一个交换机绑定两个队列，每个队列分别被两个消费者监听的情况！！</p><blockquote><p>生产者：与work模式的不同在于FanoutExchangeConfig 中需要定义交换机并将队列与交换机绑定。这里新建一个fanout包</p></blockquote><p>1 FanoutConfig配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 发布订阅模式 配置两个队列一个交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列一</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">FanoutQueueOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_fanout_queue_one&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列二</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">FanoutQueueTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;rabbit_fanout_queue_two&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机 声明为FanoutExchange类型</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;fanout_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列一到交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> FanoutQueueOne 上方定义的队列一方法名  根据此方法名参数 器会自动注入对应bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fanoutExchange 上方定义的交换机方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutExchangeA</span><span class="params">(Queue FanoutQueueOne, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(FanoutQueueOne).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列二到交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> FanoutQueueTwo  上方定义的队列二方法名  根据此方法名参数 器会自动注入对应bean   当</span></span><br><span class="line"><span class="comment">     *                        然也可以省略参数 直接在bind中指定队列构建方法名 例如 FanoutQueueTwo()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fanoutExchange 上方定义的交换机方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingFanoutExchangeB</span><span class="params">(Queue FanoutQueueTwo, FanoutExchange  fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(FanoutQueueTwo).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 FanoutProviderServer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProviderServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFanoutMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;fanout_exchange&quot;</span>,<span class="string">&quot;&quot;</span>, JSON.toJSONString(<span class="keyword">new</span> Vehicle(i,i+<span class="string">&quot;发布订阅车车&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">FanoutProviderServer fanoutProviderServer;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fanoutTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fanoutProviderServer.sendFanoutMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>消费者：与work的不同在于出现了队列！！每个队列有属于自己的消费者</p></blockquote><p>1 FanoutConfig与生产者相同</p><p>2 FanoutConsumer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerOne</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_one队列 消费者1：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerOne2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_one队列 消费者2：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------一个队列绑定两个消费者 --------------------------------</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTwo</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_two队列 消费者1：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;rabbit_fanout_queue_two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerTwo2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rabbit_fanout_queue_two队列 消费者2：收到消息---&quot;</span> + JSON.parseObject(<span class="keyword">new</span> String(message.getBody()),Vehicle.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 运行</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212031" alt="image-20200715222028261" style="zoom:80%;"><p>？交换机中有10辆车，结果是：每个队列中都有10辆车、然后每个消费者只收到5个订阅？（有点不太符合常理、队列的里面也应该只有5辆车才对啊）</p><h2 id="4、路由模式-Direct"><a href="#4、路由模式-Direct" class="headerlink" title="4、路由模式(Direct)"></a>4、路由模式(Direct)</h2><p>　　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212034.png" alt="img"></p><p>生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。</p><p><strong>也就是让消费者有选择性的接收消息。</strong></p><blockquote><p>生产者：</p></blockquote><blockquote><p>消费者：</p></blockquote><h2 id="5、主题模式-Topic"><a href="#5、主题模式-Topic" class="headerlink" title="5、主题模式(Topic)"></a>5、主题模式(Topic)</h2><p>　<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112212039.png" alt="img"></p><p>上面的路由模式是根据路由key进行完整的匹配（完全相等才发送消息），这里的通配符模式通俗的来讲就是模糊匹配。</p><p><strong>符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。</strong></p><blockquote><p>生产者：</p></blockquote><blockquote><p>消费者：</p></blockquote><h1 id="4-RabbitMQ进阶"><a href="#4-RabbitMQ进阶" class="headerlink" title="4 RabbitMQ进阶"></a>4 RabbitMQ进阶</h1><p>（下次一定，目前学会整合RabbitMQ就行07/08）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神RabbitMQ教学视频学习笔记，包括消息队列介绍、RabbitMQ安装、RabbitMQ的5中订阅和发布的模式Demo等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RabbitMQ" scheme="https://wukang555.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Linux_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/07/05/%E6%A1%86%E6%9E%B6_08_Linux_wukang/"/>
    <id>https://wukang555.github.io/2021/07/05/%E6%A1%86%E6%9E%B6_08_Linux_wukang/</id>
    <published>2021-07-05T14:55:00.000Z</published>
    <updated>2022-05-17T12:15:15.737Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Linux教学视频学习笔记，包括购买服务器、Linux简介、Linux文件、Vim编辑器、磁盘管理、环境安装等内容</p><a id="more"></a><h1 id="0-前置环境部署"><a href="#0-前置环境部署" class="headerlink" title="0 前置环境部署"></a>0 前置环境部署</h1><blockquote><p>购买服务器及环境部署</p><p>1 阿里云购买服务器</p><p>2 安装宝塔部署开发环境</p></blockquote><h2 id="0-1-阿里云购买及部署"><a href="#0-1-阿里云购买及部署" class="headerlink" title="0.1 阿里云购买及部署"></a>0.1 阿里云购买及部署</h2><blockquote><p>阿里云购买连接 <a href="https://developer.aliyun.com/plan/grow-up">https://developer.aliyun.com/plan/grow-up</a></p><p>1 购买阿里云</p><p>2 进入阿里云控制台、创建安全组</p><p>3 然后在控制台、点击<strong>轻量应用服务器</strong>进入你的服务器列表、修改密码并重启、概述里可以看到ip地址、也可以设置密码  <a href="https://swas.console.aliyun.com/">https://swas.console.aliyun.com/</a></p><p>4 下载Xshell的SSH工具、远程连接服务器  <a href="https://www.netsarang.com/zh/xshell/">https://www.netsarang.com/zh/xshell/</a></p></blockquote><p>1 购买阿里云</p><ul><li>我选的轻量应用服务器2核2G，新人99/年。购买时选择系统镜像、CentOS7.6即可。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211709.png" alt="image-20210705083032303" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211714.png" alt="image-20210705083300326" style="zoom: 50%;"><p>2 进入阿里云控制台、创建安全组</p><ul><li>点击云服务器ECS、侧边栏的网络与安全-安全组、创建安全组（默认就行）</li><li>如果购买的是轻量应用服务器这里是没有ECS服务器的、在这里创建安全组就可以了</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211717.png" alt="image-20210705084425389" style="zoom: 33%;"><p>3 进入<strong>轻量应用服务器</strong>列表、修改密码并重启、概述里可以看到ip地址、也可以设置密码</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211719.png" alt="image-20210705084659511" style="zoom:50%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211721.png" alt="image-20210705084831033" style="zoom: 33%;"><p>4 下载Xshell的SSH工具、远程连接服务器  </p><ul><li>无脑下载安装就完事，注意Xshell和XFTP都要安装</li><li>连接时新建会话、填入主机名（就是Ip地址），账号密码等等，就可以连接成功</li><li>连接教程：<a href="https://jingyan.baidu.com/article/f3e34a12f45306f5ea653542.html">https://jingyan.baidu.com/article/f3e34a12f45306f5ea653542.html</a></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211725.png" alt="image-20210705085231311" style="zoom:50%;"><h2 id="0-2-安装宝塔部署开发环境"><a href="#0-2-安装宝塔部署开发环境" class="headerlink" title="0.2 安装宝塔部署开发环境"></a>0.2 安装宝塔部署开发环境</h2><blockquote><p>1 安装宝塔 官方有详细教程 <a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>​    唯一要注意的就是开端口，安全组和防火墙两处都需要开启8888端口</p><p>2 进入宝塔管理面板一键部署应用</p></blockquote><p>1 安装宝塔 得到url 、username、password</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211728.png" alt="img" style="zoom: 50%;"><p>2 宝塔管理面板的软件商店一键部署应用</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211731.png" alt="image-20210705090046831" style="zoom: 33%;"><h1 id="1-Linux简介"><a href="#1-Linux简介" class="headerlink" title="1 Linux简介"></a>1 Linux简介</h1><p><strong>Linux简介</strong></p><p>​        Linux是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX (可移植操作系统接口)和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。<br>​        Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux 继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p><strong>Linux发行版</strong></p><p>发行版就是将Linux内核与应用软件做一个打包<br><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211734.png" alt="在这里插入图片描述"></p><p>​        今天各种场合都有使用各种Linux发行版,从嵌入式设备到超级计算机,并且在服务器领域确定了地位,通常服务器使用LAMP(Linux + Apache + MySQL + PHP)或LNMP(Linux + Nginx + MySQL + PHP)组合。目前Linux不仅在家庭与企业中使用,并且在政府中也很受欢迎。</p><h1 id="2-Linux常用命令"><a href="#2-Linux常用命令" class="headerlink" title="2 Linux常用命令"></a>2 Linux常用命令</h1><h2 id="2-1-系统目录"><a href="#2-1-系统目录" class="headerlink" title="2.1 系统目录"></a>2.1 系统目录</h2><p>1、Linux系统 一切皆文件<br>2、根目录/ ,所有的文件都挂载在这个节点下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="comment">#查看当前下的目录、可能时最常用的命令</span></span><br><span class="line">ls -a <span class="comment">#查看当前目录下的所有目录，包括隐藏</span></span><br><span class="line">ls -l <span class="comment">#列出当前下目录的包含文件的属性与权限等等数据；(常用)</span></span><br><span class="line">ls -al <span class="comment">#列出当前下目录的包含文件的属性与权限等等数据,包括隐藏</span></span><br><span class="line">ls / <span class="comment">#查看根目录/下的目录</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211741.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</span><br><span class="line">&#x2F;boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">&#x2F;dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</span><br><span class="line">&#x2F;etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</span><br><span class="line">&#x2F;home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</span><br><span class="line">&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</span><br><span class="line">&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">&#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</span><br><span class="line">&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</span><br><span class="line">&#x2F;opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</span><br><span class="line">&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</span><br><span class="line">&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</span><br><span class="line">&#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</span><br><span class="line">&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。</span><br><span class="line">&#x2F;sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</span><br><span class="line">&#x2F;tmp：这个目录是用来存放一些临时文件的。 用完即丢的文件可以放在这个目录下</span><br><span class="line">&#x2F;usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</span><br><span class="line">&#x2F;usr&#x2F;bin： 系统用户使用的应用程序。</span><br><span class="line">&#x2F;usr&#x2F;sbin： 超级用户使用的比较高级的管理程序和系统守护程序。</span><br><span class="line">&#x2F;usr&#x2F;src： 内核源代码默认的放置目录。</span><br><span class="line">&#x2F;var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</span><br><span class="line">&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</span><br><span class="line">&#x2F;www：存放服务器网站相关的资源，环境，网站的项目</span><br></pre></td></tr></table></figure><h2 id="2-2-目录管理【重要】"><a href="#2-2-目录管理【重要】" class="headerlink" title="2.2 目录管理【重要】"></a>2.2 目录管理【重要】</h2><p>切换目录cd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">cd</span> [绝对路径] <span class="comment">#切换至该绝对路径下</span></span><br><span class="line"><span class="built_in">cd</span> /  <span class="comment">#表示切换到根目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..  <span class="comment">#表示返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment"># 表示回到/root目录下（特殊）</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示目前所在的目录</span></span><br><span class="line"><span class="built_in">pwd</span> -P <span class="comment"># 如果是链接，要显示真实地址</span></span><br></pre></td></tr></table></figure><p>创建目录 mkdir</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p test2/test3/test4 <span class="comment"># 用-p递归创建层级目录</span></span><br></pre></td></tr></table></figure><p>删除空的目录 rmdir</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p test2/test3/test4 <span class="comment">#递归删除文件</span></span><br></pre></td></tr></table></figure><p>复制文件或者目录 cp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/install.sh /home <span class="comment">#将install.sh 复制到home文件夹中</span></span><br></pre></td></tr></table></figure><p>移除文件或者目录 rm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f <span class="comment">#忽略不存在的文件,不会出现警告,强制删除!</span></span><br><span class="line">-r <span class="comment">#递归删除目录! 这是非常危险的选项！！！</span></span><br><span class="line">-i <span class="comment">#互动,删除询问是否删除</span></span><br><span class="line">rm -rf install.sh  <span class="comment">#删除系统中的install.sh</span></span><br></pre></td></tr></table></figure><p>移动文件或者目录|重命名文件 mv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f <span class="comment">#强制</span></span><br><span class="line">-u <span class="comment">#只替换已经更新过的文件</span></span><br><span class="line">mv install.sh cqhstudy <span class="comment">#移动文件</span></span><br><span class="line">mv cqhstudy cqhstudy2 <span class="comment">#重命名文件夹名</span></span><br></pre></td></tr></table></figure><h2 id="2-3-基本属性"><a href="#2-3-基本属性" class="headerlink" title="2.3 基本属性"></a>2.3 基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><h3 id="1-基本属性查看"><a href="#1-基本属性查看" class="headerlink" title="1 基本属性查看"></a>1 基本属性查看</h3><p>下面以/home目录下的几个文件或目录的基本属性作为介绍：<code>ls -l</code>查看文件属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp14cwp14hjrpbcb149wZ /]<span class="comment"># cd /home</span></span><br><span class="line">[root@iZbp14cwp14hjrpbcb149wZ home]<span class="comment"># ls -l</span></span><br><span class="line">total 1668</span><br><span class="line">-rw-r--r-- 1 root  root  1694239 Jul  5 09:19 36、Linux使用.pdf</span><br><span class="line">drwx------ 3 admin admin    4096 Jul  4 20:33 admin</span><br><span class="line">drwx------ 2 redis redis    4096 Jul  4 22:00 redis</span><br><span class="line">drwx------ 3 www   www      4096 Jul  4 22:00 www</span><br><span class="line">[root@iZbp14cwp14hjrpbcb149wZ home]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>以<code>36、Linux使用.pdf</code>这个pdf文件为例，属性分为几个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  前十个字符：表示类型和读写权限</span><br><span class="line">1  表示hard links的个数</span><br><span class="line">root  root  表述属主和属组都是root</span><br><span class="line">1694239 表示文件的大小？（对的）</span><br><span class="line">Jul  5 09:19 36、Linux使用.pdf 表示时间和文件名</span><br></pre></td></tr></table></figure><p>每个文件的属性由左边第一部分的10个字符来确定 (如下图) :</p><ul><li>第一位表示文件类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当为[d]则是目录</span><br><span class="line">当为[-]则是文件;</span><br><span class="line">若是[l]则表示为链接文档( link file);</span><br><span class="line">若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ;</span><br><span class="line">若是[c]则表示为装置文件里面的串行端口设备,例如键盘、鼠标( 一次性读取装置)。</span><br></pre></td></tr></table></figure><ul><li>后9位表示 权限，如下所示</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211747.png" alt="在这里插入图片描述" style="zoom: 25%;"><h3 id="2-修改文件的属性"><a href="#2-修改文件的属性" class="headerlink" title="2 修改文件的属性"></a>2 修改文件的属性</h3><p>1 chgrp :更改文件属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 属组名文件名</span><br><span class="line"><span class="comment"># -R :递归更改文件属组,就是在更改某个目录文件的属组时,如果加上R的参数,那么该目录下的所有文件的属组都会更改。</span></span><br></pre></td></tr></table></figure><p>2、chown :更改文件属主,也可以同时更改文件属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [-R] 属主名文件名</span><br><span class="line">chown [-R] 属主名:属组名文件名</span><br></pre></td></tr></table></figure><p>3、chmod :更改文件9个属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure><h2 id="2-4-文件内容查看"><a href="#2-4-文件内容查看" class="headerlink" title="2.4 文件内容查看"></a>2.4 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="comment">#由第一行开始显示文件内容</span></span><br><span class="line">tac <span class="comment">#从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</span></span><br><span class="line">nl <span class="comment">#显示的时候，顺道输出行号！</span></span><br><span class="line">more <span class="comment">#一页一页的显示文件内容</span></span><br><span class="line">less <span class="comment">#与 more 类似，但是比 more 更好的是，他可以往前翻页！</span></span><br><span class="line">head <span class="comment">#只看头几行</span></span><br><span class="line">tail <span class="comment">#只看尾巴几行</span></span><br></pre></td></tr></table></figure><p>1 cat 由第一行开始显示文件内容  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [-AbEnTv] 文件名</span><br><span class="line">-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</span><br><span class="line">-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</span><br><span class="line">-E ：将结尾的断行字节 $ 显示出来；</span><br><span class="line">-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</span><br><span class="line">-T ：将 [tab] 按键以 ^I 显示出来；</span><br><span class="line">-v ：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure><p>2 nl 显示的时候，顺道输出行号！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br><span class="line">-b ：指定行号指定的方式，主要有两种：</span><br><span class="line">-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</span><br><span class="line">-b t ：如果有空行，空的那一行不要列出行号(默认值)；</span><br><span class="line">-n ：列出行号表示的方法，主要有三种：</span><br><span class="line">-n ln ：行号在荧幕的最左方显示；</span><br><span class="line">-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</span><br><span class="line">-n rz ：行号在自己栏位的最右方显示，且加 0 ；</span><br><span class="line">-w ：行号栏位的占用的位数。</span><br></pre></td></tr></table></figure><p>3 more #一页一页的显示文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">move 文件</span><br><span class="line">more 这个程序的运行过程中，你有几个按键可以按的</span><br><span class="line">空白键 (space)：代表向下翻一页；</span><br><span class="line">    Enter ：代表向下翻『一行』；</span><br><span class="line">    /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</span><br><span class="line">    :f ：立刻显示出档名以及目前显示的行数；</span><br><span class="line">    q ：代表立刻离开 more ，不再显示该文件内容。</span><br><span class="line">    b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用</span><br></pre></td></tr></table></figure><p><strong>硬链接和软链接：</strong></p><ul><li>硬链接：A—B,假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种机制硬链接到一个重要文件上，防止误删</li><li>软链接：类似Windows下的快捷方式，删除源文件，快捷方式也就访问不了</li></ul><blockquote><p>操作步骤：<br>1 创建链接 ln命令！<code>ln</code>  <code>ln -s</code><br>2 touch命令创建文件！<br>3 echo输入字符串<br>4 删除f1之后，查看f2和f3的区别</p></blockquote><p>123步骤如下：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211831.png" alt="在这里插入图片描述"></p><p>4 删除f1之后，查看f2和f3的区别：</p><ul><li>f2 硬链接还在   f3软连接失效</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211834.png" alt="在这里插入图片描述"></p><h2 id="2-5-Vim编辑器【重要】"><a href="#2-5-Vim编辑器【重要】" class="headerlink" title="2.5 Vim编辑器【重要】"></a>2.5 Vim编辑器【重要】</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器。vim 是vi的升级，具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h3 id="1-三种输入模式"><a href="#1-三种输入模式" class="headerlink" title="1 三种输入模式"></a>1 三种输入模式</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是</p><ul><li>命令模式：敲击键盘动作会被Vim识别为命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i 切换到输入模式，以输入字符。</span><br><span class="line">x 删除当前光标所在处的字符。</span><br><span class="line">: 切换到底线命令模式，以在最底一行输入命令。</span><br></pre></td></tr></table></figure><ul><li>输入模式：编辑文本、输入多行字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字符按键以及Shift组合，输入字符</span><br><span class="line">ENTER，回车键，换行</span><br><span class="line">BACK SPACE，退格键，删除光标前一个字符</span><br><span class="line">DEL，删除键，删除光标后一个字符</span><br><span class="line">方向键，在文本中移动光标</span><br><span class="line">HOME&#x2F;END，移动光标到行首&#x2F;行尾</span><br><span class="line">Page Up&#x2F;Page Down，上&#x2F;下翻页</span><br><span class="line">Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</span><br><span class="line">ESC，退出输入模式，切换到命令模式</span><br></pre></td></tr></table></figure><ul><li>底线命令模式 : 可以输入单个或多个字符的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q 退出程序</span><br><span class="line">w 保存文件</span><br><span class="line">&#x2F;&#x2F;一般就wq组合使用</span><br></pre></td></tr></table></figure><h3 id="2-vim新建txt文件示例"><a href="#2-vim新建txt文件示例" class="headerlink" title="2 vim新建txt文件示例"></a>2 vim新建txt文件示例</h3><blockquote><p>1 进入目标目录，执行 vim 文件名</p><p>2 按下 i 进入输入模式，编写文本内容</p><p>3 按下 ESC 按钮回到一般模式，执行wq保存并退出</p></blockquote><p>1 使用 vim 来建立一个名为 runoob.txt 的文件时，输入：</p><ul><li>直接输入 <strong>vim 文件名</strong> 就能够进入 vi 的一般模式了。文件不存在则新建、存在则修改。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim runoob.txt</span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211753.jpg" alt="img" style="zoom:33%;"><p>2 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</p><ul><li>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211756.jpg" alt="img" style="zoom:33%;"><p>3 按下 ESC 按钮回到一般模式，执行wq保存并退出</p><ul><li><p>按下 <strong>Esc</strong> 这个按钮，会发现画面左下角的 – INSERT – 不见了！，表示进入了一般模式</p></li><li><p>存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p></li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211758.jpg" alt="img" style="zoom:33%;"><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><h2 id="2-6-用户和用户组管理"><a href="#2-6-用户和用户组管理" class="headerlink" title="2.6 用户和用户组管理"></a>2.6 用户和用户组管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><blockquote><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul></blockquote><h3 id="1-Linux系统用户账号的管理"><a href="#1-Linux系统用户账号的管理" class="headerlink" title="1 Linux系统用户账号的管理"></a>1 Linux系统用户账号的管理</h3><p><strong>用户账号的管理</strong>：添加、修改和删除。</p><p>添加账号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br></pre></td></tr></table></figure><p>删除账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 选项 用户名</span><br></pre></td></tr></table></figure><p>修改帐号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure><p><strong>用户口令的管理：</strong></p><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><ul><li>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 选项 用户名</span><br></pre></td></tr></table></figure><h3 id="2-Linux系统用户组的管理"><a href="#2-Linux系统用户组的管理" class="headerlink" title="2 Linux系统用户组的管理"></a>2 Linux系统用户组的管理</h3><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p>增加一个新的用户组使用groupadd命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br></pre></td></tr></table></figure><p>删除一个已有的用户组，使用groupdel命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 用户组</span><br></pre></td></tr></table></figure><p>修改用户组的属性使用groupmod命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br></pre></td></tr></table></figure><p>用户可以在用户组之间切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ newgrp root</span><br><span class="line"><span class="comment"># 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</span></span><br></pre></td></tr></table></figure><h2 id="2-7-磁盘管理"><a href="#2-7-磁盘管理" class="headerlink" title="2.7 磁盘管理"></a>2.7 磁盘管理</h2><blockquote><p>占个坑，以后来补，下次一定。</p></blockquote><h3 id="1-磁盘管理"><a href="#1-磁盘管理" class="headerlink" title="1 磁盘管理"></a>1 磁盘管理</h3><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><blockquote><p>Linux磁盘管理常用三个命令为df、du和fdisk。</p><ul><li>df：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li><li>fdisk：用于磁盘分区</li></ul></blockquote><h3 id="2-磁盘格式化"><a href="#2-磁盘格式化" class="headerlink" title="2 磁盘格式化"></a>2 磁盘格式化</h3><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 <code>mkfs</code>（make filesystem） 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs [-t 文件系统格式] 装置文件名</span><br></pre></td></tr></table></figure><h3 id="3-磁盘检验"><a href="#3-磁盘检验" class="headerlink" title="3 磁盘检验"></a>3 磁盘检验</h3><p>fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><h3 id="4-磁盘挂载与卸除"><a href="#4-磁盘挂载与卸除" class="headerlink" title="4 磁盘挂载与卸除"></a>4 磁盘挂载与卸除</h3><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><h2 id="2-8-进程管理"><a href="#2-8-进程管理" class="headerlink" title="2.8 进程管理"></a>2.8 进程管理</h2><p>在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。  每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。  </p><p>每个进程都可能以两种方式存在的。前台与后台 。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。  </p><p>ps 查看当前系统中正在执行的各种进程的信息！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps- xx：</span><br><span class="line">  -a 显示当前终端所有的进程信息</span><br><span class="line">  -u 以用户的信息显示进程</span><br><span class="line">  -x 显示后台运行进程的参数</span><br><span class="line"><span class="comment">#ps -aux  查看所有进程</span></span><br><span class="line">ps-aux|grep mysql  查看mysql相关进程</span><br><span class="line"><span class="comment">#命令格式：命令A|命令B，即命令A的正确输出作为命令B的操作对象（输入）</span></span><br><span class="line"><span class="comment"># grep 查找文件中符合条件的字符串</span></span><br></pre></td></tr></table></figure><p>kill 结束进程：杀掉进程 等价于Windows结束任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br><span class="line"><span class="comment"># 常用选项： -9 :表示强迫进程立即停止</span></span><br></pre></td></tr></table></figure><h1 id="3-环境安装"><a href="#3-环境安装" class="headerlink" title="3 环境安装"></a>3 环境安装</h1><blockquote><p>下载jdk\tomcat\docker，直接宝塔。。环境应该不用自己配吧？答：不用，真香。</p></blockquote><h2 id="3-1-安装Redis"><a href="#3-1-安装Redis" class="headerlink" title="3.1 安装Redis"></a>3.1 安装Redis</h2><p>Redis宝塔安装的6.X版本有问题，我这里卸载了手动安装一遍！！安装路径为 /www/server/redis</p><p>1 官网下载tar.gz文件，XFTP传到root文件夹下</p><p>2 解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf redis-5.0.8.tar.gz</span><br></pre></td></tr></table></figure><p>3 移动redis目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /root/redis-5.0.8 /www/server/redis</span><br></pre></td></tr></table></figure><p>4 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>5 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/www/server/redis install</span><br></pre></td></tr></table></figure><p>6 后台启动Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line"><span class="comment"># 按ctrl+z退出</span></span><br></pre></td></tr></table></figure><p>7 修改配置文件redis.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将<span class="built_in">bind</span>注释</span><br><span class="line">将protected-mode设置为no</span><br><span class="line">daemonize改为yes</span><br></pre></td></tr></table></figure><p>8  运行redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis   <span class="comment">#进入redis目录</span></span><br><span class="line">./bin/redis-server ./redis.conf <span class="comment">#开启服务</span></span><br><span class="line">src/./redis-cli <span class="comment">#建立连接</span></span><br></pre></td></tr></table></figure><p>9 查看连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep redis <span class="comment">#查看redis相关的进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程号  <span class="comment">#强制关闭某进程</span></span><br></pre></td></tr></table></figure><p>10 关闭连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>11 使命令全局可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /www/server/redis/src/redis-server /usr/<span class="built_in">local</span>/bin/redis-server</span><br><span class="line">sudo cp /www/server/redis/src/redis-cli /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><p>12 新的建立连接命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli <span class="comment">#直接运行 舒服了</span></span><br></pre></td></tr></table></figure><h2 id="3-2-LInux运行jar包，跑起来"><a href="#3-2-LInux运行jar包，跑起来" class="headerlink" title="3.2 LInux运行jar包，跑起来"></a>3.2 LInux运行jar包，跑起来</h2><p>然后我们打包一个不需要连接数据库的项目springboot-03-web02，看看能不能直接在服务器上跑起来。</p><blockquote><p>1 保证能运行起来，然后clear、package</p><p>2 target下找到jar包，在Windows本地资源目录下cmd命令窗口运行之</p><p>​    java -jar 文件名  #确保能够在本地跑起来</p><p>3 用XFTP将该jar包丢入服务器某个文件夹下</p><p>4 查看防火墙开启了哪些端口，如果要用的端口没开请启用之。</p><p>5 查看进程占用了哪些端口、如果被占用了、请kill该进程</p><p>6 定位目标文件夹 java -jar运行之，公网ip即可访问该网站</p></blockquote><p>123过于傻瓜操作、我不屑之。</p><p>4 查看防火墙开启了哪些端口，如果要用的端口没开请启用之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-portsv <span class="comment">#查看已开启的端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=9000/tcp --permanent  <span class="comment">#开启某个端口、这里以9000为例</span></span><br><span class="line">systemctl restart firewalld.service <span class="comment">#重启防火墙命令 发现有9000了（如果是阿里云还要设置安全组）</span></span><br></pre></td></tr></table></figure><p>5 查看进程占用了哪些端口、如果被占用了、请kill该进程</p><ul><li>我操作时项目发布是默认8080端口，但被占用了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp|grep 80  <span class="comment">#查看80相关的端口、被占用的情况，找到进程id</span></span><br><span class="line"><span class="built_in">kill</span> -9 4770  <span class="comment">#例如，如果是4770进程占用，就关闭之。</span></span><br><span class="line">netstat -lnp|grep 80 <span class="comment">#关闭之后记得再次查看端口占用情况，如果还占用、继续kill</span></span><br></pre></td></tr></table></figure><p>6 定位目标文件夹 java -jar运行之，公网ip即可访问该网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/wukang</span><br><span class="line">java -jar springboot-03-web02.jar</span><br><span class="line"><span class="comment"># 然后就跑起来了...嘿嘿嘿嘿嘿</span></span><br></pre></td></tr></table></figure><p>登录之、一切正常：</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211808.png" alt="image-20210705201741583" style="zoom: 33%;"><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211811.png" alt="image-20210705201903075" style="zoom: 33%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Linux教学视频学习笔记，包括购买服务器、Linux简介、Linux文件、Vim编辑器、磁盘管理、环境安装等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Linux" scheme="https://wukang555.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis_笔记（狂神）</title>
    <link href="https://wukang555.github.io/2021/06/30/%E6%A1%86%E6%9E%B6_07_Redis_wukang/"/>
    <id>https://wukang555.github.io/2021/06/30/%E6%A1%86%E6%9E%B6_07_Redis_wukang/</id>
    <published>2021-06-30T14:55:00.000Z</published>
    <updated>2022-05-17T12:14:34.367Z</updated>
    
    <content type="html"><![CDATA[<p>狂神Redis教学视频学习笔记，包括NoSQL介绍、Redies数据类型、Redis事务、整合SpringBoot、Redis持久化、Redis主从复制等内容</p><a id="more"></a><blockquote><p>[1] 主要框架及内容都是狂神Redis的课堂笔记 <a href="https://www.kuangstudy.com/">https://www.kuangstudy.com/</a></p><p>[2] 参考了javaguide的文章 <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all?id=_1-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-redis-%e5%91%97">redis</a></p></blockquote><h1 id="1-NoSQL概述"><a href="#1-NoSQL概述" class="headerlink" title="1 NoSQL概述"></a>1 NoSQL概述</h1><h2 id="1-1-数据库架构的演变"><a href="#1-1-数据库架构的演变" class="headerlink" title="1.1 数据库架构的演变"></a>1.1 数据库架构的演变</h2><blockquote><p>数据库架构演进：</p><p>1 单机MySQL的美好年代  </p><p>2 Memcached（缓存）+ MySQL + 垂直拆分（多个完整的数据库）</p><p>3 MySQL主从读写分离 （读写分离、主从复制）</p><p>4 分表分库 + 水平拆分 + Mysql 集群  </p><p>5 现在的架构</p></blockquote><p><strong>1 单机MySQL的美好年代</strong>  </p><ul><li>在90年代，一个网站的访问量一般不大，用单个数据库完全可以轻松应付！  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211332.png" alt="image-20210704162507809" style="zoom: 67%;"><p><strong>2 Memcached（缓存）+ MySQL + 垂直拆分（多个完整的数据库）</strong></p><ul><li>Memcached缓解数据库的读取压力  </li><li>垂直拆分：多个完整的数据库供读写，缓解压力</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211334.png" alt="image-20210704162715236" style="zoom:67%;"><p><strong>3 MySQL主从读写分离 （读写分离、主从复制）</strong></p><ul><li>读写分离：使的大量的数据库用于读，部分用于写</li><li>主从复制：写数据库修改后、立马更新到读数据库，提高了读写性能和读库的可扩展性  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211339.png" alt="image-20210704162949719" style="zoom:67%;"><p><strong>4 分表分库 + 水平拆分 + Mysql 集群</strong>  </p><ul><li>MySQL主库的写压力开始出现瓶颈，开始流行使用分表分库来缓解写压力和数据增长的扩展问题  【重要】</li><li>MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的需求，只是在高可靠性上提供了非常大的保证。  </li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211342.png" alt="image-20210704163213199" style="zoom:67%;"><p><strong>5 现在的架构</strong></p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211346.png" alt="image-20210704163340611" style="zoom: 67%;"><p><strong>目前的困境：</strong></p><p>MySQL关系数据库很强大，但是它并不能很好的应付所有的应用场景，MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。  </p><p>比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变的非常的小 。这时就需要用非关系型数据库NoSQL</p><h2 id="1-2-什么是NoSQL"><a href="#1-2-什么是NoSQL" class="headerlink" title="1.2 什么是NoSQL"></a>1.2 什么是NoSQL</h2><h3 id="1-NoSQL-概述"><a href="#1-NoSQL-概述" class="headerlink" title="1 NoSQL  概述"></a>1 NoSQL  概述</h3><p><strong>NoSQL = Not Only SQL 不仅仅是SQL，泛指非关系型的数据库 。</strong></p><p><strong>Nosql特点</strong></p><p>1 方便扩展（数据之间没有关系，很好扩展！）</p><p>2 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p><p>3 数据类型是多样型的！（不需要事先设计数据库，随取随用）</p><p><strong>大数据时代的3V和3高b</strong></p><p>大数据时代的3V ：指描述问题的<strong>海量Velume、多样Variety、实时Velocity</strong></p><p>大数据时代的3高 ： 指对程序的要求：<strong>高并发、高扩展性、高性能</strong></p><h3 id="2-Nosql的四大分类"><a href="#2-Nosql的四大分类" class="headerlink" title="2 Nosql的四大分类"></a>2 Nosql的四大分类</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>键值对（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, <strong>Redis</strong>, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td>Key 指向 Value 的键值对，用hash table实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td></tr></tbody></table><h3 id="3-关系型数据库和非关系型数据库的区别【理解背】"><a href="#3-关系型数据库和非关系型数据库的区别【理解背】" class="headerlink" title="3 关系型数据库和非关系型数据库的区别【理解背】"></a>3 关系型数据库和非关系型数据库的区别【理解背】</h3><ul><li>关系型数据库：<ul><li>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</li><li>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</li><li>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</li></ul></li><li>非关系型数据库 not only SQL<ul><li>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</li><li>面向高性能并发读写的key-value数据库</li><li>面向可扩展性的分布式数据库</li></ul></li><li>数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库</li></ul><h1 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2 Redis入门"></a>2 Redis入门</h1><blockquote><p>Redis：REmote DIctionary Server（远程字典服务器）  </p><p><a href="https://redis.io/">https://redis.io/</a> 官网  </p><p><a href="http://www.redis.cn/">http://www.redis.cn</a> 中文网  </p></blockquote><h2 id="2-1-Redis概述"><a href="#2-1-Redis概述" class="headerlink" title="2.1 Redis概述"></a>2.1 Redis概述</h2><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库（可以称之为内存中的数据库），可以存储键和五种不同类型的值之间的映射。</p><p>Redis 支持很多特性，<strong>例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</strong>具体的功能有：将内存异步写入硬盘、发布订阅系统消息、地图信息分析、定时器计数器等</p><h2 id="2-2-启动Redis"><a href="#2-2-启动Redis" class="headerlink" title="2.2 启动Redis"></a>2.2 启动Redis</h2><blockquote><p>宝塔安装有问题，我是后来自己安装，见Linux笔记。启动和运行的命令如下</p><p>redis-server /www/server/redis/redis.conf #指定配置文件<br>redis-cli #直接运行 舒服了</p></blockquote><p>启动Redis、并测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli -p 6379 <span class="comment">#使用默认端口6379开启连接</span></span><br><span class="line">ping <span class="comment">#测试是否成功，成功就返回PONG</span></span><br><span class="line"><span class="built_in">set</span> k1 helloworld <span class="comment">#设置一个键为k1,值为helloworld的键值对</span></span><br><span class="line">get k1 <span class="comment">#获取k1键的值，返回helloworld则成功</span></span><br></pre></td></tr></table></figure><p>查看系统当前进程、关闭redis连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新开一个连接窗口</span></span><br><span class="line">ps -ef|grep redis <span class="comment">#查看当前进程</span></span><br><span class="line">shutdown <span class="comment">#关闭连接</span></span><br><span class="line"><span class="built_in">exit</span> <span class="comment">#退出</span></span><br><span class="line">ps -ef|grep redis <span class="comment">#查看当前进程</span></span><br></pre></td></tr></table></figure><ul><li>执行ps命令 发现进程正开启</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211353.png" alt="image-20210705220738127" style="zoom:67%;"><ul><li>关闭连接并退出</li></ul><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211356.png" alt="image-20210705221251869"></p><ul><li>执行ps命令 发现进程已关闭</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211359.png" alt="image-20210705221355936" style="zoom:80%;"><h2 id="2-3-基础知识说明"><a href="#2-3-基础知识说明" class="headerlink" title="2.3 基础知识说明"></a>2.3 基础知识说明</h2><p>默认16个数据库，类似数组下标从零开始，初始默认使用零号库</p><blockquote><p>Select命令切换数据库</p><p>Dbsize查看当前数据库的key的数量</p><p>Flushdb：清空当前库</p><p>Flushall：清空全部的库</p></blockquote><p>Redis为什么使用单线程？</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p>为什么要用Redis/为什么要用缓存？</p><p>高性能：</p><ul><li>缓存位于内存中，直接操作内存比读取数据库更快</li><li>为了保证数据的一致性，数据库中的数据改变时需要同时改变缓存中的数据</li></ul><p>高并发</p><ul><li>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g）</li><li>使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</li></ul><blockquote><p>QPS（Query Per Second）每秒查询率，是用来衡量服务性能的一个重要指标</p></blockquote><h1 id="3-五大数据类型-2"><a href="#3-五大数据类型-2" class="headerlink" title="3 五大数据类型[2]"></a>3 五大数据类型[2]</h1><h2 id="3-1-string"><a href="#3-1-string" class="headerlink" title="3.1 string"></a>3.1 string</h2><ol><li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li><li><strong>常用命令:</strong> <code>set,get,strlen,exists,decr,incr,setex</code> 等等。</li><li><strong>应用场景</strong> ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>普通字符串的基本操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value <span class="comment">#设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>批量设置</strong> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 <span class="comment"># 批量设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 <span class="comment"># 批量获取多个 key 对应的 value</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>过期</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure><h2 id="3-2-list"><a href="#3-2-list" class="headerlink" title="3.2 list"></a>3.2 list</h2><ol><li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li><li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li><li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList 1 <span class="comment"># 将 list的尾部(最左边)1个元素取出</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop myList2 1 <span class="comment"># 将 list的头部(最右边)的1个元素取出</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>我专门花了一个图方便小伙伴们来理解：</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211406.png" alt="redis list"></p><p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p><p><strong>通过 <code>llen</code> 查看链表长度：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen myList</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="3-3-hash"><a href="#3-3-hash" class="headerlink" title="3.3 hash"></a>3.3 hash</h2><ol><li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li><li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li><li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;guide&quot;</span></span><br><span class="line">3) <span class="string">&quot;description&quot;</span></span><br><span class="line">4) <span class="string">&quot;dev&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;description&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line">1) <span class="string">&quot;guide&quot;</span></span><br><span class="line">2) <span class="string">&quot;dev&quot;</span></span><br><span class="line">3) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-set"><a href="#3-4-set" class="headerlink" title="3.4 set"></a>3.4 set</h2><ol><li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li><li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li><li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard mySet <span class="comment"># 查看 set 的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-sorted-set"><a href="#3-5-sorted-set" class="headerlink" title="3.5 sorted set"></a>3.5 sorted set</h2><ol><li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li><li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3-6-bitmap-不太懂"><a href="#3-6-bitmap-不太懂" class="headerlink" title="3.6 bitmap(不太懂)"></a>3.6 bitmap(不太懂)</h2><ol><li><strong>介绍 ：</strong> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</li><li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li><li><strong>应用场景:</strong> 适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 bitmap 来记录上述事例中一周的打卡记录如下所示：</span></span><br><span class="line"><span class="comment"># 周一：1，周二：0，周三：0，周四：1，周五：1，周六：0，周天：0 （1 为打卡，0 为不打卡）</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">0</span><br><span class="line"><span class="comment"># getbit 获取操作</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3 <span class="comment"># 查看周四是否打卡</span></span><br><span class="line">1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 6 <span class="comment"># 查看周七是否打卡</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># 统计这周打卡的记录，可以看到只有3天是打卡的状态：</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="4-Redis事务"><a href="#4-Redis事务" class="headerlink" title="4 Redis事务"></a>4 Redis事务</h1><p>Redis事务的简单理解就是将命令以队列的形式打包、放入一个队列中、然后一起执行所有命令。某条命令执行失败不会影响其他命令。Redis事务的操作和执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始事务（MULTI）。</span><br><span class="line">命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。</span><br><span class="line">执行事务(EXEC)。</span><br></pre></td></tr></table></figure><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><ul><li>使用 <a href="https://redis.io/commands/multi"><code>MULTI</code></a>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec"><code>EXEC</code></a>命令将执行所有命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Guide哥&quot;</span></span><br></pre></td></tr></table></figure><ul><li>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER <span class="string">&quot;Guide哥&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话(在本事务外被修改)，整个事务都不会执行，直接返回失败。</li></ul><p>在本事务中修改watch的变量a,不会有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a 11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> a 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) <span class="string">&quot;11&quot;</span></span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;22&quot;</span></span><br></pre></td></tr></table></figure><p>在本事务外修改name的值，将会出错，<strong>整个事务都不会执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口1 事务</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;wukang1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment">#执行完这条后去窗口2</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment">#发现执行的结果为nil 出问题了</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 窗口2 修改name的值</span></span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;wukang1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;wukang2&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）</li><li>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</li><li>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</li></ul><h1 id="5-Jedis"><a href="#5-Jedis" class="headerlink" title="5 Jedis"></a>5 Jedis</h1><p>Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件。是springboot集成Redis的前置知识，了解即可。</p><p><strong>5.1 Jedis连接Redis</strong></p><p>直接new一个Jedis对象，填入ip和端口号，就可以了。步骤如下：</p><blockquote><p>1 新建一个redis-study的空项目，项目下建一个普通maven项目resid-01-jedis，注意我这里jdk用的11</p><p>2 导入redis依赖，开启本地windows下的redis软件，双击redis-server.exe 和 redis-cli.exe</p><p>3 编写测试代码、连接redis</p></blockquote><p>2 导入redis依赖，开启本地redis软件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3 编写测试代码、连接redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.ping;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="comment">//查看服务是否运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务正在运行: &quot;</span>+jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：连接成功！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211416.png" alt="image-20210706135357768" style="zoom:50%;"><p><strong>5.2 Jedis类的API调用</strong></p><p>连接和关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.connect(); <span class="comment">//连接</span></span><br><span class="line">jedis.disconnect(); <span class="comment">//断开连接</span></span><br></pre></td></tr></table></figure><p>对key操作的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB();</span><br><span class="line"><span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>)</span><br><span class="line"><span class="string">&quot;系统中所有的键如下：&quot;</span> Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"><span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey()</span><br><span class="line"><span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>)</span><br><span class="line"><span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize()</span><br><span class="line"><span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll()</span><br></pre></td></tr></table></figure><p>对String操作的命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mget();</span><br><span class="line">jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br></pre></td></tr></table></figure><p>对List操作命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jedis.lpush();</span><br><span class="line">jedis.rpop;</span><br><span class="line">jedis.lrange();</span><br><span class="line">jedis.ltrim();</span><br><span class="line">jedis.sort();</span><br></pre></td></tr></table></figure><p>对Set的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd();</span><br><span class="line">jedis.smembers();</span><br><span class="line">jedis.spop();</span><br><span class="line">jedis.sismember();</span><br><span class="line">jedis.sinter(); <span class="comment">//交集并集</span></span><br></pre></td></tr></table></figure><p>对Hash的操作命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jedis.hmset();</span><br><span class="line">jedis.hset();</span><br><span class="line">jedis.hgetAll();</span><br><span class="line">jedis.hkeys();</span><br><span class="line">jedis.hvals();</span><br><span class="line">jedis.hlen();</span><br><span class="line">jedis.hdel();</span><br><span class="line">jedis.hexists();</span><br><span class="line">jedis.hmget();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5.3 Jedis处理事务</strong></p><blockquote><p>//开启事务</p><p>Transaction multi = jedis.multi();</p></blockquote><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMulti</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端连接服务端，redis服务端需要被开启</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//向redis存入一条数据</span></span><br><span class="line">            multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">            <span class="comment">//再存入一条数据</span></span><br><span class="line">            multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">            <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">            <span class="comment">//int i = 100/0;</span></span><br><span class="line">            <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">            <span class="comment">//最终关闭客户端</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>没有出现异常（注释掉<code>int i = 100/0</code>)</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211421.png" alt="image-20210706142409593" style="zoom:50%;"><ul><li>出现异常</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211423.png" alt="image-20210706142445829" style="zoom:50%;"><h1 id="6-SpringBoot整合Redis"><a href="#6-SpringBoot整合Redis" class="headerlink" title="6 SpringBoot整合Redis"></a>6 SpringBoot整合Redis</h1><h2 id="6-1-使用内置RedisTemplate"><a href="#6-1-使用内置RedisTemplate" class="headerlink" title="6.1 使用内置RedisTemplate"></a>6.1 使用内置RedisTemplate</h2><p>先简单使用内置的RedisTemplate对象，用来连接和使用Redis</p><blockquote><p>0 开启本地windows下的redis软件，双击redis-server.exe 和 redis-cli.exe</p><p>1 新建一个springboot项目 勾选Redis</p><p>2 在application.properties配置文件中配置redis</p><p>3 在test文件夹下的Redis02SpringbootApplicationTests类中编写测试代码</p><p>4 运行contextLoads方法、测试</p></blockquote><p>1 新建一个springboot项目 勾选Redis，初始化的配置如下图</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211427.png" alt="image-20210706144801199" style="zoom: 50%;"><p>2 在application.properties配置文件中配置redis</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure><p>3  在test文件夹下的Redis02SpringbootApplicationTests类中编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;wukang&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 测试结果，打印值wukang成功！</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211431.png" alt="image-20210706185427629" style="zoom:50%;"><p>事实上，所有Redis的命令都集成在RedisTemplate中，使用RedisTemplate.XX()即可调用，一些基本的原生命令，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.基本命令（原生命令，实际开发中需要使用工具类RedisUtils）</span></span><br><span class="line"><span class="comment">// redisTemplate  操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line"><span class="comment">// opsForValue    操作字符串 类似String</span></span><br><span class="line"><span class="comment">// opsForList     操作List 类似List</span></span><br><span class="line"><span class="comment">// opsForSet      操作Set</span></span><br><span class="line"><span class="comment">// opsForHash     操作Hash</span></span><br><span class="line"><span class="comment">// opsForZSet     操作ZSet</span></span><br><span class="line"><span class="comment">// opsForGeo      操作Geo</span></span><br><span class="line"><span class="comment">// opsForHyperLogLog  操作HyperLogLog</span></span><br></pre></td></tr></table></figure><h2 id="6-2-手动配置一个RedisTemplate"><a href="#6-2-手动配置一个RedisTemplate" class="headerlink" title="6.2 手动配置一个RedisTemplate"></a>6.2 手动配置一个RedisTemplate</h2><h3 id="1-为什么要自己配置"><a href="#1-为什么要自己配置" class="headerlink" title="1 为什么要自己配置"></a>1 为什么要自己配置</h3><p>对每一个组件springboot中都有一个XXXAutoConfiguration的自动配置类，和对应的XXXProperties，这里我们先看 <strong>RedisAutoConfiguration 自动配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class,JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="comment">// 我们可以自己定义一个redisTemplate来替换这个默认的！</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt;redisTemplate(RedisConnectionFactory redisConnectionFactory)<span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span></span><br><span class="line">        <span class="comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。内置的RedisTemplate有一些缺点</p><ul><li>内置的RedisTemplate的泛型是&lt;Object,Object&gt;，，泛型为&lt;String,Object&gt;将会更好用</li><li>内置的RedisTemplate没有设置key及value的序列化方式</li></ul><p><strong>@ConditionalOnMissingBean(name = “redisTemplate”) 该注解表明我们自己配置一个RedisTemplate对象后、内置的RedisTemplate就不会被实例化了。所以这里我们自己写一个配置类RedisConfig配置之。</strong></p><h3 id="2-编写RedisConfig和工具类"><a href="#2-编写RedisConfig和工具类" class="headerlink" title="2 编写RedisConfig和工具类"></a>2 编写RedisConfig和工具类</h3><blockquote><p>1 编写RedisConfig类</p><p>2 写一个Redis工具类</p><p>3 测试</p></blockquote><p>1 编写RedisConfig类：主要工作是序列化、算是一个模板，也不知道到底有没有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RedisTemplate序列化配置 -- &gt;  注意要使用 @Qualifier(&quot;redisTemplate&quot;) 避免歧义（测试类中有使用案例）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.utils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(String.valueOf(CollectionUtils.arrayToList(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 测试类,位于test包下的哦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;wukang&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisConfigTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;吴康&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//将传入的对象序列化为json（自己配置RedisTemplate后就不需要这个）</span></span><br><span class="line">        <span class="comment">//String jsonUser=new ObjectMapper().writeValueAsString(user);</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redisUtilTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisUtil.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;吴康工具人&quot;</span>);</span><br><span class="line">        System.out.println(redisUtil.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-Redis配置conf"><a href="#7-Redis配置conf" class="headerlink" title="7 Redis配置conf"></a>7 Redis配置conf</h1><p>目录下有redis.conf时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf <span class="comment">#进入编辑该文件的界面</span></span><br><span class="line">i <span class="comment">#进入编辑模式</span></span><br><span class="line">Esc <span class="comment">#退出编辑进入一般模式</span></span><br><span class="line">:q <span class="comment">#退出</span></span><br><span class="line">:wq <span class="comment">#保存并退出</span></span><br></pre></td></tr></table></figure><p>简单列几个重要的配置</p><ul><li>网络</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379 <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><ul><li>通用 GENERAL</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span></span><br><span class="line">databases 16 <span class="comment"># 数据库的数量，默认是 16 个数据库</span></span><br></pre></td></tr></table></figure><ul><li>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof。redis 是内存数据库，如果没有持久化，那么数据断电及失！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试！</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存rdb文件的时候，进行错误的检查校验！</span></span><br><span class="line">dir ./ <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure><ul><li>SECURITY 安全，这里演示命令行设置一个密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span> <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 <span class="comment"># 使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><ul><li>APPEND ONLY 模式 aof配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></pre></td></tr></table></figure><h1 id="8-Redis-持久化"><a href="#8-Redis-持久化" class="headerlink" title="8 Redis 持久化"></a>8 Redis 持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化。</p><p>Redis 支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。</p><h2 id="8-1-快照（snapshotting）持久化（RDB）"><a href="#8-1-快照（snapshotting）持久化（RDB）" class="headerlink" title="8.1 快照（snapshotting）持久化（RDB）"></a>8.1 快照（snapshotting）持久化（RDB）</h2><p>RDB（Redis DataBase）：Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s(15分钟)内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s(5分钟)内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s(1分钟)内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>RDB的优缺点</p><ul><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。<strong>如果需要进行大规模数据的恢复</strong>，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li><li>RDB的缺点是最后一次持久化后的数据可能丢失。</li><li>fork进程的时候，会占用一定的内存空间！！</li></ul><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211447.png" alt="image.png" style="zoom:80%;"><h2 id="8-2-AOF（append-only-file）持久化"><a href="#8-2-AOF（append-only-file）持久化" class="headerlink" title="8.2 AOF（append-only file）持久化"></a>8.2 AOF（append-only file）持久化</h2><p>AOF将我们的所有命令都记录下来。开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#让操作系统决定何时进行同步Copy to clipboardErrorCopied</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p>AOF的优缺点</p><ul><li>每一次修改都同步，文件的完整会更加好！</li><li>从不同步，效率最高的！</li><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li></ul><h1 id="9-Redis主从复制"><a href="#9-Redis主从复制" class="headerlink" title="9 Redis主从复制"></a>9 Redis主从复制</h1><h2 id="9-1-主从复制架构"><a href="#9-1-主从复制架构" class="headerlink" title="9.1 主从复制架构"></a>9.1 主从复制架构</h2><p>在第一节，数据库的架构演变中我们就提到过读写分离和主从复制。同样Redis所谓一种缓存（易失型数据），也有类似的主从复制的模式。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211451.png" alt="image-20210704162949719" style="zoom:67%;"><p>Redis主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）。</p><p><strong>主从复制的作用主要包括：</strong></p><ol><li>==数据冗余==：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>==故障恢复==：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>==负载均衡==：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>==高可用基石==：主从复制还是哨兵和集群能够实施的基础。</li></ol><p>真实的项目为了防止宕机不可能使用单机的Redis，所以主从复制的架构是必须的，并且最简单的情况是一主二从。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211454.png" alt="image.png" style="zoom: 50%;"><h2 id="9-2-一主二从环境配置"><a href="#9-2-一主二从环境配置" class="headerlink" title="9.2 一主二从环境配置"></a>9.2 一主二从环境配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info replication   <span class="comment"># 查看当前库的信息 执行</span></span><br><span class="line"><span class="comment"># 执行结果：</span></span><br><span class="line">role:master <span class="comment">#该服务器的角色是主机</span></span><br><span class="line">connected_slaves:0 <span class="comment">#该服务器没有从机</span></span><br></pre></td></tr></table></figure><p>我的redis.conf在 /www/server/redis目录下，经过全局后简化了开启redis的命令，如下：（全局命令见Linux笔记）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis.conf <span class="comment">#指定配置文件</span></span><br><span class="line">redis-cli <span class="comment">#直接运行 舒服了</span></span><br><span class="line">ps -aux | grep redis <span class="comment">#查看redis相关的进程</span></span><br></pre></td></tr></table></figure><h3 id="1-开始配置主从环境"><a href="#1-开始配置主从环境" class="headerlink" title="1 开始配置主从环境"></a>1 开始配置主从环境</h3><blockquote><p>这里通过开启多个进程来模拟主从环境只是一种演示，实际业务中是需要多台服务器的！！</p><p>1 复制并修改三个配置文件 redis79 redis80 redis81</p><p>2 三个会话窗口开启三个不同的服务</p><p>3 配置一主（79）二从（80、81），从机认老大</p></blockquote><p>1 复制并修改三个配置文件 redis79 redis80 redis81</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /www/server/redis</span><br><span class="line">cp redis.conf redis79.conf</span><br><span class="line">cp redis.conf redis80.conf</span><br><span class="line">cp redis.conf redis81.conf</span><br><span class="line">vim redis79.conf</span><br><span class="line">vim redis80.conf</span><br><span class="line">vim redis81.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分别修改 端口、oid文件名、log文件名、dump文件名</span><br><span class="line">1 指定端口 6379，依次类推</span><br><span class="line">2 Pid文件名字 pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid, 依次类推</span><br><span class="line">3 Log文件名字 logfile &quot;6379.log&quot;, 依次类推</span><br><span class="line">4 Dump.rdb文件名字 dbfilename dump6379.rdb, 依次类推</span><br></pre></td></tr></table></figure><p>2 三个会话窗口开启三个不同的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server /www/server/redis/redis79.conf</span><br><span class="line">redis-cli -p 6379</span><br><span class="line">redis-server /www/server/redis/redis80.conf</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">redis-server /www/server/redis/redis81.conf</span><br><span class="line">redis-cli -p 6381</span><br><span class="line">ps -aux | grep redis <span class="comment">#查看发现有三个进程 </span></span><br></pre></td></tr></table></figure><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211500.png" alt="image-20210707105010907" style="zoom: 50%;"><p>3 配置一主（79）二从（80、81），从机认老大</p><ul><li>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从就好了！</li><li>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里用的是命令，是暂时的！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 127.0.0.1 6379 <span class="comment">#两个从机分别执行</span></span><br></pre></td></tr></table></figure><h3 id="2-主从机的特点"><a href="#2-主从机的特点" class="headerlink" title="2 主从机的特点"></a>2 主从机的特点</h3><ul><li><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动从机保存！</p></li><li><p>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个候，主机如果回来了，从机依旧可以直接获取到该主机写的信息！</p></li><li><p>如果从机重启了（命令行来配置的主从的情况），就会变回主机（默认）！只要（重新设置）变为从机，立马就会从主机中获取值！</p><ul><li>只要是重新连接master，一次完全同步（全量复制）将被自动执行！</li></ul></li></ul><blockquote><p>复制原理</p><p>Slave 启动成功连接到 master 后会发送一个sync同步命令。</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><ul><li><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p></li></ul></blockquote><p>在没有使用哨兵模式前，如果主机断开了连接，我们只能手动配置主机、从机！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF no one <span class="comment">#让自己变成主机</span></span><br></pre></td></tr></table></figure><h2 id="9-3-哨兵模式"><a href="#9-3-哨兵模式" class="headerlink" title="9.3 哨兵模式"></a>9.3 哨兵模式</h2><p>哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。哨兵是一个独立的进程，作为进程，它会独立运行。</p><p>==其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。==</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211503.png" alt="image.png" style="zoom: 50%;"><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211509.png" alt="image.png" style="zoom:50%;"><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为 <strong>==主观下线==</strong> 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**==客观下线==**。</p><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ol><p><strong>缺点：</strong></p><ol><li>Redis 不好线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li></ol><h1 id="10-缓存穿透和缓存雪崩-2"><a href="#10-缓存穿透和缓存雪崩-2" class="headerlink" title="10 缓存穿透和缓存雪崩[2]"></a>10 缓存穿透和缓存雪崩[2]</h1><h2 id="10-1-缓存穿透"><a href="#10-1-缓存穿透" class="headerlink" title="10.1 缓存穿透"></a>10.1 缓存穿透</h2><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211509.png" alt="image-20210707115232430"></p><p>解决缓存穿透问题，最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p>除了基本的参数校验方法外，还有缓存无效key和布隆过滤器</p><h3 id="1-缓存无效key"><a href="#1-缓存无效key" class="headerlink" title="1 缓存无效key"></a>1 缓存无效key</h3><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况.</p><p>如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2 布隆过滤器"></a>2 布隆过滤器</h3><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211513.png" alt="image" style="zoom: 80%;"><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><h2 id="10-2-缓存雪崩"><a href="#10-2-缓存雪崩" class="headerlink" title="10.2 缓存雪崩"></a>10.2 缓存雪崩</h2><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong>可能导致宕机。</p><h3 id="缓存雪崩的原因"><a href="#缓存雪崩的原因" class="headerlink" title="缓存雪崩的原因"></a>缓存雪崩的原因</h3><ul><li>系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</li><li>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</li></ul><h3 id="缓存雪崩的解决办法："><a href="#缓存雪崩的解决办法：" class="headerlink" title="缓存雪崩的解决办法："></a>缓存雪崩的解决办法：</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h1 id="11-Redis发布订阅"><a href="#11-Redis发布订阅" class="headerlink" title="11 Redis发布订阅"></a>11 Redis发布订阅</h1><p>简单来说就是用Redis server作为一个消息队列，实现消息通信！！Redis可以做，但我后面要学RabittMQ，这里就不深究了</p><p><strong>发布订阅的示意图如下：</strong></p><p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com/img/20211112211517.png" alt="image.png"></p><p><strong>使用场景：</strong></p><ol><li>实时消息系统！</li><li>事实聊天！（频道当做聊天室，将信息回显给所有人即可！） </li><li>订阅，关注系统都是可以的！ 稍微复杂的场景我们就会使用 消息中间件MQ</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;狂神Redis教学视频学习笔记，包括NoSQL介绍、Redies数据类型、Redis事务、整合SpringBoot、Redis持久化、Redis主从复制等内容&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://wukang555.github.io/categories/%E7%8B%82%E7%A5%9E/"/>
    
    
    <category term="框架" scheme="https://wukang555.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Redis" scheme="https://wukang555.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
