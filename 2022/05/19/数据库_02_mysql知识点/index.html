<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wukang555.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="MySQL知识点总结：索引、架构、锁、事物、隔离级别。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL知识点">
<meta property="og:url" content="https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_02_mysql%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="落风的风">
<meta property="og:description" content="MySQL知识点总结：索引、架构、锁、事物、隔离级别。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212727.png">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212732.png">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212737.png">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212741">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212748">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212751">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212754">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212757">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212801">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212804.jpg">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212808.png">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212811.png">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212817">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212820">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212823">
<meta property="og:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212828.png">
<meta property="article:published_time" content="2022-05-19T15:55:00.000Z">
<meta property="article:modified_time" content="2022-05-19T01:59:35.059Z">
<meta property="article:author" content="Wu kang">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212727.png">

<link rel="canonical" href="https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_02_mysql%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>MySQL知识点 | 落风的风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="落风的风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落风的风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://wukang555.github.io/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_02_mysql%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wu kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落风的风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-19 23:55:00 / Modified: 09:59:35" itemprop="dateCreated datePublished" datetime="2022-05-19T23:55:00+08:00">2022-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>MySQL知识点总结：索引、架构、锁、事物、隔离级别。</p>
<a id="more"></a>

<blockquote>
<p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/a303549861/article/details/100302267?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-19.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-19.control">参考了CSDN上一个大佬关于MySQL的面经总结</a></p>
<p>[2] <a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/#%E6%95%B0%E6%8D%AE%E5%BA%93">参考了cyc2018大佬主页</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/database/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95?id=%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95">参考了JavaGuide的数据库索引文章</a></p>
</blockquote>
<p>说实话现在只会背背事务及隔离级别、各种锁的面经，但数据库底层的实现仍然是一无所知，<code>Innodb</code>引擎那本书也还没看到重点部分，权且先用大佬通俗的文章先理解一下，三个重点：</p>
<ul>
<li>索引</li>
<li>MySQL的基础架构 一条sql语句的执行过程</li>
<li>锁</li>
<li>事务和隔离级别</li>
<li>不同存储引擎的区别（面经）</li>
</ul>
<h1 id="1-索引"><a href="#1-索引" class="headerlink" title="1 索引"></a>1 索引</h1><h2 id="1-1-索引的定义、使用场景"><a href="#1-1-索引的定义、使用场景" class="headerlink" title="1.1 索引的定义、使用场景"></a>1.1 索引的定义、使用场景</h2><p><strong>什么是索引？</strong></p>
<p>索引，是数据库管理系统中一个排好序的数据结构，类似于书籍的目录，想找到一本书的某个特定的主题，需要先找到书的目录，定位对应的页码。</p>
<p>MySQL 中存储引擎使用类似的方式进行查询，先去索引中查找对应的值，然后根据匹配的索引找到对应的数据行。</p>
<p>（where后面出现的列都是索引么？索引跟主键有什么区别和关系）</p>
<p> <strong>索引有什么好处？</strong></p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>
</ul>
<p><strong>索引有什么坏处？</strong></p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<p><strong>索引的使用场景？</strong></p>
<ul>
<li>1、对非常小的表，大部分情况下全表扫描效率更高。</li>
<li>2、对中大型表，索引非常有效。</li>
<li>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</li>
</ul>
<p><strong>表的两种切分方式：</strong></p>
<ul>
<li><p>水平切分Sharding ：它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<ul>
<li>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</li>
</ul>
</li>
<li><p>垂直切分：垂直切分是将一张表按列切分成多个表</p>
<ul>
<li><p>通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
</li>
<li><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际场景下，MySQL 分区表很少使用，原因可以看看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/admin1973/article/details/55504018">《互联网公司为啥不使用 MySQL 分区表？》</a> 文章。</p>
<p>对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p>
</blockquote>
<h2 id="1-2-索引按应用层次分类"><a href="#1-2-索引按应用层次分类" class="headerlink" title="1.2 索引按应用层次分类"></a>1.2 索引按应用层次分类</h2><p>索引，都是实现在存储引擎层的。根据应用层次分为六种类型：</p>
<p>1、普通索引：最基本的索引，允许重复和为null。</p>
<p>2、唯一索引：与普通索引类似，允许为空，但具有唯一性约束。（主键索引是特殊的唯一索引，不允许有空值。）</p>
<p>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</p>
<p>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</p>
<p>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</p>
<blockquote>
<p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。</p>
</blockquote>
<p>具体的使用，可以看看 <a target="_blank" rel="noopener" href="http://blog.720ui.com/2017/mysql_core_03_how_use_index/">《服务端指南 数据存储篇 | MySQL（03） 如何设计索引》</a> 。</p>
<p>==有一个问题：外键索引究竟是什么？前缀索引又是什么？最左匹配是什么？==</p>
<h2 id="1-3-索引的底层实现（数据结构）"><a href="#1-3-索引的底层实现（数据结构）" class="headerlink" title="1.3 索引的底层实现（数据结构）"></a>1.3 索引的底层实现（数据结构）</h2><p>索引根据存储结构来分，索引分为 <strong>BTree索引（B-Tree或B+Tree索引），Hash索引</strong>，full-index全文索引，R-Tree索引。</p>
<p><strong>Hash索引</strong> ：哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据。</p>
<p><strong>B-Tree索引</strong>：B树的数据结构，数据分布在各个节点之上</p>
<p><strong>B+Tree索引</strong>：B+树的数据结构，所有数据分布在叶子节点上、非终端节点看成是索引部分</p>
<blockquote>
<p>回头看看大话数据结构的B树去了</p>
</blockquote>
<h3 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212727.png" alt="img"></p>
<p>既然哈希表查找这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong>有两点</p>
<ul>
<li>1 Hash 冲突问题（hash冲突不是主要的问题），hash冲突可以通过链地址法、再散列函数法等方法解决</li>
<li>2 Hash 索引不支持顺序和范围查询（最大的缺点），比如下面的的范围查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br><span class="line"># Hash 索引是根据 hash 算法来定位的，范围查找时难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?</span><br></pre></td></tr></table></figure>

<h3 id="两种B树索引的区别"><a href="#两种B树索引的区别" class="headerlink" title="两种B树索引的区别"></a>两种B树索引的区别</h3><ul>
<li>B+树的检索更为稳定<ul>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
</li>
<li>B+树的叶子结点包含全部关键字信息更适合于顺序检索，范围检索<ul>
<li>1要排序遍历的话，直接从左到右遍历叶子节点</li>
<li>2 适合带范围的查找：先从根节点出发找到最小值的位置，但后定位到叶子节点中，一直遍历找直到找到最大值</li>
</ul>
</li>
</ul>
<h2 id="1-4-索引存储位置的分类"><a href="#1-4-索引存储位置的分类" class="headerlink" title="1.4 索引存储位置的分类"></a>1.4 索引存储位置的分类</h2><p><strong>索引按索引表存放的位置分为聚集索引和非聚集索引</strong></p>
<h3 id="1-4-1-聚集索引"><a href="#1-4-1-聚集索引" class="headerlink" title="1.4.1 聚集索引"></a>1.4.1 聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。==主键索引属于聚集索引==。</strong></p>
<p>聚集索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的<strong>数据</strong>。</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212732.png" alt="img" style="zoom: 50%;">

<p>聚集索引的优点：</p>
<ul>
<li>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</li>
</ul>
<p>聚集索引的缺点：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3 id="1-4-2-非聚集索引"><a href="#1-4-2-非聚集索引" class="headerlink" title="1.4.2 非聚集索引"></a>1.4.2 非聚集索引</h3><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong> 唯一索引，普通索引，前缀索引等索引都属于二级索引（辅助索引），二级索引属于非聚集索引。</p>
<p>二级索引的叶子节点存放的是主键，一般查到主键后再回表查数据。(大部分是，也不绝对)</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212737.png" alt="img" style="zoom:50%;">

<p>非聚集索引的优点：</p>
<ul>
<li><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</li>
</ul>
<p>非聚集索引的缺点：</p>
<ul>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<h3 id="1-4-3-非聚集索引一定要回表查询？"><a href="#1-4-3-非聚集索引一定要回表查询？" class="headerlink" title="1.4.3 非聚集索引一定要回表查询？"></a>1.4.3 非聚集索引一定要回表查询？</h3><p><strong>非聚集索引不一定回表查询。</strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么非聚集索引也可以一次得到所需的字段，无需回表查询</p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name&#x3D;&#39;guang19&#39;;</span><br></pre></td></tr></table></figure>

<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<h2 id="1-5-创建索引的注意事项"><a href="#1-5-创建索引的注意事项" class="headerlink" title="1.5 创建索引的注意事项"></a>1.5 创建索引的注意事项</h2><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h1 id="2-MySQL的基础架构"><a href="#2-MySQL的基础架构" class="headerlink" title="2 MySQL的基础架构"></a>2 MySQL的基础架构</h1><blockquote>
<p>本节完全参考了<a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/database/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84">一条SQL语句是如何执行的</a>文章，作者：木木匠</p>
</blockquote>
<p>本篇文章会分析下一个 SQL语句在 MySQL 中的执行流程，但在分析之前需要先了解 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解SQL语句的执行过程。</p>
<h2 id="2-1-MySQL-基本架构概览"><a href="#2-1-MySQL-基本架构概览" class="headerlink" title="2.1 MySQL 基本架构概览"></a>2.1 MySQL 基本架构概览</h2><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<ul>
<li><strong>连接器：</strong>身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong>执行语句，然后从存储引擎返回数据。</li>
</ul>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212741" alt="img" style="zoom: 50%;">



<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h2 id="2-2-查询语句分析"><a href="#2-2-查询语句分析" class="headerlink" title="2.2 查询语句分析"></a>2.2 查询语句分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_student A where A.age&#x3D;&#39;18&#39; and A.name&#x3D;&#39; 张三 &#39;;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li><p>1 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>2 通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>3 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>4 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h2 id="2-3-更新语句分析"><a href="#2-3-更新语句分析" class="headerlink" title="2.3 更新语句分析"></a>2.3 更新语句分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_student A set A.age&#x3D;&#39;19&#39; where A.name&#x3D;&#39; 张三 &#39;;</span><br></pre></td></tr></table></figure>

<p>其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>1 先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>2 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>3 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>4 更新完成。</li>
</ul>
<blockquote>
<p>redo log 是 InnoDB 引擎特有的，因此InooDB也有了crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
</blockquote>
<p>redo log的两阶段提交的方式是为了保证一致性！！，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li>
</ul>
<h1 id="3-数据库的锁"><a href="#3-数据库的锁" class="headerlink" title="3 数据库的锁"></a>3 数据库的锁</h1><blockquote>
<p>完全参考了木木匠的开源项目中的文章<a target="_blank" rel="noopener" href="https://github.com/javagrowing/JGrowing/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%EF%BC%9F.md"><strong>为什么开发人员必须要了解数据库锁？</strong></a></p>
</blockquote>
<p>锁在数据库中其功能之一也是用来实现事务隔离性。而隔离性是为了解决脏读、不可重复读、和幻读几类问题。事务的隔离性这里就先不讲了。直接看InnoDB中有哪些锁吧</p>
<h2 id="3-1-InnoDB锁的类型"><a href="#3-1-InnoDB锁的类型" class="headerlink" title="3.1 InnoDB锁的类型"></a>3.1 InnoDB锁的类型</h2><p>小明首先了解一下Mysql中常见的锁类型有哪些:</p>
<h3 id="2-3-1-S-or-X-（行锁）"><a href="#2-3-1-S-or-X-（行锁）" class="headerlink" title="2.3.1 S or X （行锁）"></a>2.3.1 S or X （行锁）</h3><p>在InnoDb中实现了两个标准的行级锁，可以简单的看为两个读写锁:</p>
<ul>
<li>S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。</li>
<li>X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了。</li>
</ul>
<blockquote>
<p>兼容性:是指事务A获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。</p>
</blockquote>
<p>纵轴是代表已有的锁，横轴是代表尝试获取的锁。只有读锁和读锁同时兼容</p>
<table>
<thead>
<tr>
<th align="center">已有锁\ 尝试锁</th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>X</strong></td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td align="center"><strong>S</strong></td>
<td>冲突</td>
<td>兼容</td>
</tr>
</tbody></table>
<h3 id="2-3-2-IS-or-IX（意向锁-表锁）"><a href="#2-3-2-IS-or-IX（意向锁-表锁）" class="headerlink" title="2.3.2 IS or IX（意向锁\表锁）"></a>2.3.2 IS or IX（意向锁\表锁）</h3><p>意向锁在InnoDB中是表级锁,和他的名字一样他是用来表达一个事务想要获取什么。其实就是先为表锁打一个标记！！意向锁分为:</p>
<ul>
<li>意向共享锁 IS:表达一个事务想要获取一张表中某几行的共享锁。</li>
<li>意向排他锁 IX:表达一个事务想要获取一张表中某几行的排他锁。</li>
</ul>
<p>这个锁有什么用呢？为什么需要这个锁呢？ 首先说一下如果没有这个锁，如果要给这个表加上表锁，一般的做法是去遍历每一行看看他是否有行锁，这样的话效率太低，而我们有意向锁，只需要判断是否有意向锁即可，不需要再去一行行的去扫描。</p>
<p><strong>因此 IS 和 IX 的作用就是在上表级锁的时候，可以快速判断是否可以上锁，而不需要遍历表中的所有记录。</strong></p>
<p>在InnoDB中由于支持的是行级的锁，因此InnboDB锁的兼容性可以扩展如下：</p>
<table>
<thead>
<tr>
<th>.</th>
<th>IX</th>
<th>IS</th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
</tbody></table>
<h3 id="2-3-3-自增长锁（还是有点没看懂）"><a href="#2-3-3-自增长锁（还是有点没看懂）" class="headerlink" title="2.3.3 自增长锁（还是有点没看懂）"></a>2.3.3 自增长锁（还是有点没看懂）</h3><p>自增长锁是一种特殊的表锁机制，<strong>提升并发插入性能</strong>。对于这个锁有几个特点:</p>
<ul>
<li>在sql执行完就释放锁，并不是事务执行完。</li>
<li>对于Insert…select大数据量插入会影响插入性能，因为会阻塞另外一个事务执行。</li>
<li>自增算法可以配置。</li>
</ul>
<p>在MySQL5.1.2版本之后，有了很多优化，可以根据不同的模式来进行调整自增加锁的方式。小明看到了这里打开了自己的MySQL发现是5.7之后，于是便输入了下面的语句,获取到当前锁的模式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;innodb_autoinc_lock_mode&#39;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_autoinc_lock_mode | 2     |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>在MySQL中innodb_autoinc_lock_mode有3种配置模式：0、1、2，分别对应”传统模式”, “连续模式”, “交错模式”。</p>
<ul>
<li><p>0 传统模式:也就是我们最上面的使用表锁。</p>
</li>
<li><p>1 连续模式:对于插入的时候可以确定行数的使用互斥量，对于不能确定行数的使用表锁的模式。</p>
</li>
<li><p>2 交错模式:所有的都使用互斥量，为什么叫交错模式呢，有可能在批量插入时自增值不是连续的，当然一般来说如果不看重自增值连续一般选择这个模式，性能是最好的。</p>
</li>
</ul>
<h2 id="3-2-InnoDB锁算法"><a href="#3-2-InnoDB锁算法" class="headerlink" title="3.2 InnoDB锁算法"></a>3.2 InnoDB锁算法</h2><h3 id="2-4-1-记录锁-Record-Lock"><a href="#2-4-1-记录锁-Record-Lock" class="headerlink" title="2.4.1 记录锁(Record-Lock)"></a>2.4.1 记录锁(Record-Lock)</h3><p>记录锁是锁住记录的，这里要说明的是这里<strong>锁住的是索引记录，而不是我们真正的数据记录。</strong></p>
<ul>
<li>如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住.</li>
<li>如果没有表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁。</li>
<li>如果要锁的列没有索引，则会进行全表记录加锁。</li>
</ul>
<h3 id="2-4-2-间隙锁（gap锁）"><a href="#2-4-2-间隙锁（gap锁）" class="headerlink" title="2.4.2 间隙锁（gap锁）"></a>2.4.2 间隙锁（gap锁）</h3><p>间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫gap锁，gap锁之间不会相互阻塞，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。</p>
<p><strong>要给此时还未存在的记录加锁怎么办？加间隙锁！！防止幻读！！</strong></p>
<blockquote>
<p>如下图：有两个间隙锁，相互之间不阻塞。但对间隙之中的元素起保护作用</p>
</blockquote>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212748" alt="img" style="zoom: 50%;">

<h3 id="3-2-3-next-key锁"><a href="#3-2-3-next-key锁" class="headerlink" title="3.2.3 next-key锁"></a>3.2.3 next-key锁</h3><p>这个锁本质是记录锁加上gap锁。在RR隔离级别下(InnoDB默认)，Innodb对于行的扫描锁定都是使用此算法，但是如果查询扫描中有唯一索引会退化成只使用记录锁。为什么呢? 因为唯一索引能确定行数，而其他索引不能确定行数，有可能在其他事务中会再次添加这个索引的数据会造成幻读。</p>
<h3 id="3-2-4-插入意向锁"><a href="#3-2-4-插入意向锁" class="headerlink" title="3.2.4 插入意向锁"></a>3.2.4 插入意向锁</h3><p>插入意向锁是在插入数据的时候产生的。 如果持有插入意向锁。在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个<strong>记录索引</strong>包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p>
<p>某个间隙被锁住之后，可以插入一个”插入意向锁“，表示在等待这个间隙被释放。</p>
<blockquote>
<p>这里要说明的是如果有间隙锁了，插入意向锁会被阻塞。</p>
</blockquote>
<h2 id="3-3-加锁实验"><a href="#3-3-加锁实验" class="headerlink" title="3.3 加锁实验"></a>3.3 加锁实验</h2><p>因为事务之间是隔离的，可以通过两个事务来研究不同锁之间的冲突。</p>
<p><strong>1 事务A查询（使用普通索引），事务B对不同行数据做插入操作</strong></p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212751" alt="img" style="zoom:50%;">

<p>发现在事务A中给555加了Next-key锁，事务B插入的时候会首先进行插入意向锁的插入，于是得出下面结论:可以看见事务B由于间隙锁和插入意向锁的冲突，导致了阻塞。</p>
<p><strong>2 事务A查询（使用唯一索引），事务B对不同行数据做插入操作</strong></p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212754" alt="img" style="zoom:50%;">

<p>发现事务B并没有发生阻塞，，因为唯一索引会降级记录锁，这么做的理由是:非唯一索引加next-key锁由于不能确定明确的行数有可能其他事务在你查询的过程中，再次添加这个索引的数据，导致隔离性遭到破坏，也就是幻读。唯一索引由于明确了唯一的数据行，所以不需要添加间隙锁解决幻读。</p>
<p><strong>3 事务A查询（没有使用索引），事务B对不同行数据做插入操作</strong></p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212757" alt="img" style="zoom:50%;">

<p>小明一看哎哟我去，这个咋回事呢，咋不管是用实验1非间隙锁范围的数据，还是用间隙锁里面的数据都不行，难道是加了表锁吗？</p>
<p>的确，如果用没有索引的数据，其会对所有聚簇索引上都加上next-key锁。</p>
<p>所以大家平常开发的时候如果对查询条件没有索引的，一定进行一致性读，也就是加锁读，会导致全表加上索引，会导致其他事务全部阻塞，数据库基本会处于不可用状态。</p>
<h2 id="3-4-解决项目中的死锁问题"><a href="#3-4-解决项目中的死锁问题" class="headerlink" title="3.4 解决项目中的死锁问题"></a>3.4 解决项目中的死锁问题</h2><blockquote>
<p>undo较小的事务是啥？（就是回滚不重要的事务呗）</p>
</blockquote>
<p>死锁:是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。说明有等待才会有死锁，解决死锁可以通过去掉等待，比如回滚事务。</p>
<p>解决死锁的两个办法:</p>
<ol>
<li>等待超时:当某一个事务等待超时之后回滚该事务，另外一个事务就可以执行了，但是这样做效率较低，会出现等待时间，还有个问题是如果这个事务所占的权重较大，已经更新了很多数据了，但是被回滚了，就会导致资源浪费。</li>
<li>等待图(wait-for-graph): 等待图用来描述事务之间的等待关系，当这个图如果出现回路如下:就出现回滚，通常来说InnoDB会选择回滚权重较小的事务，也就是undo较小的事务。</li>
</ol>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212801" alt="img" style="zoom: 50%;">

<h1 id="4-事务和隔离级别"><a href="#4-事务和隔离级别" class="headerlink" title="4 事务和隔离级别"></a>4 事务和隔离级别</h1><blockquote>
<p>这里先用我之前幕布上的笔记</p>
</blockquote>
<h2 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p><strong>事务的ACID特性</strong></p>
<ul>
<li>原子性：一个事务中的操作要么都发生（全部提交成功），要么都不发生（全部回滚）。</li>
<li>一致性：数据库<strong>在事务执行前后</strong>都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li>
<li>隔离性： 多个事务并发访问时，事务之间是隔离的。就是说一个事务所做的修改在<strong>最终提交以前</strong>，对其它事务是不可见的。</li>
<li>持久性： 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中。即使系统崩溃，事务执行的结果也不会丢失。<ul>
<li>系统发生崩溃可以通过<strong>重做日志（Redo Log）</strong>进行恢复，与<strong>回滚日志记录数据的逻辑修改</strong>不同，重做日志记录的是数据页的物理修改。</li>
<li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时<strong>反向执行这些修改操作</strong>即可。</li>
</ul>
</li>
</ul>
<p><strong>ACID特性之间的关系</strong></p>
<ul>
<li><p>只有满足一致性，事务的执行结果才是正确的。</p>
</li>
<li><p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</p>
</li>
<li><p>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</p>
</li>
<li><p>事务满足持久化是为了能应对系统崩溃的情况。</p>
</li>
</ul>
<p><strong>总结：如何满足ACID特性</strong></p>
<ul>
<li><p>数据库管理系统采用<strong>日志</strong>来保证事务的原子性、持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</p>
</li>
<li><p>数据库管理系统采用<strong>锁机制</strong>来实现事务的隔离性。当多个事务同时更新数 据库中相同的数据时，只允许持有锁的事务能更新该数据</p>
</li>
<li><p>原子性和隔离性满足之后保证了一致性：即保证执行结果正确；持久性用来应对系统的崩溃</p>
</li>
</ul>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212804.jpg" alt="img" style="zoom: 67%;">

<h2 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2 事务日志"></a>4.2 事务日志</h2><blockquote>
<p>二进制日志只在事务提交的时候一次性写入(基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入。</p>
</blockquote>
<p>MYSQL自带的日志有bin二进制日志、查询日志、慢查询日志</p>
<ul>
<li><strong>bin log日志 记录所有更改数据的语句，可用于数据复制。</strong></li>
<li><strong>错误日志（error log）记录MySQL服务进程mysqld在启动/关闭或运行过程中遇到的错误信息</strong></li>
<li>普通查询日志（general query log）：记录建立的客户端连接和执行的语句。</li>
<li>慢查询日志（slow query log）：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询。</li>
</ul>
<p>所谓的<strong>事务日志</strong>是指InnoDB引擎的redo log重做日志和undo log回滚日志。 <strong>redo用来保证事务的持久性，通过记录物理修改来恢复数据。 undo保证事务的原子、用来回滚行记录到某个特定的版本。</strong></p>
<h3 id="4-2-1-redo日志"><a href="#4-2-1-redo日志" class="headerlink" title="4.2.1 redo日志"></a>4.2.1 redo日志</h3><blockquote>
<p>我这里只需要理解redo是什么就好了，至于如何实现和底层原理、我还不懂</p>
<p>参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/No_Game_No_Life_/article/details/106718599">这篇文章</a></p>
</blockquote>
<p><strong>redo log通常是物理日志，记录的是也得物理修改操作。</strong></p>
<p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p>
<p><strong>mysql数据库同步数据到磁盘的过程！！</strong></p>
<p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Buffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。而buffer pool是在内存里的，如果还没来的同步的时候宕机或断电了，就会导致丢失部分已提交事务的修改信息。</p>
<p>所以引入了redo log来记录已成功提交事务的修改信息，宕机之后，系统重启后读取redo log恢复最新数据。虽然redo log也有内存buffer缓冲的部分，如果要严格保证数据不丢失，就要在事务提交前做一次磁盘写入，但是这种IO操作相比于buffer pool这种以页（16kb）为管理单位的随机写入，它做的是几个字节的顺序写入，效率要高得多。<strong>（就是说虽然redo也是需要从内存写入磁盘，但它是顺序写入、比直接同步事务要快得多）</strong></p>
<p>比如下面的操作，从银行卡账户转账到理财账户表：</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212808.png" alt="在这里插入图片描述" style="zoom:80%;">

<p><strong>redo buffer比 buffer pool快，但redo buffer就不可能丢失事务么？</strong></p>
<p>当一条 SQL 更新完 Buffer Pool 中的缓存页后，将<strong>修改先写入redo log buffer 的缓存</strong>中，<strong>然后</strong>在某一个合适的时间点，将这条 <strong>redo log buffer中的修改刷入到磁盘redo log</strong>中。(其中还涉及到redo log buffer 内部是划分为许多 redo log block，每次刷新的是redo log block。这里不再详细表述了)</p>
<p>合适的时间点：</p>
<p>这个合适的时间点究竟是什么时候呢？</p>
<ul>
<li><p>MySQL 正常关闭的时候；</p>
</li>
<li><p>MySQL 的后台线程每隔一段时间定时的将 redo log buffer 刷入到磁盘，默认是每隔 1s 刷一次；</p>
</li>
<li><p>当 redo log buffer 中的日志写入量超过 redo log buffer 内存的一半时，即超过 8MB 时，会触发 redo log buffer 的刷盘；</p>
</li>
<li><p><strong>当事务提交时，根据配置的参数 innodb_flush_log_at_trx_commit 来决定是否刷盘。</strong></p>
<ul>
<li>如果innodb_flush_log_at_trx_commit 参数配置为 0，表示事务提交时，不进行 redo log buffer 的刷盘操作；</li>
<li>如果配置为 1，表示事务提交时，会将此时事务所对应的 redo log 所在的 redo log block 从内存写入到磁盘，同时调用 fysnc，确保数据落入到磁盘；</li>
<li>如果配置为 2，表示只是将日志写入到操作系统的缓存，而不进行 fysnc 操作。（进程在向磁盘写入数据时，是先将数据写入到操作系统的缓存中：os cache，再调用 fsync 方法，才会将数据从 os cache 中刷新到磁盘上</li>
</ul>
</li>
</ul>
<p><img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212811.png" alt="img"></p>
<blockquote>
<p>实际上要严格保证数据不丢失，必须得保证 innodb_flush_log_at_trx_commit 配置为 1。</p>
<p>innodb_flush_log_at_trx_commit为0，表示事务提交时不需要写入重做日志，而是由master thread来定期完成。<br>innodb_flush_log_at_trx_commit为2，表示事务提交时将重做日志写入重做日志缓存中。这个情况下，MySQL发生宕机但是操作系统没有宕机的情况下，重做是仍然可以进行的</p>
</blockquote>
<p><strong>下面介绍将日志同步到磁盘中的最佳实践：两阶段提交！!</strong></p>
<blockquote>
<p>如何通过日志实现持久性？</p>
<p>一言以蔽之：即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的文件中进行持久化。（包括redo log file和undo log file）。持久化又是一个需要经过系统调用的过程。</p>
<p>因为MySQL是工作在用户空间的，MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，所以必须经过系统调用fsync()操作，才能完成。</p>
</blockquote>
<p>更新数据、写入日志的过程：</p>
<ol>
<li>MySQL Server 层的执行器调用 InnoDB 存储引擎的数据更新接口；</li>
<li>存储引擎更新 Buffer Pool 中的缓存页，</li>
<li>同时存储引擎记录一条 redo log 到 redo log buffer 中，并将该条 redo log 的状态标记为 prepare 状态；</li>
<li>接着存储引擎告诉执行器，可以提交事务了。执行器接到通知后，会写 binlog 日志，然后提交事务；</li>
<li>存储引擎接到提交事务的通知后，将 redo log 的日志状态标记为 commit 状态；</li>
<li>接着根据 innodb_flush_log_at_commit 参数的配置，决定是否将 redo log buffer 中的日志刷入到磁盘。</li>
</ol>
<p>将 redo log 日志标记为 prepare 状态和 commit 状态，这种做法称之为两阶段事务提交，它能保证事务在提交后，数据不丢失。为什么呢？redo log 在进行数据重做时，只有读到了 commit 标识，才会认为这条 redo log 日志是完整的，才会进行数据重做，否则会认为这个 redo log 日志不完整，不会进行数据重做。</p>
<h3 id="4-2-2-undo日志"><a href="#4-2-2-undo日志" class="headerlink" title="4.2.2 undo日志"></a>4.2.2 undo日志</h3><p><strong>undo 称为回滚日志，是一种逻辑日志，是为了保证事务的原子性。</strong></p>
<ul>
<li><p>undo log主要记录的是数据的逻辑变化，因此只是将数据库逻辑地恢复到原 来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
</li>
<li><p>当 InnoDB存储引擎回滚时，它实际上做的是与先前相反的丁作。对于每个INSERT, InnoDB存储引擎会完成一个DELETE; 对于每个 DELETE, InnoDB存储引擎会执行一个INSERT; 对于每个UPDATE, InnoDB存储引擎会执行一个相反的UPDATE, 将修改前的行放回去。</p>
</li>
</ul>
<p><strong>比如一个插入的更新操作：</strong></p>
<p>用户执行了一个INSERT 10W条记录的事务，这个事务会导致分配新的段，即表空间会增大。在用户执行ROLLBACK时，会将插入的事务进行回滚（即对插入的行进行全部的删除操作），但是表空间的大小事实上还是变大了，只是数据还是那些数据。</p>
<h3 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h3><p>既然生产环境一般建议将 innodb_flush_log_at_trx_commit 设置为 1，也就是说每次更新数据时，redo log写入磁盘也要发生一次磁盘IO，为什么无直接将数据的修改写入磁盘中，何必引入 redo log 这一机制呢？</p>
<ul>
<li>首先 redo log 日志的刷盘时将修改追加到文件末尾，虽然也是一次磁盘 IO，但是这是顺序写操作（<strong>不需要移动磁头</strong>）；而对于直接将数据更新到磁盘，这个操作发生的是随机写操作（<strong>需要移动磁头做寻址</strong>）。</li>
<li>从另一方面来讲，通常一次更新操作，我们往往只会涉及到修改几个字节的数据，而如果因为仅仅修改几个字节的数据，就将整个数据页写入到磁盘（无论是磁盘还是 buffer pool，他们管理数据的单位都是以页为单位），这个代价未免也太了（每个数据页默认是 16KB），而一条 redo log 日志的大小可能就只有几个字节，因此每次磁盘 IO 写入的数据量更小，那么耗时也会更短。</li>
</ul>
<p><strong>redo日志和bin日志的区别！！</strong>？</p>
<h2 id="4-3-事务并发控制带来的问题"><a href="#4-3-事务并发控制带来的问题" class="headerlink" title="4.3 事务并发控制带来的问题"></a>4.3 事务并发控制带来的问题</h2><ul>
<li>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题，主要有以下四种：<ul>
<li><strong>丢失更新</strong>：两个事务在并发下同时进行更新，后一个事务的更新覆盖了前一个事务的更新。</li>
<li><strong>脏读</strong>： 脏读意味着一个事务T2读取了另一个事务T1未提交的数据，（当T1撤销了这次修改、那么T2读的就是脏数据）</li>
<li><strong>不可重复读</strong>：同一个事务中，多次读取到的数据不一致（原因是其他事务T2进来对本事务T1的一个数据做了修改、导致T1两次读取结果不一样）</li>
<li><strong>幻读</strong>：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据（T2想要读取T1的数据，但是T2读取数据之后，T1又对该数据进行了更新导致T2读取的是更新之前的数据）</li>
</ul>
</li>
<li>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。<ul>
<li>并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。</li>
<li>数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</li>
</ul>
</li>
</ul>
<h2 id="4-4-事务的隔离级别"><a href="#4-4-事务的隔离级别" class="headerlink" title="4.4 事务的隔离级别"></a>4.4 事务的隔离级别</h2><p>数据库事务的隔离级别有4个，由低到高依次为 <strong>读未提交、读已提交、可重复读、序列化</strong></p>
<ul>
<li>读未提交： 如果一个事务已经 开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。<strong>避免了丢失更新</strong>，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。<ul>
<li>不允许同时写，避免了丢失更新，有脏读</li>
</ul>
</li>
<li>读已提交： 读取数据的事务允许其 他事务继续访问该行数据（写），但是未提交的写事务将会禁止其他事务访问该行。<strong>避免了脏读</strong>，但是却可能出现不可重复读。事务A事先读 取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。<strong>（一般默认的隔离级别）</strong><ul>
<li>未提交的写禁止其他事物访问，避免了脏读</li>
</ul>
</li>
<li>可重复读：无论是否有其他事务对数据做了修改，一个事务在启动和提交之间读到数据始终是一致的。通常是，读取数据的事务将 会禁止写事务（但允许读事务），写事务则禁止任何其他事务。。这样避免 了<strong>不可重复读和脏读</strong>，但是有时可能出现幻读。<ul>
<li>只能同时并发读，避免不可重复读，有幻读</li>
</ul>
</li>
<li>序列化：要求事务序列化 执行，事务只能一个接着一个地执行，不能并发执行。序列化是最高的事务隔离级 别，同时代价也最高。。不仅可以<strong>避免脏读、不可重复读，还避免了幻读</strong>。</li>
</ul>
<h2 id="4-5-多版本并发控制MVCC"><a href="#4-5-多版本并发控制MVCC" class="headerlink" title="4.5 多版本并发控制MVCC"></a>4.5 多版本并发控制MVCC</h2><blockquote>
<p>[1] 此小节参考了 <strong>yes的练级攻略</strong> 的文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/401CeXbEK27pX9dFOOHDnA">关于MySQL的酸与MVCC和面试官小战三十回合</a> 文章幽默有趣、讲的比较深入又十分易懂</p>
</blockquote>
<h3 id="4-5-1-什么是MVCC"><a href="#4-5-1-什么是MVCC" class="headerlink" title="4.5.1 什么是MVCC?"></a>4.5.1 什么是MVCC?</h3><p>多版本并发控制（Multi-Version  Concurrency Control ）。指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。</p>
<p>这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞，写操作可以继续写，无非就是多加了一个版本，历史版本记录可供已经启动的事务读取。</p>
<p>（为保持简短，简化了SQL语句，下文也同样简化）</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212817" alt="图片" style="zoom: 80%;">

<h3 id="4-5-2-MVCC有什么用？"><a href="#4-5-2-MVCC有什么用？" class="headerlink" title="4.5.2 MVCC有什么用？"></a>4.5.2 MVCC有什么用？</h3><p>MVCC 主要可以提高了事务的并发度，提升数据库的性能。</p>
<p>如果是读未提交的话，直接读最新版本的数据就行了，压根就不需要保存以前的版本。可串行化隔离级别事务都串行执行了，所以也不需要多版本，<strong>因此 MVCC 是用来实现读已提交和可重复读的。</strong></p>
<ul>
<li><p>对于<strong>读已提交</strong>：规定只有在写事务只有提交之后，才可以读，不然可能会出现脏读的问题。但是如果有MVCC保存多版本的数据的话、如果A事务在修改时，另一个事务B仍然可以读取旧版本的数据。这样读写就不会阻塞了，提高了事务的并发度。（如果没有的话事务B就会阻塞）</p>
</li>
<li><p>对于<strong>可重复读</strong>，MVCC可以和gap间隙锁来防止幻读。（没有MVCC在RR隔离级别下可能出现幻读）</p>
</li>
</ul>
<h3 id="4-5-3-MVCC的实现原理？"><a href="#4-5-3-MVCC的实现原理？" class="headerlink" title="4.5.3 MVCC的实现原理？"></a>4.5.3 MVCC的实现原理？</h3><p>MVCC其实没有存多个版本的数据，索引上对应的记录只有一个版本，但是利用undo日志可以获得之前版本的数据，类似通过undo日志、形成了一个版本链，看起来是多个版本！！</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212820" alt="图片" style="zoom: 67%;">

<p>举个栗子：三条命令：</p>
<p>1 一个事务ID为1的事务执行 <code>insert （1，XX）</code>语句执行，并提交</p>
<p>2 一个事务ID为5的事务执行 <code>update NO where id 1</code> 语句执行，并提交</p>
<p>3 一个事务ID为11 的事务执行 <code>update Yes where id 1</code> 这个语句，并提交</p>
<p>最后id=1的这行数据字段分别为（1，Yes)，同时还有 trx_id （当前事务ID）和 roll_pointer(指向undo日志的指针) 这两个隐藏字段。其版本链如下：</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212823" alt="图片" style="zoom:67%;">

<p>多个版本链还涉及到一个重要的问题，就是当前版本的数据应该对哪些事务可见?</p>
<blockquote>
<p>一个原则就是 未提交的数据是不可见的，已提交还未修改的数据是可见的。</p>
<p>可见版本的判断是从最新版本开始沿着版本链逐渐寻找老的版本，如果遇到符合条件的版本就返回。（因为事务的id是随开始事务的时间而递增的）</p>
</blockquote>
<p><strong>readView 用来判断哪个版本对当前事务可见的</strong>，其判断涉及到四个字段值：</p>
<ul>
<li>creator_trx_id，当前事务ID。</li>
<li>m_ids，生成 readView 时还活跃的事务ID集合，也就是已经启动但是还未提交的事务ID列表。</li>
<li>min_trx_id，当前活跃ID之中的最小值。</li>
<li>max_trx_id，生成 readView 时 InnoDB 将分配给下一个事务的 ID 的值（事务 ID 是递增分配的，越后面申请的事务ID越大）</li>
</ul>
<p><strong>判断条件如下：</strong></p>
<ul>
<li>如果当前数据版本的 trx_id ==  creator_trx_id 说明修改这条数据的事务就是当前事务，所以可见。</li>
<li>如果当前数据版本的 trx_id &lt; min_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候已提交，所以可见。</li>
<li>如果当前数据版本的 trx_id 在 m_ids 中，说明修改这条数据的事务此时还未提交，所以不可见。（还活跃的事务，即未提交，所以不可见）</li>
<li>如果当前数据版本的 trx_id &gt;= max_trx_id，说明修改这条数据的事务在当前事务生成 readView 的时候还未启动，所以不可见(结合事务ID递增来看)。</li>
</ul>
<h3 id="4-5-4-可重复读下的MVCC"><a href="#4-5-4-可重复读下的MVCC" class="headerlink" title="4.5.4 可重复读下的MVCC"></a>4.5.4 可重复读下的MVCC</h3><blockquote>
<p>其实需要先讲一下：读已提交隔离级别下的MVCC，比较简单，一笔带过：</p>
<p>总是读取到最近的一个已提交的数据，如果两次读取中，有另一个事务提交了，那么第二次读取将会读取到新提交的数据。存在<strong>不可重复读</strong>的并发问题。</p>
</blockquote>
<p>读已提交每次查询都会重新生成一个新的 readView ，而可重复读在第一次生成  readView 之后的所有查询都共用同一个 readView 。</p>
<p>也就是说可重复读只会在第一次 select 时候生成一个 readView ，所以一个事务里面不论有几次 select ，其实看到的都是同一个 readView 。</p>
<p>因为两次查询用的是同一个readView ，所以不管新事务有没有提交，仍认为它没有提交，查到的还是那个老版本的数据！！所以是可重复读的！！</p>
<p> undolog 算是热点资源，多个事务会争抢 undolog 。所以为了提高 undolog 的写入性能，每个事务都有属于自己的 undolog 页面链表</p>
<h1 id="5-其他知识点"><a href="#5-其他知识点" class="headerlink" title="5 其他知识点"></a>5 其他知识点</h1><h2 id="5-1-不同存储引擎的区别"><a href="#5-1-不同存储引擎的区别" class="headerlink" title="5.1 不同存储引擎的区别"></a>5.1 不同存储引擎的区别</h2><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，MySQL 5.5 版本后默认的存储引擎为 InnoDB。</p>
<p>InnoDB 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p><strong>InnoDB 和MyISAM 的对比</strong></p>
<ul>
<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。（InnoDB 有redo日志！！）</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h2 id="5-2-关系型数据库和非关系型数据库的区别"><a href="#5-2-关系型数据库和非关系型数据库的区别" class="headerlink" title="5.2 关系型数据库和非关系型数据库的区别"></a>5.2 关系型数据库和非关系型数据库的区别</h2><ul>
<li><p>关系型数据库：</p>
<ul>
<li><p>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点</p>
</li>
<li><p>关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差</p>
</li>
<li><p>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性较差</p>
</li>
</ul>
</li>
<li><p>非关系型数据库</p>
<ul>
<li><p>指非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统</p>
</li>
<li><p>面向高性能并发读写的key-value数据库</p>
</li>
<li><p>面向可扩展性的分布式数据库</p>
</li>
</ul>
</li>
</ul>
<p>数据的持久存储，尤其是海量数据的持久存储，使用的更多的还是关系数据库</p>
<h2 id="5-3-复合索引的最左前缀原则"><a href="#5-3-复合索引的最左前缀原则" class="headerlink" title="5.3 复合索引的最左前缀原则"></a>5.3 复合索引的最左前缀原则</h2><blockquote>
<p>最左前缀法则：带头大哥不能死、中间兄弟不能断；如果是全值匹配查询时，顺序无所谓；</p>
<p>参考了神文<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41917109/article/details/88944290">Mysql最左匹配原则</a> 写的真是太好了</p>
</blockquote>
<p>索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p>
<img src="https://blog-figure.oss-cn-hangzhou.aliyuncs.com//img/20211112212828.png" alt="img" style="zoom:67%;">

<p>也就是说：索引a的值是有序的，而只有在a相等的情况下b才是有序的。如果单独查b，只能全表找b，没办法二分索引找到b。</p>
<p><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p>
<p><strong>1 全值匹配查询时–用到了索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line">select * from table_name where b &#x3D; &#39;2&#39; and a &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line">select * from table_name where c &#x3D; &#39;3&#39; and b &#x3D; &#39;2&#39; and a &#x3D; &#39;1&#39; </span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><strong>2 匹配左边的列时—只有从第一个开始才能用到索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 如果都从最左边开始连续匹配，用到了索引</span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39;  </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and b &#x3D; &#39;2&#39; and c &#x3D; &#39;3&#39;</span><br><span class="line"># 这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 </span><br><span class="line">select * from table_name where  b &#x3D; &#39;2&#39; </span><br><span class="line">select * from table_name where  c &#x3D; &#39;3&#39;</span><br><span class="line">select * from table_name where  b &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br><span class="line"># 如果不连续时，只用到了a列的索引，b列和c列都没有用到 </span><br><span class="line">select * from table_name where a &#x3D; &#39;1&#39; and c &#x3D; &#39;3&#39; </span><br></pre></td></tr></table></figure>

<p> <strong>3 匹配列前缀</strong>：如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where a like &#39;As%&#39;; &#x2F;&#x2F;前缀都是排好序的，走索引查询</span><br><span class="line">select * from table_name where  a like &#39;%As&#39;&#x2F;&#x2F;全表查询</span><br><span class="line">select * from table_name where  a like &#39;%As%&#39;&#x2F;&#x2F;全表查询</span><br></pre></td></tr></table></figure>


    </div>

    <div>
      
          
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------感谢阅读<i class="fa fa-paw"></i>没事常来-------------
        </div>
    
</div>
      
    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/19/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83_01_%E9%98%BF%E9%87%8Cjava%E8%A7%84%E8%8C%83/" rel="prev" title="阿里java规范（泰山版）">
      <i class="fa fa-chevron-left"></i> 阿里java规范（泰山版）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93_01_mysql%E8%AF%AD%E6%B3%95&%E7%BB%83%E4%B9%A0/" rel="next" title="mysql语法&练习">
      mysql语法&练习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">1 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 索引的定义、使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%B4%A2%E5%BC%95%E6%8C%89%E5%BA%94%E7%94%A8%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 索引按应用层次分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 索引的底层实现（数据结构）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">hash索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8DB%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.</span> <span class="nav-text">两种B树索引的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 索引存储位置的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 聚集索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 非聚集索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E8%A6%81%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3 非聚集索引一定要回表查询？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 创建索引的注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-MySQL%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">2 MySQL的基础架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 MySQL 基本架构概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 查询语句分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 更新语句分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">3 数据库的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-InnoDB%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 InnoDB锁的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-S-or-X-%EF%BC%88%E8%A1%8C%E9%94%81%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.3.1 S or X （行锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-IS-or-IX%EF%BC%88%E6%84%8F%E5%90%91%E9%94%81-%E8%A1%A8%E9%94%81%EF%BC%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.3.2 IS or IX（意向锁\表锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E8%87%AA%E5%A2%9E%E9%95%BF%E9%94%81%EF%BC%88%E8%BF%98%E6%98%AF%E6%9C%89%E7%82%B9%E6%B2%A1%E7%9C%8B%E6%87%82%EF%BC%89"><span class="nav-number">3.1.3.</span> <span class="nav-text">2.3.3 自增长锁（还是有点没看懂）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-InnoDB%E9%94%81%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 InnoDB锁算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%AE%B0%E5%BD%95%E9%94%81-Record-Lock"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.4.1 记录锁(Record-Lock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88gap%E9%94%81%EF%BC%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.4.2 间隙锁（gap锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-next-key%E9%94%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 next-key锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 插入意向锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%8A%A0%E9%94%81%E5%AE%9E%E9%AA%8C"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 加锁实验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 解决项目中的死锁问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">4 事务和隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 事务日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-redo%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 redo日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-undo%E6%97%A5%E5%BF%97"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 undo日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 事务并发控制带来的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 事务的隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6MVCC"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 多版本并发控制MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1 什么是MVCC?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-MVCC%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2 MVCC有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">4.5.3.</span> <span class="nav-text">4.5.3 MVCC的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8B%E7%9A%84MVCC"><span class="nav-number">4.5.4.</span> <span class="nav-text">4.5.4 可重复读下的MVCC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">5 其他知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 不同存储引擎的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 关系型数据库和非关系型数据库的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 复合索引的最左前缀原则</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wu kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu kang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
