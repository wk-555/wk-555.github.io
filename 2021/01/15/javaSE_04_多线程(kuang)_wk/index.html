<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wukang555.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1、实现多线程：三种实现方式、线程优先级2.、线程的状态和控制：线程的生命周期、线程的状态控制函数3.、线程同步：买票问题、synchronized关键字和ReentrantLock可重入锁4、 线程通信：生产者消费者案例5、线程池：线程池的简单使用6、静态代理：线程实现的底层模式7、 lambda表达式：简单使用">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程笔记（狂神）">
<meta property="og:url" content="https://wukang555.github.io/2021/01/15/javaSE_04_%E5%A4%9A%E7%BA%BF%E7%A8%8B(kuang)_wk/index.html">
<meta property="og:site_name" content="落风的风">
<meta property="og:description" content="1、实现多线程：三种实现方式、线程优先级2.、线程的状态和控制：线程的生命周期、线程的状态控制函数3.、线程同步：买票问题、synchronized关键字和ReentrantLock可重入锁4、 线程通信：生产者消费者案例5、线程池：线程池的简单使用6、静态代理：线程实现的底层模式7、 lambda表达式：简单使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205931.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205951.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205953.png">
<meta property="article:published_time" content="2021-01-15T14:55:00.000Z">
<meta property="article:modified_time" content="2021-11-12T13:45:42.213Z">
<meta property="article:author" content="Wu kang">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205931.jpg">

<link rel="canonical" href="https://wukang555.github.io/2021/01/15/javaSE_04_%E5%A4%9A%E7%BA%BF%E7%A8%8B(kuang)_wk/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>多线程笔记（狂神） | 落风的风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="落风的风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落风的风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://wukang555.github.io/2021/01/15/javaSE_04_%E5%A4%9A%E7%BA%BF%E7%A8%8B(kuang)_wk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wu kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落风的风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程笔记（狂神）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-15 22:55:00" itemprop="dateCreated datePublished" datetime="2021-01-15T22:55:00+08:00">2021-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-12 21:45:42" itemprop="dateModified" datetime="2021-11-12T21:45:42+08:00">2021-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8B%82%E7%A5%9E/" itemprop="url" rel="index"><span itemprop="name">狂神</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>1、实现多线程：三种实现方式、线程优先级<br>2.、线程的状态和控制：线程的生命周期、线程的状态控制函数<br>3.、线程同步：买票问题、synchronized关键字和ReentrantLock可重入锁<br>4、 线程通信：生产者消费者案例<br>5、线程池：线程池的简单使用<br>6、静态代理：线程实现的底层模式<br>7、 lambda表达式：简单使用</p>
<a id="more"></a>

<h2 id="1-实现多线程"><a href="#1-实现多线程" class="headerlink" title="1. 实现多线程"></a>1. 实现多线程</h2><h3 id="1-1进程和线程的区别【背诵】"><a href="#1-1进程和线程的区别【背诵】" class="headerlink" title="1.1进程和线程的区别【背诵】"></a>1.1进程和线程的区别【背诵】</h3><p>进程：是正在运行的程序。是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。线程：是CPU调度和分派的基本单位。它可与同属一个进程的其他的线程共享进程所拥有的全部资源。区别如下：<br>        1、根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位<br>        2、开销方面：<strong>进程之间切换开销大</strong>，<strong>线程之间切换的开销小</strong>。<br>        3、所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）<br>        4、内存分配：系统为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存。线程组之间只能共享资源。<br>        5、包含关系：线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<h3 id="1-2实现多线程：继承Thread类-【应用-】"><a href="#1-2实现多线程：继承Thread类-【应用-】" class="headerlink" title="1.2实现多线程：继承Thread类 【应用 】"></a>1.2实现多线程：继承Thread类 【应用 】</h3><p><strong>实现步骤：</strong></p>
<ol>
<li><p>定义一个类MyThread继承Thread类</p>
</li>
<li><p>在MyThread类中重写run()方法</p>
</li>
<li><p>创建MyThread类的对象</p>
</li>
<li><p>启动线程</p>
</li>
</ol>
<p><strong>run()方法和start()方法的区别：</strong></p>
<ul>
<li>调用run()方法，是串行执行，先执行完run方法体中的所有内容、再执行后面的命令</li>
<li>调用start()方法，是多线程执行，轮流交替的执行</li>
</ul>
<p><strong>实现代码：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThreadDemo类 执行多线程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果显示两个线程交替执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        MyThread my3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">        my3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MyThread类 继承Thread类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3实现多线程：实现Runnable接口【应用】"><a href="#1-3实现多线程：实现Runnable接口【应用】" class="headerlink" title="1.3实现多线程：实现Runnable接口【应用】"></a>1.3实现多线程：实现Runnable接口【应用】</h3><p><strong>实现步骤</strong></p>
<ol>
<li>定义一个类MyRunnable实现Runnable接口</li>
<li>在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li>
<li>启动线程</li>
</ol>
<p>Thread的构造方法</p>
<ul>
<li>Thread(Runnable target) 分配一个新的Thread对象</li>
<li>Thread(Runnable target, String name) 分配一个新的Thread对象、并命名</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRun = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">// 分配一个新的Thread对象、并命名</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myRun,<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myRun,<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//输出线程名和序号i</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Runnable接口的优点</strong></p>
<ol>
<li>接口可以实现多个，避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ol>
<h3 id="1-4实现多线程：实现-Callable接口【了解】"><a href="#1-4实现多线程：实现-Callable接口【了解】" class="headerlink" title="1.4实现多线程：实现 Callable接口【了解】"></a>1.4实现多线程：实现 Callable接口【了解】</h3><p><strong>实现步骤</strong></p>
<ol>
<li>定义一个类Mycallable类，重写call方法，有返回值</li>
<li>定一个测试类，创建Mycallable类的对象myCallable</li>
<li>使用FutureTask来包装Callable对象，得到task对象</li>
<li>使用task对象 创建线程Thread(task,”name”)</li>
<li>启动线程，还可以获得线程最后的返回值</li>
</ol>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCallable myCallable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 使用FutureTask来包装Callable对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task1 = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallable);</span><br><span class="line">        FutureTask&lt;Integer&gt; task2 = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(myCallable);</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(task1,<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(task2,<span class="string">&quot;火车&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//可以获取返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread1.getName()+task1.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现Callable接口的优点</strong></p>
<ol>
<li>接口可以实现多个，避免了Java单继承的局限性</li>
<li>可以有返回值，可以抛出异常</li>
</ol>
<h3 id="1-5设置和获取线程名称-【应用】"><a href="#1-5设置和获取线程名称-【应用】" class="headerlink" title="1.5设置和获取线程名称 【应用】"></a>1.5设置和获取线程名称 【应用】</h3><p>Thread类中设置和获取线程名称的方法</p>
<ul>
<li><p>void setName(String name) 将此线程的名称更改为等于参数name</p>
</li>
<li><p>String getName() 返回此线程的名称</p>
</li>
<li><p>获取main()方法所在的线程名称</p>
<ul>
<li>Thread currentThread() 返回对当前正在执行的线程对象的引用</li>
</ul>
</li>
</ul>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my1.setName(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        my2.setName(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"><span class="comment">//        MyThread my1 = new MyThread(&quot;高铁&quot;);</span></span><br><span class="line"><span class="comment">//        MyThread my2 = new MyThread(&quot;飞机&quot;);</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-6线程优先级【应用】"><a href="#1-6线程优先级【应用】" class="headerlink" title="1.6线程优先级【应用】"></a>1.6线程优先级【应用】</h3><p><strong>线程调度</strong></p>
<ul>
<li><p>两种调度方式</p>
<ul>
<li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些**(java采用这种)**</li>
</ul>
</li>
<li><p>随机性</p>
<ul>
<li>假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</li>
</ul>
</li>
<li><p>优先级相关方法</p>
<ul>
<li><p><code>final int getPriority()</code> 返回此线程的优先级</p>
</li>
<li><p><code>final void setPriority(intnewPriority)</code>更改此线程的优先级 线程默认优先级是5；线程优先级的范围是：1-10</p>
</li>
<li><p>线程优先级高仅仅表示获取cpu时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的结果，，跑了几次，感觉随机性太大</p>
</li>
</ul>
</li>
</ul>
<p><strong>示例代码</strong></p>
<p>各跑5000次效果依然很随机、cpu太快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPriority tp = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(tp, <span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(tp, <span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(tp, <span class="string">&quot;自行车&quot;</span>);</span><br><span class="line">        <span class="comment">//public final void setPriority(int newPriority)：更改此线程的优先级</span></span><br><span class="line">        th1.setPriority(<span class="number">4</span>);</span><br><span class="line">        th2.setPriority(<span class="number">10</span>);</span><br><span class="line">        th3.setPriority(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//public final int getPriority()：返回此线程的优先级</span></span><br><span class="line">        System.out.println(th1.getPriority());</span><br><span class="line">        System.out.println(th2.getPriority());</span><br><span class="line">        System.out.println(th3.getPriority());</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-线程的状态和控制"><a href="#2-线程的状态和控制" class="headerlink" title="2. 线程的状态和控制"></a>2. 线程的状态和控制</h2><h3 id="2-1线程的生命周期【背诵】"><a href="#2-1线程的生命周期【背诵】" class="headerlink" title="2.1线程的生命周期【背诵】"></a>2.1线程的生命周期【背诵】</h3><p><strong>线程的五种状态</strong></p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205931.jpg" alt="img" style="zoom:80%;">

<p><strong>线程的常用方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>sleep(longmillisec)</code></td>
<td align="left"><em>休眠，在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</em></td>
</tr>
<tr>
<td align="left"><code>join()</code></td>
<td align="left"><em>执行，指定某一个线程执行完毕后，再执行其他线程</em>，也可以指定时常</td>
</tr>
<tr>
<td align="left"><code>yield()</code></td>
<td align="left"><em>谦让，暂停当前正在执行的线程对象，并执行其他线程。也会争夺cpu</em></td>
</tr>
<tr>
<td align="left"><del>`suspend()</del>`</td>
<td align="left"><del>挂起，不推荐使用suspend()去挂起线程的原因，是因为suspend()在导致线程暂停的同时，并不会 去释放任何锁资源。</del></td>
</tr>
<tr>
<td align="left"><del>`resume()</del>`</td>
<td align="left"><del>继续执行</del></td>
</tr>
<tr>
<td align="left"><del>`stop()</del>`</td>
<td align="left"><del>终止线程，不建议使用<code>Thread.stop()</code>方法，因为stop()会直接终止线程，并释放所有锁，如果释放了维持对象一致性的锁，就可能导致对象被写坏</del></td>
</tr>
<tr>
<td align="left"><code>setDaemon(boolean on)</code></td>
<td align="left"><em>将此线程标记为守护线程</em></td>
</tr>
<tr>
<td align="left"><code>Obj.wait()</code></td>
<td align="left"><em>等待，停止继续执行，而转为等待状态</em></td>
</tr>
<tr>
<td align="left"><code>Obj.notify()</code></td>
<td align="left"><em>通知，通知等待的线程执行</em></td>
</tr>
</tbody></table>
<p><strong>Sleep()和wait()的区别</strong></p>
<ol>
<li><code>wait</code>只能在同步（synchronize）环境中被调用，而sleep不需要。</li>
<li><code>wait</code>方法在进入<code>wait</code>状态的时候会释放对象的锁，但是sleep方法不会。</li>
<li>进入<code>wait</code>状态的线程能够被<code>notify</code>和<code>notifyAll</code>线程唤醒，sleep状态的线程指定确定的时间。</li>
</ol>
<h3 id="2-2-sleep-方法"><a href="#2-2-sleep-方法" class="headerlink" title="2.2 sleep()方法"></a>2.2 sleep()方法</h3><p>特点：</p>
<ul>
<li>sleep(时间）指定当前线程阻塞的毫秒数；</li>
<li>sleep 存在异常<code>InterruptedException</code>；</li>
<li>sleep时间达到后线程进入就绪状态；</li>
<li>sleep可以模拟网络延时；</li>
<li><strong>每一个对象都有一个锁，sleep不会释放锁。</strong></li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(ts1, <span class="string">&quot;曹操&quot;</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(ts1, <span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(ts1, <span class="string">&quot;孙权&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="comment">//sleep()方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-join-方法"><a href="#2-3-join-方法" class="headerlink" title="2.3 join()方法"></a>2.3 join()方法</h3><p>特点：</p>
<ul>
<li>用在主线程里面</li>
<li>指定某一个线程执行完毕后，再执行其他线程</li>
</ul>
<p><strong>代码示例：</strong></p>
<ul>
<li>康熙是爸爸，康熙执行完之后，四阿哥和八阿哥才能争夺皇位。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(tj1, <span class="string">&quot;康熙&quot;</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(tj1, <span class="string">&quot;四阿哥&quot;</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(tj1, <span class="string">&quot;八阿哥&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        <span class="comment">//调用join()方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            th1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-yield-方法"><a href="#2-4-yield-方法" class="headerlink" title="2.4 yield()方法"></a>2.4 yield()方法</h3><p>特点：</p>
<ul>
<li>礼让线程在释放cpu之后进入就绪队列，但依然会竞争cpu。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;线程开始执行。&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程停止执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 礼让成功</span></span><br><span class="line"><span class="comment">//A线程开始执行。</span></span><br><span class="line"><span class="comment">//B线程开始执行。</span></span><br><span class="line"><span class="comment">//B线程停止执行。</span></span><br><span class="line"><span class="comment">//A线程停止执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//礼让不一定成</span></span><br><span class="line"><span class="comment">//B线程开始执行。</span></span><br><span class="line"><span class="comment">//A线程开始执行。</span></span><br><span class="line"><span class="comment">//B线程停止执行。</span></span><br><span class="line"><span class="comment">//A线程停止执行。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-setDaemon-boolean-flag-方法"><a href="#2-5-setDaemon-boolean-flag-方法" class="headerlink" title="2.5 setDaemon(boolean flag)方法"></a>2.5 setDaemon(boolean flag)方法</h3><p>特点：</p>
<ul>
<li>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出,即，主线程完成后，守护线程相继终止（自动）</li>
</ul>
<p><strong>代码示例：</strong></p>
<p>当刘备（主线程）执行完毕后，守护线程：关羽、张飞，会自动相继退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(td1, <span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(td1, <span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">        <span class="comment">//设置主线程（也就是当前线程）的名字</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">        <span class="comment">//设置为守护线程</span></span><br><span class="line">        th1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        th2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//执行线程</span></span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        <span class="comment">//主线程循环输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">21</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a>3. 线程同步</h2><h3 id="3-1卖票的同步问题"><a href="#3-1卖票的同步问题" class="headerlink" title="3.1卖票的同步问题"></a>3.1卖票的同步问题</h3><p><strong>需求</strong>：某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，程序模拟该电影院卖票。</p>
<p><strong>思路</strong>：</p>
<ul>
<li>1:定义一个类<code>SellTicket</code>实现Runnable接口，里面定义一个成员变量：<code>private int tickets = 100;</code></li>
<li>2:在<code>SellTicket</code>类中重写run()方法实现卖票，代码步骤如下<ul>
<li>A:判断票数大于0，就卖票，并告知是哪个窗口卖的</li>
<li>B:卖了票之后，总票数要减1 </li>
<li>C:票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行</li>
</ul>
</li>
<li>3:定义一个测试类<code>SellTicketDemo</code>，里面有main方法，代码步骤如下<ul>
<li>A:创建SellTicket类的对象</li>
<li>B:创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</li>
<li>C:启动线程</li>
</ul>
</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(st,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正出售第&quot;</span> + (<span class="number">101</span> - tickets) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可能出现的问题</span></span><br><span class="line"><span class="comment">//相同的票出现多次</span></span><br><span class="line"><span class="comment">//出现负数的票（票卖多了）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-线程同步方案的两种锁"><a href="#3-2-线程同步方案的两种锁" class="headerlink" title="3.2 线程同步方案的两种锁"></a>3.2 线程同步方案的两种锁</h3><p><strong>安全问题出现的条件有：</strong><br>            1.是多线程环境；2.有共享数据；3.有多条语句操作共享数据；</p>
<p><strong>解决线程安全的问题：</strong><br>            让程序没有安全问题的环境。主要是针对第三条：锁上多条语句操作的共享数据。<br>​            java提供两种锁机制来实现同步：synchronized关键字、ReentrantLock可重入锁</p>
<p><strong>使用同步方法的利弊：</strong><br>            好处：解决了多线程的数据安全问题<br>            弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p>
<p><strong>synchronized关键字：</strong></p>
<ul>
<li><p>实现线程之间的同步，对同步的代码加锁，使得每一次、只有一个线程能进入同步块。</p>
</li>
<li><p>三种作用范围：</p>
<ul>
<li>指定加锁的对象：给指定的对象加锁——锁当前对象</li>
<li>直接作用于实例方法：对当前实例加锁——锁当前方法</li>
<li>直接所用于静态方法：对当前的类加锁——锁整个实例对象</li>
</ul>
</li>
</ul>
<p><strong>ReentrantLock可重入锁：</strong></p>
<ul>
<li>实现lock接口，扩展了synchronized得一些功能</li>
<li>一些特点<ul>
<li>显示的操作，手动加锁、释放锁</li>
<li>一个线程内可以重复加锁</li>
<li>提供中断处理得能力——锁等待限时 <code>tryLock()</code></li>
<li>可实现公平锁和非公平锁</li>
</ul>
</li>
</ul>
<p><strong><em>synchronized 和 Lock （ReentrantLock ）有什么区别？【背诵】</em></strong></p>
<ul>
<li>底层实现上来说<ul>
<li>synchronized 是JVM层面的锁，是Java关键字，synchronized 的实现涉及到锁的升级和优化，具体为无锁、偏向锁、轻量级锁、自旋锁等。</li>
<li>ReentrantLock 是从jdk1.5以来提供的API层面的锁。</li>
</ul>
</li>
<li>从锁的对象来说<ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
</ul>
</li>
<li>从操作步骤来说<ul>
<li>synchronized 不需要手动获取锁和释放锁，使用简单；</li>
<li>lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
</ul>
</li>
<li>ReentrantLock具有更多得功能<ul>
<li>ReentrantLock则可以设置中断，可通过<code>trylock(long timeout,TimeUnit unit)</code>设置超时方法；</li>
<li>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法<code>new ReentrantLock</code>时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</li>
<li>ReentrantLock通过绑定Conditiont条件结合<code>await()/singal()</code>方法实现线程的精确唤醒</li>
</ul>
</li>
</ul>
<p>​    </p>
<h3 id="3-3-synchronized关键字"><a href="#3-3-synchronized关键字" class="headerlink" title="3.3 synchronized关键字"></a>3.3 synchronized关键字</h3><p><strong>synchronized锁对象</strong></p>
<p>先定义一个obj对象，将要同步的代码块放在<code>synchronized(obj)&#123;&#125;</code>的括号里面。**<code>sleep()</code>方法一定要放在锁外面，才能生效。**</p>
<p>锁的对象必须是需要做增删改查的对象！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="comment">//synchronized(任意对象) &#123;</span></span><br><span class="line"><span class="comment">//多条语句操作共享数据的代码</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有点小问题 只有一个窗口买到票</span></span><br></pre></td></tr></table></figure>

<p><strong>synchronized锁实例方法</strong></p>
<p>就是把synchronized关键字加到方法上 ,格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            sellTickets();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//定义一个sellTickets()同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTickets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized锁静态方法</strong></p>
<p>就是把synchronized关键字加到静态方法上 ,格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            sellTickets();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//定义一个sellTickets()同步静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTickets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4ReentrantLock可重入锁"><a href="#3-4ReentrantLock可重入锁" class="headerlink" title="3.4ReentrantLock可重入锁"></a><strong>3.4ReentrantLock可重入锁</strong></h3><p><strong>ReentrantLock几个重要的方法</strong></p>
<ul>
<li><code>lock()</code>:获得锁，如果锁已经被占用，则等待。</li>
<li><code>lockInterruptibly()</code>: 获得锁，但优先响应中断。</li>
<li><code>tryLock()</code>: 尝试获得锁，如果成功，返回true，失败返回false。该方法不等待，立即返回。</li>
<li><code>tryLock(long time, TimeUnit unit)</code> :在给定时间内尝试获得锁。</li>
<li><code>unlock()</code>:释放锁</li>
</ul>
<p><strong>使用步骤：</strong></p>
<ol>
<li>使用<code>ReentrantLock() </code>创建一个<code>ReentrantLock</code>的实例；</li>
<li>将<code>lock()</code>和 <code>unlock()</code>放在需要同步的代码块的首位；</li>
<li>为了解锁操作一定会执行，这里使用<code> try()&#123;&#125; finally&#123;&#125;</code>方法；</li>
<li><strong><code>sleep()</code>方法一定要放在锁外面，才能生效</strong></li>
</ol>
<p><strong>实例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-线程通信"><a href="#4-线程通信" class="headerlink" title="4. 线程通信"></a>4. 线程通信</h2><p>线程通信的方式：</p>
<ul>
<li><code>wait() </code>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</li>
<li><code>wait(long timeout)</code> 指定等待的毫秒数</li>
<li><code>notify()</code> 唤醒一个处于等待状态的线程</li>
<li><code>notifyAll() </code>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程先调度</li>
</ul>
<p><strong>注：上述方法都是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出<code>IIIegalMonitorSateException</code>异常.</strong></p>
<h3 id="4-1-生产者消费者（管程法）"><a href="#4-1-生产者消费者（管程法）" class="headerlink" title="4.1 生产者消费者（管程法）"></a>4.1 生产者消费者（管程法）</h3><p>生产者消费者模型是一个并发协作的模型：</p>
<ul>
<li><p><strong>生产者：</strong>负责生产数据的模块（可能是方法、对象、线程、进程）</p>
</li>
<li><p><strong>消费者：</strong>负责处理数据的模块（可能是方法、对象、线程、进程）</p>
</li>
<li><p><strong>缓冲区（仓库）：</strong>消费者和生产者之间通信的桥梁，生产者将生产好的产品放入缓冲区，消费者从缓冲区中取出产品。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试：生产者消费者模型--&gt;管程法</span></span><br><span class="line"><span class="comment">//生产者、消费者、缓冲区、产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> Product(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了&quot;</span>+i+<span class="string">&quot;个产品。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了---&gt;&quot;</span>+container.pop().id+<span class="string">&quot;个产品。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Product[] products = <span class="keyword">new</span> Product[<span class="number">10</span>];<span class="comment">//需要容器大小</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">//容器计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Product product)</span></span>&#123;<span class="comment">//生产者放入产品</span></span><br><span class="line">        <span class="keyword">if</span>(count==products.length)&#123; <span class="comment">//如果缓冲区满了，就需要等待消费者消费</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();<span class="comment">//生产者等待下一次生产</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有满，就继续生产产品</span></span><br><span class="line">        products[count] = product;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();<span class="comment">// 可以通知消费者消费了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        Product product = products[count];</span><br><span class="line">        <span class="comment">//消费了之后，就可以通知生产者继续生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line">        <span class="keyword">new</span> Producer(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-生产者消费者（信号灯法）"><a href="#4-2-生产者消费者（信号灯法）" class="headerlink" title="4.2 生产者消费者（信号灯法）"></a>4.2 生产者消费者（信号灯法）</h3><p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库：生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为。</p>
<p>（先把代码放出来、以后再看需不需要深究。）</p>
<p>1:奶箱类(Box)：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//放牛奶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putMilk</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.number=number;</span><br><span class="line">        System.out.println(<span class="string">&quot;送奶工投递第&quot;</span>+<span class="keyword">this</span>.number+<span class="string">&quot;瓶牛奶&quot;</span>);</span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//唤醒其他线程</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//取牛奶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getMilk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!state)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户拿到第&quot;</span>+<span class="keyword">this</span>.number+<span class="string">&quot;瓶牛奶&quot;</span>);</span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2:生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box=box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">            box.putMilk(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3:消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Custromer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custromer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box=box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            box.getMilk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4:测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下</p>
<ul>
<li>A:创建奶箱对象，这是共享数据区域</li>
<li>B:创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</li>
<li>C:创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</li>
<li>D:创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</li>
<li>E:启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(box);</span><br><span class="line">        Custromer c = <span class="keyword">new</span> Custromer(box);</span><br><span class="line"></span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(c);</span><br><span class="line"></span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//送奶工投递第1瓶牛奶</span></span><br><span class="line"><span class="comment">//用户拿到第1瓶牛奶</span></span><br><span class="line"><span class="comment">//送奶工投递第2瓶牛奶</span></span><br><span class="line"><span class="comment">//用户拿到第2瓶牛奶</span></span><br><span class="line"><span class="comment">//送奶工投递第3瓶牛奶</span></span><br><span class="line"><span class="comment">//用户拿到第3瓶牛奶</span></span><br></pre></td></tr></table></figure>

<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h2><h3 id="5-1-线程池介绍"><a href="#5-1-线程池介绍" class="headerlink" title="5.1 线程池介绍"></a>5.1 线程池介绍</h3><p>思路</p>
<ul>
<li>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。</li>
<li>将活跃的线程放入线程池中，方便取用</li>
<li>创建线程——从线程池中获得空闲线程</li>
<li>关闭线程——向池子归还线程</li>
</ul>
<p>好处：</p>
<ul>
<li><p>提高响应速度、减少了创建新线程的时间</p>
</li>
<li><p>降低资源消耗、重复利用线程池中的线程，不需要每次都创建</p>
</li>
<li><p>便于线程的管理</p>
<ul>
<li><code>corePoolSize</code> 核心池的大小</li>
<li><code>maximumPoolSize</code> 最大线程数</li>
<li><code>keepAliveTime</code>  当线程池线程数量超过<code>corePoolSize</code>时，多余的空闲线程的存活时间。 即，超过<code>corePoolSize</code>的空闲线程，在多长时间内，会被销毁。</li>
<li><strong><code>workQueue</code>: 任务队列，被提交但尚未被执行的任务。</strong></li>
<li><strong><code>handler</code>: 拒绝策略。当任务太多来不及处理，如何拒绝任务。</strong></li>
</ul>
</li>
</ul>
<p>线程的创建、执行和关闭</p>
<ul>
<li><p><code>ExecutorService service = Executors.newFixedThreadPool(10);</code></p>
</li>
<li><p><code>service.execute(new MyThread());</code></p>
</li>
<li><p><code>service.shutdown();</code></p>
</li>
</ul>
<p>线程创建的几种方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ExecutorService newFixedThreadPool(int nThreads)</code></td>
<td>返回一个固定线程数量的线程池。该线程池中的线 程数量始终不变。</td>
</tr>
<tr>
<td><code>ExecutorService newSingleThreadExecutor()</code></td>
<td>返回一个只有一个线程的线程池。</td>
</tr>
<tr>
<td><code>ExecutorService newCachedThreadPool()</code></td>
<td>该方法返回一个可根据实际情况调整线程数量的线程池。</td>
</tr>
<tr>
<td><code>ScheduledExecutorService newSingleThreadScheduledExecutor()</code></td>
<td>该方法返回一个 <code>ScheduledExecutorService</code> 对 象，线程池大小为 1。 扩展了 在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</td>
</tr>
<tr>
<td><code>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code></td>
<td>该方法也返回一个 <code>ScheduledExecutorService</code> 对象，但 该线程池可以指定线程数量。</td>
</tr>
</tbody></table>
<h3 id="5-2-线程池示例代码"><a href="#5-2-线程池示例代码" class="headerlink" title="5.2 线程池示例代码"></a>5.2 线程池示例代码</h3>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">// newFixedThreadPool(10); 参数是线程池的大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//pool-1-thread-1</span></span><br><span class="line"><span class="comment">//pool-1-thread-2</span></span><br><span class="line"><span class="comment">//pool-1-thread-3</span></span><br><span class="line"><span class="comment">//pool-1-thread-5</span></span><br><span class="line"><span class="comment">//pool-1-thread-4</span></span><br></pre></td></tr></table></figure>



<h2 id="6-静态代理——线程实现的底层模式"><a href="#6-静态代理——线程实现的底层模式" class="headerlink" title="6. 静态代理——线程实现的底层模式"></a>6. 静态代理——线程实现的底层模式</h2><h3 id="6-1-静态代理模式："><a href="#6-1-静态代理模式：" class="headerlink" title="6.1 静态代理模式："></a>6.1 静态代理模式：</h3><p>真实对象和代理对象都实现同一个接口，代理对象要代理真实角色。就和实现线程一样，真实对象和Thread都实现了Runnable接口，然后用<code>new Thread(myRun,&quot;飞机&quot;);</code>实现线程即是用Thread对象代理真实的<code>myRun</code>对象。</p>
<p><strong>静态代理的好处：</strong></p>
<ol>
<li><p>代理对象可以做很多真实对象做不了的事情</p>
</li>
<li><p>真实对象可专注做自己的事情</p>
</li>
</ol>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 人间四大喜事: 久旱逢甘霖,他乡遇故知,洞房花烛夜,金榜题名时</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nick要结婚了，超开心...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> You target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(You target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;       <span class="comment">//真实目标角色</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚之前，布置现场&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.target.happyMarry();   <span class="comment">//真实对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结婚之后，收尾款&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真实对象自己调方法</span></span><br><span class="line">        You nike = <span class="keyword">new</span> You();</span><br><span class="line">        nike.happyMarry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过代理帮你调方法</span></span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.happyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Nick要结婚了，超开心...</span></span><br><span class="line"><span class="comment">结婚之前，布置现场</span></span><br><span class="line"><span class="comment">Nick要结婚了，超开心...</span></span><br><span class="line"><span class="comment">结婚之后，收尾款</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2-线程中的静态代理分析"><a href="#6-2-线程中的静态代理分析" class="headerlink" title="6.2 线程中的静态代理分析"></a>6.2 线程中的静态代理分析</h3><p><strong>1.Thread类实现了Runable接口，**</strong>即Thread类相当于上文中的”婚庆公司”**</p>
<p><img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205951.png" alt="image"></p>
<p> <strong>2.我们写的类也是实现了Runnable接口，即我们写的类相当于上文中的”结婚人You”</strong></p>
<p><img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112205953.png" alt="image"></p>
<p> <strong>3.在实现了Runnable接口后通过代理类Thread对象完成线程的启动</strong></p>
<ul>
<li><p>在代理类Thread对象的创建中，声明了我们所写的实际对象，eg:”myRunnable”。</p>
</li>
<li><p>然后由Thread类协助我们完成这一系列的操作。</p>
</li>
<li><p>看似简单的start()背后，代理类Thread还帮助我们做了很多事。</p>
</li>
</ul>
<h2 id="7-lambda表达式"><a href="#7-lambda表达式" class="headerlink" title="7. lambda表达式"></a>7. lambda表达式</h2><p>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” 。</p>
<p><strong>Lambda 表达式</strong>，也可称为闭包。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。Lambda表达式可以替代以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。</p>
<p>Lambda表达式的使用前提：函数式接口，即有一个接口，接口中有且仅有一个抽象方法。</p>
<p><strong>lambda 表达式的语法格式如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 </span></span><br><span class="line"><span class="comment">代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>lambda 表达式省略规则：</strong></p>
<ul>
<li>参数类型可以省略。但是有多个参数的情况下，不能只省略一个</li>
<li>如果参数有且仅有一个，那么小括号可以省略</li>
<li>如果代码块的语句只有一条，可以省略大括号和分号，和return关键字</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">(<span class="keyword">int</span> a )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正文...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        ILove love1 = <span class="keyword">new</span> ILove() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I Love you： &quot;</span> + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        love1.love(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        ILove love2 = (<span class="keyword">int</span> a)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I Love you： &quot;</span> + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        love2.love(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去掉参数类型</span></span><br><span class="line">        ILove love3 = (a)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I Love you： &quot;</span> + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        love3.love(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ILove love4 = a-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I Love you： &quot;</span> + a);</span><br><span class="line">        &#125;;</span><br><span class="line">        love4.love(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  lambda表达只有一行代码，还可继续简化成下面的情况</span></span><br><span class="line">        ILove love5 = a-&gt;System.out.println(<span class="string">&quot;I Love you： &quot;</span> + a);</span><br><span class="line">        love5.love(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    <div>
      
          
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------感谢阅读<i class="fa fa-paw"></i>没事常来-------------
        </div>
    
</div>
      
    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/14/javaSE_03_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" rel="prev" title="Java基础之输入输出命令">
      <i class="fa fa-chevron-left"></i> Java基础之输入输出命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/16/javaSE_05_%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84(kuang)_wk/" rel="next" title="注解与反射笔记（狂神）">
      注解与反射笔记（狂神） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1. 实现多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%90%E8%83%8C%E8%AF%B5%E3%80%91"><span class="nav-number">1.1.</span> <span class="nav-text">1.1进程和线程的区别【背诵】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB-%E3%80%90%E5%BA%94%E7%94%A8-%E3%80%91"><span class="nav-number">1.2.</span> <span class="nav-text">1.2实现多线程：继承Thread类 【应用 】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91"><span class="nav-number">1.3.</span> <span class="nav-text">1.3实现多线程：实现Runnable接口【应用】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0-Callable%E6%8E%A5%E5%8F%A3%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-number">1.4.</span> <span class="nav-text">1.4实现多线程：实现 Callable接口【了解】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0-%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91"><span class="nav-number">1.5.</span> <span class="nav-text">1.5设置和获取线程名称 【应用】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%90%E5%BA%94%E7%94%A8%E3%80%91"><span class="nav-number">1.6.</span> <span class="nav-text">1.6线程优先级【应用】</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">2. 线程的状态和控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%90%E8%83%8C%E8%AF%B5%E3%80%91"><span class="nav-number">2.1.</span> <span class="nav-text">2.1线程的生命周期【背诵】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-sleep-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 sleep()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-join-%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 join()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-yield-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 yield()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-setDaemon-boolean-flag-%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 setDaemon(boolean flag)方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">3. 线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E5%8D%96%E7%A5%A8%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">3.1卖票的同步问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 线程同步方案的两种锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 synchronized关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4ReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text">3.4ReentrantLock可重入锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">4.</span> <span class="nav-text">4. 线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88%E7%AE%A1%E7%A8%8B%E6%B3%95%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 生产者消费者（管程法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88%E4%BF%A1%E5%8F%B7%E7%81%AF%E6%B3%95%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 生产者消费者（信号灯法）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.</span> <span class="nav-text">5. 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 线程池介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 线程池示例代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BA%95%E5%B1%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">6. 静态代理——线程实现的底层模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 静态代理模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 线程中的静态代理分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">7. lambda表达式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wu kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu kang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
