<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wukang555.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。” “十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划-力扣题解">
<meta property="og:url" content="https://wukang555.github.io/2021/11/28/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E5%89%AF%E6%9C%AC/index.html">
<meta property="og:site_name" content="落风的风">
<meta property="og:description" content="“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。” “十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202814.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202815.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202816.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202817.jpg">
<meta property="article:published_time" content="2021-11-28T14:55:00.000Z">
<meta property="article:modified_time" content="2021-11-08T12:02:54.090Z">
<meta property="article:author" content="Wu kang">
<meta property="article:tag" content="力扣">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202814.png">

<link rel="canonical" href="https://wukang555.github.io/2021/11/28/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E5%89%AF%E6%9C%AC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>动态规划-力扣题解 | 落风的风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="落风的风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落风的风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://wukang555.github.io/2021/11/28/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E5%89%AF%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wu kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落风的风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划-力扣题解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-28 22:55:00" itemprop="dateCreated datePublished" datetime="2021-11-28T22:55:00+08:00">2021-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-08 20:02:54" itemprop="dateModified" datetime="2021-11-08T20:02:54+08:00">2021-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/comments/377874">“一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡。”</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/comments/401721">“十推九敲，八种思路，用光七情六欲五感，在这里四覆三翻二挠，一拳爆屏。”</a></p>
<a id="more"></a>

<blockquote>
<p>[1] 定义部分参考了力扣官方<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/dynamic-programming-1-plus/xceyqr/">力扣小卡片-动态规划</a></p>
<p>[2] 使用方法和力扣题目来自于<a target="_blank" rel="noopener" href="https://greyireland.gitbook.io/algorithm-pattern/ji-chu-suan-fa-pian/dp">开源模板-动态规划</a></p>
<p>[3] 文章结构和代码全凭个人理解、错误之处敬请指出；除标注外皆原创、保留权力</p>
</blockquote>
<h2 id="1-如何使用动态规划"><a href="#1-如何使用动态规划" class="headerlink" title="1 如何使用动态规划"></a>1 如何使用动态规划</h2><p>​        动态规划（Dynamic programming，简称 DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划不是某一种具体的算法，而是一种算法思想：若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。[1]</p>
<p>​        现阶段的刷题就是为了面试撕代码，所以第一节直接讲怎么用，第二节再讲DP是什么。</p>
<h3 id="1-1-使用场景-2"><a href="#1-1-使用场景-2" class="headerlink" title="1.1 使用场景[2]"></a>1.1 使用场景[2]</h3><ul>
<li><strong>满足以下条件之一</strong><ul>
<li>求最大/最小值（Maximum/Minimum ）</li>
<li>求是否可行（Yes/No ）</li>
<li>求可行个数（Count(*) ）</li>
</ul>
</li>
<li><strong>满足不能排序或者交换（Can not sort / swap ）</strong></li>
</ul>
<h3 id="1-2-四点要素-2"><a href="#1-2-四点要素-2" class="headerlink" title="1.2 四点要素[2]"></a>1.2 四点要素[2]</h3><ul>
<li>状态 State<ul>
<li><strong>灵感，创造力，存储小规模问题的结果</strong></li>
</ul>
</li>
<li>方程 Function<ul>
<li>状态之间的联系，怎么通过小的状态，来算大的状态</li>
</ul>
</li>
<li>初始化 Intialization<ul>
<li>最极限的小状态是什么, 起点</li>
</ul>
</li>
<li>答案 Answer<ul>
<li>最大的那个状态是什么，终点</li>
</ul>
</li>
</ul>
<h3 id="1-3-示例模板-斐波那契数"><a href="#1-3-示例模板-斐波那契数" class="headerlink" title="1.3 示例模板-斐波那契数"></a>1.3 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">示例模板-斐波那契数</a></h3><blockquote>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p>
</blockquote>
<p>​        以最为简单的斐波拉契数作为例子，<strong>方便理解动态规划算法的使用流程</strong>。<strong>四点要素中我觉得最重要的是状态</strong>，状态用来存储小规模问题的结果、状态的选择需要创造力，但就应试考试而言、我们通过经验来弥补就好了。其次是状态转移方程、基本只要能列出方程就离解题不远了。本题而言、方程已经直接给了就可以直接上手：</p>
<ul>
<li>动态规划 <code>dp[i]</code>表示<code>F(i)</code>的值</li>
<li>初始化 <code>dp[0]=0, dp[1]=1</code>; 终点求<code>dp[n]</code></li>
<li>状态转移方程 <code>dp[i]=dp[i-1]+dp[i-2]</code>;</li>
</ul>
<p>模板代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        至于怎么减少空间复杂度，重复利用<code>dp</code>数组的空间，其实是细支末节，并不很难，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n; <span class="comment">//特殊情况先判断</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//重复利用空间</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-介绍动态规划-1"><a href="#2-介绍动态规划-1" class="headerlink" title="2 介绍动态规划[1]"></a>2 介绍动态规划[1]</h2><p>​        应用这种动态规划算法思想解决问题的可行性，对<strong>子问题与原问题的关系</strong>，以及<strong>子问题之间的关系</strong>这两方面有一些要求，它们分别对应了<strong>最优子结构</strong>和<strong>重复子问题</strong>。</p>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>一个问题的最优解是由它的各个子问题的最优解决定的。将子问题的解进行组合可以得到原问题的解是动态规划可行性的关键。在解题中一般用状态转移方程描述这种组合。找到了最优子结构，也就能推导出一个状态转移方程 $f(n)$</p>
<p><img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202814.png" alt="img"></p>
<h3 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h3><p>重复子问题规定的是子问题与子问题的关系。动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。</p>
<p>动态规划算法中关于最优子结构和重复子问题的理解的关键点：</p>
<ul>
<li>证明问题的方案中包含一种选择，选择之后留下一个或多个子问题</li>
<li>设计子问题的递归描述方式</li>
<li>证明对原问题的最优解包括了对所有子问题的最优解</li>
<li>证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）</li>
</ul>
<h2 id="3-力扣题解"><a href="#3-力扣题解" class="headerlink" title="3 力扣题解"></a>3 力扣题解</h2><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h3><blockquote>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标<code>i</code>或<code> i + 1</code> 。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>这题状态的选择很有创造性，<strong>从底部往上动态查找</strong></li>
<li><code>dp[i][j]</code>表示 第<code>i</code>行的<code>j</code>节点出发 到第<code>n</code>行的最小路径和</li>
<li>初始化<code> dp</code>为原集合 目标<code>dp[0][0]</code></li>
<li>动态迭代 <code>dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1])+arr[i][j]</code></li>
</ul>
<p>代码：空间优化就是一维数组，代码就不再列出了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">1</span>) <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化最后一层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][j] = triangle.get(m-<span class="number">1</span>).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><blockquote>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p>
<p>示例 1：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202815.jpg" alt="img" style="zoom: 67%;">

<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>原地动态规划<code> dp[i][j]</code>表示从左上角到<code>i,j</code>处的最小路径和</li>
<li>初始化<code>dp[0][i], dp[j][0]</code>累计即可  终点<code>dp[m-1][n-1]</code></li>
<li>动态规划方程<code> dp[i][j] = grid[i][j]+ Math.min(dp[i-1][j],dp[i][j-1])</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i) grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                grid[i][j] += Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h3><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>示例 1：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202816.jpg" alt="img" style="zoom:67%;">

<p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2</p>
</blockquote>
<p>思路：</p>
<ul>
<li>状态就是某网格的路径数 有障碍物时当前为0</li>
<li><code>dp[i][j]</code>表示从左上角到<code>i,j</code>位置的路径数目</li>
<li>初始化 第一行第一列为1 如果出现障碍物后面全0 终点<code>dp[m-1][n-1]</code></li>
<li>动态迭代 有障碍物则0，如果没有就<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li>
</ul>
<p>代码：其实如果新建一个<code>dp[][]</code>数组后细节处更不易出错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//排除干扰</span></span><br><span class="line">        <span class="comment">//初始化 第一列和第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;j++) obstacleGrid[j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里第一行要从第二个开始了 因为第一列初始化已经修改了值！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++) obstacleGrid[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    obstacleGrid[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    obstacleGrid[i][j]=obstacleGrid[i-<span class="number">1</span>][j]+obstacleGrid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h3><blockquote>
<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p>示例 1：</p>
<p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p>
</blockquote>
<p>思路：动态规划——维护每个点是否可达的数组</p>
<ul>
<li><code>dp[i] </code>表示能否跳到<code>i+1</code>这个节点</li>
<li><code>dp[0] = true</code>  求<code>dp[n-1]</code>;</li>
<li><strong>动态迭代求<code>dp[i]</code>时，从<code>i-1</code>处向前找</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;n&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">//默认为false</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//动态迭代求dp[i]时，从i-1处向前找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span>&amp;&amp;i-j&lt;=nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]==<span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>
</blockquote>
<p>这个动态规划怎么这么慢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示从索引i到j的子串是否是回文串</span></span><br><span class="line">        <span class="comment">//动态迭代 dp[i][j] = dp[i+1][j-1] &amp;&amp; s.charAt(i)==s.charAt(j);</span></span><br><span class="line">        <span class="comment">//两层循环 外层长度从1到n  内层索引 i从0到n-l</span></span><br><span class="line">        <span class="comment">//初始化 需要初始长度为1 和长度为2 的dp</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> length=<span class="number">1</span>;length&lt;=n;length++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n-length;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i+length-<span class="number">1</span>;  <span class="comment">//[i,j]</span></span><br><span class="line">                <span class="keyword">if</span>(length==<span class="number">1</span>) dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(length==<span class="number">2</span>) dp[i][j] = s.charAt(i)==s.charAt(j);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s.charAt(i)==s.charAt(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;length&gt;maxLength)&#123;</span><br><span class="line">                    maxLength = length;</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这题的频率不是一般的高，暴力解法也来爽一爽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//想先写一个暴力解法</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">                String cur = s.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(cur)&amp;&amp; cur.length()&gt;maxLength)&#123;</span><br><span class="line">                    left = i; right = j;</span><br><span class="line">                    maxLength = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一个字符串是否是回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(s.length()-i-<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="132-分割回文串-II"><a href="#132-分割回文串-II" class="headerlink" title="132. 分割回文串 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h3><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 最少分割次数 。</p>
<p>示例 1：</p>
<p>输入：s = “aab”<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [“aa”,”b”] 这样两个回文子串。</p>
</blockquote>
<p>思路：</p>
<ul>
<li><code>dp[i]</code>表示1到i的子串的最小分割次数 <code>dp = new int[n+1]</code>; <code>dp[]</code>的长度比字符串s大1</li>
<li><code>dp[i]</code>的初始化为<code>dp[i-1]+1</code>,,并且<code>dp[1]=0; dp[0]=-1</code>，终点<code>dp[n]</code></li>
<li><code>dp[i]</code>的求解需要利用遍历，<code>j</code>从<code>0</code>遍历到<code>i-1</code> 如果有<code>[j+1,i]</code>部分是回文的(对应于<code>s(j,i-1)</code> )则<code>dp[i]=Math.min(dp[i],dp[j]+1)</code></li>
</ul>
<p>代码：运行相当之慢，好像判断是否回文哪里可以用动态规划优化一下（回头再看吧…)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=-<span class="number">1</span>; dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//[j+1,i]为回文则取小值</span></span><br><span class="line">                <span class="keyword">if</span>(isBack(s,j,i-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBack</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)!=s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><ul>
<li>和分割回文子串的最小次数是一类题，<code>dp[i]</code>的求解需要 <code>dp[]数组</code>从<code>0</code>往<code>i</code>的遍历 找找迭代方程中的需要的那个元素</li>
<li><code>dp[i]</code>表示<strong>以<code>i</code>索引元素结尾的</strong>严格增子序列的长度！！！<code>dp[i]</code>非递增，而是代表类它自己那个递增序列的长度</li>
<li>初始化 <code>dp[0]=1; dp[i]=1</code> 终点不是<code>dp[n-1]</code>，而是**<code>dp[i]</code>数组的最大值**</li>
<li>动态迭代<code> j</code>有<code>0</code>到<code>i-1</code>,<code>if(nums[j]&lt;nums[i])</code> 则<code>dp[i] =max(dp[i], dp[j]+1)</code>,,,</li>
<li>用一个<code>maxResult</code>记录<code>dp[]</code>数组的最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxResult=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]) dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            maxResult=Math.max(dp[i],maxResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h3><blockquote>
<p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​        思路：连续三道<strong>找状态<code>dp[i]</code>，需要遍历<code>dp[]</code>数组<code>i</code>之前的所有元素</strong>、来判断<code>dp[i]</code>的取值了！！ 都是复杂度为<code>O(n2)</code>的<code>DP</code></p>
<ul>
<li><code>dp[i]</code>表示字符串第<code>i-i</code>个元素，是否可以被拆分为字典中出现的词</li>
<li><code>dp[0]</code>表示无字符串为true， 终点<code>dp[n]</code></li>
<li>动态迭代 当<code>dp[j]=true&amp;&amp;[j+1,i]位于字典中</code>，对应s的索引为<code>s[j,i-1]</code></li>
<li>用set集合判断是否在字段中</li>
</ul>
<p>​    代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">//因为求dp[1]要用到dp[0]索引定义dp长度为n+1！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]==<span class="keyword">true</span> &amp;&amp; wordDictSet.contains(s.substring(j,i)) )&#123;</span><br><span class="line">                    dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：想复杂了没想到是一个简单的DP</p>
<ul>
<li>当<code>text[i]==text[j]</code>时 <code>dp[i][j] = dp[i-1][j-1]+1</code></li>
<li>否则 <code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code></li>
<li>初始化<code>dp[0][0] = 0</code>第一行第一列都为0 终点<code>dp[m][n]</code></li>
<li><strong>定义m+1 n+1维的数组就很完美</strong></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(); <span class="keyword">int</span> n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><blockquote>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li><code>dp[i][j]</code>表示word1前<code>i</code>个转换成word2前<code>j</code>个 所需使用的最小操作数</li>
<li>初始化 第一行<code>dp[0][j]=j </code>第一列<code>dp[i][0]=i</code>    //终点<code>dp[m][n]</code></li>
<li>动态规划,若<code>word1.charAt(i-1)==word2.charAt(j-1)</code> 则<code>dp[i][j]=dp[i-1][j-1]</code>表示不需要操作</li>
<li>若不相等 则<code>dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code></li>
<li><strong>定义m+1 n+1维的数组就很完美</strong><ul>
<li>因为要用到<code>i-1 j-1</code>,所以需要从<code>1</code>开始循环，<code>dp[0][0]</code>表示都为空时的状态，<code>dp[1][1]</code>代表第一个元素的状态，所以<code>dp[m][n]</code>是终点</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行第一列为i,j</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min( Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>; <span class="comment">//分别对应：增加、增加、替换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-面试高频题"><a href="#4-面试高频题" class="headerlink" title="4 面试高频题"></a>4 面试高频题</h2><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><blockquote>
<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211107202817.jpg" alt="img" style="zoom:50%;">

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：这题的关键是状态的确定 还有迭代方程</p>
<ul>
<li><code>dp[i][j]</code>表示以<code>[i][j]</code>为右下角，且只包含 1 的正方形的边长最大值</li>
<li>初始化：第一行第一列最大为1，并且就等于<code>matrix</code>矩阵的值</li>
<li>需要用一个<code>maxLength</code>记录最大边长</li>
<li>迭代方程<code> dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code>;</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                maxLength=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLength) maxLength=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength*maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h3><blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：动态规划，有变化的地方在于p，需要分类考虑</p>
<ul>
<li>状态<code>dp[i][j]</code>表示s的前<code>i</code>个字符和p的前<code>j</code>个字符是否匹配成功</li>
<li>初始化 <code>dp[0][0]=true</code>, <code>dp[i][0]=false</code>; <code>dp[0][j]</code>仅p前j个全为*才为真； 终点<code>dp[m][n]</code></li>
<li>动态迭代 如果p[j]为小写字母，<code>dp[i][j] = s[i]==p[j] &amp;&amp; dp[i-1][j-1]</code></li>
<li>如果 p[j]为？, <code>dp[i][j] = dp[i-1][j-1]</code></li>
<li>如果 p[j]为*， <code>dp[i][j] = dp[i][j-1] || dp[i-1][j]</code>; 分别表示 *使用和不使用的情况 (这里难想一点)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] =<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][j]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] || dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//为小写字母</span></span><br><span class="line">                    dp[i][j] = s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>) &amp;&amp; dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><blockquote>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li>动态规划 状态<code>dp[i]</code>表示索引<code>i</code>的字符结尾的最长有效子串的长度</li>
<li>初始化<code>dp[i]=0</code>, 终点：求<code>dp[]数组</code>的最大值</li>
<li>动态迭代 当<code>s[i]为&#39;(&#39; </code>时<code>dp[i]=0</code>;</li>
<li>1形如<code>&quot;...()&quot;</code> 当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;(&#39; 时 dp[i]=dp[i-2]+2</code>;</li>
<li>2形如<code>&quot;...))&quot; </code>当<code>s[i]=&#39;)&#39;&amp;&amp;s[i-1]=&#39;)&#39; </code>时 当前一个子串之前的有<code>(</code>能与s[i]的<code>)</code>配对时，需<code> +2+(之前的子串长度</code><ul>
<li> <code>if(s[i-dp[i-1]-2]==&#39;(&#39;)</code> 则<code>dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]</code></li>
</ul>
</li>
<li>注意每一次赋值判断之前都要判断s和dp是否可能发生越界！！细节太多了！</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;=<span class="number">2</span>) dp[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i] = dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&lt;<span class="number">0</span>) dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候需要定义<code>dp[]</code>数组长度+1，还真实一个苦恼的问题</p>
<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><blockquote>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li>状态：<code>dp[i][0]</code> 第i天不持有的最大利润;<code>dp[i][1]</code> 第i天持有的最大利润</li>
<li>初始化:<code>dp[0][0] = 0; dp[0][1] = -prices[0]</code>   ；终点：<code>dp[n-1][0]</code> </li>
<li>只能买卖一次 说明买入的时候 资产为<code>-prices[i]</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只能买卖一次 说明买入的时候 资产为-price[i]</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减少空见复杂度,重复利用<code>dp[]数组</code>的空间</p>
<ul>
<li><code>% 2</code>还可以写成 <code>&amp; 1</code>，这里为了保证可读性，选用 <code>% 2</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">0</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">0</span>],dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i%<span class="number">2</span>][<span class="number">1</span>] = Math.max(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(n-<span class="number">1</span>)&amp;<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//与运算博大精深啊</span></span><br><span class="line">        <span class="comment">//return Math.max(dp[1][0],dp[0][0]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路:</p>
<ul>
<li>状态 <code>dp[i][j]</code>表示索引<code>i</code>天状态<code>j</code>下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</li>
<li>初始化 第一天：<code>dp[0][0]=dp[0][2]=dp[0][4]=0</code>; <code>dp[0][1]=dp[0][3]=-prices[0] </code> 终点<code>dp[n-1][2or4]</code></li>
<li>动态迭代 <code>dp[i][0] = 0; dp[i][1] =max(-prices[i],dp[i-1][1]); dp[i][2] = max(dp[i-1][1]+prices[i],dp[i-1][2]);</code></li>
<li><code>dp[i][3]=max(dp[i-1][2]-prices[i],dp[i-1][3]); dp[i][4]=max(dp[i-1][3]+prices[i],dp[i-1][4]);</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态 dp[i][j]表示索引i天状态j下的最大利润 j=0表示未买入 1表示买入一个 2表示卖出一个 3表示买入第二个 4表示卖出第二个</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>]= dp[<span class="number">0</span>][<span class="number">3</span>] =-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]= dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(-prices[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i],dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i],dp[i-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n-<span class="number">1</span>][<span class="number">2</span>],dp[n-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二：空间优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//状态：0表示未交易 1表示买入一次 2表示卖出一次 3表示买入两次 4表示卖出两次</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[<span class="number">4</span>] = Math.max(dp[<span class="number">4</span>], dp[<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><blockquote>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li>状态（0到2k） 0表示未交易 1表示买入一次 2表示卖出一次…2k-1表示买入k次，2k表示卖出k次</li>
<li>初始化：<code>dp[0]</code>始终为0；<code>dp[1]= - prices[0]</code>；<code>dp[2-end]</code>初始化为一个小值</li>
<li>动态迭代：<ul>
<li><strong>外层循环</strong>为考虑的天数，从<code>i=1:n-1</code></li>
<li><strong>内层循环</strong>为遍历所有状态：从<code>j=1:2k</code></li>
<li>如果当前状态索引j为奇数，也就是手头有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] - prices[i])</code></li>
<li>如果当前状态索引j为偶数，也就是手头没有股票的情况<code>dp[j] = max(dp[j], dp[j - 1] + prices[i])</code></li>
</ul>
</li>
<li>终点为数组<code>dp[] </code>的最大值</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[]:2k+1;  dp[2*k-1]买入k次  dp[2*k]表示卖出k次</span></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        k = Math.min(k,n/<span class="number">2</span>); <span class="comment">//最多进行n/2次交易！！</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp为小值</span></span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i++) dp[i]= Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//按天数动态迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]+prices[i],dp[j]);</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">1</span>) dp[j] = Math.max(dp[j-<span class="number">1</span>]-prices[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2</span>*k;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h3><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li>//<code>dp[i][j]</code> 表示n1以<code>i</code>开头、n2以<code>j</code>开头的子数组的最长公共子数组长度 即<code>nums1[i:end] nums2[j:end]</code></li>
<li>//初始化<code>dp[m-1][n-1]=0or1</code>;<code> dp[m-1][j]=0or1; dp[i][n-1]=0or1</code>; 终点<code>dp[0][0]</code>，求数组<code>dp[][]</code>的最大值</li>
<li>//动态迭代 <code>nums1[i]==nums2[j]? dp[i][j] = dp[i+1][j+1]+1:0</code>;</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个反序推导的题</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[m-<span class="number">1</span>]==nums2[j]) dp[m-<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]==nums2[n-<span class="number">1</span>]) dp[i][n-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp[i][j] =  nums1[i]==nums2[j]? dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;res) res = dp[i][j];          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接定义<code>dp[][]</code>数组的长度为<code>[m+1,n+1]</code>,那样就不用初始化了</p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li><code>dp[i]</code>表示偷窃前<code>i</code>个房屋所能获得的最大金额</li>
<li>初始化 <code>dp[0]=nums[0]</code> <code>dp[1]=Max(dp[0],nums[1])</code>; 终点<code>dp[n-1]</code></li>
<li>动态迭代 <code>dp[i] = Max(dp[i-1],dp[i-1]+nums[i])</code>;</li>
</ul>
<p>代码: 如果使用滚动数组可以减少空间复杂度、不列出了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示偷窃前i个房屋所能获得的最大金额</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; dp[<span class="number">1</span>]=Math.max(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<p>思路：</p>
<ul>
<li><code>dp[i] </code>表示前<code>i</code>件范围盗窃 最大金额</li>
<li><code>dp[i] = max(dp[i-1],dp[i-2]+nums[i])</code>;</li>
<li>如果第一件盗窃 则盗窃范围为[0,n-2]</li>
<li>如果第一间不盗窃 范围为[1,n-1]</li>
<li><strong>因为要用到<code>dp[i-2]</code>，所以用<code>dp[0]=0</code>表示不盗窃！！</strong></li>
</ul>
<p>代码一：两个<code>dp[]</code>数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//相当于两个动态规划的叠加 1盗窃第一间房[0,n-2] 2不盗窃第一间房[1,n-1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]; <span class="comment">//盗窃第一间房</span></span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]; <span class="comment">//盗窃了第二间房</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp1[i] = Math.max(dp1[i-<span class="number">1</span>],dp1[i-<span class="number">2</span>]+nums[i-<span class="number">1</span>]);</span><br><span class="line">            dp2[i] = Math.max(dp2[i-<span class="number">1</span>],dp2[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1[n-<span class="number">1</span>],dp2[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二：滚动数组优化空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一件盗窃 则盗窃范围为[0,n-2]</span></span><br><span class="line">        <span class="comment">//如果第一间不盗窃 范围为[1,n-1]</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>]; <span class="comment">//前3 后3</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">2</span>],Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//初始化 至少有四个元素</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        dp[<span class="number">3</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">4</span>] = Math.max(nums[<span class="number">2</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//两种情况循环次数是一样的 注意i的大小就好了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">1</span>],dp[<span class="number">0</span>]+nums[i]);</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//第二种情况</span></span><br><span class="line">            dp[<span class="number">5</span>] = Math.max(dp[<span class="number">4</span>],dp[<span class="number">3</span>]+nums[i+<span class="number">1</span>]);</span><br><span class="line">            dp[<span class="number">3</span>] = dp[<span class="number">4</span>];</span><br><span class="line">            dp[<span class="number">4</span>] = dp[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">//System.out.println(dp[5]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">2</span>],dp[<span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><blockquote>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：注意负负得正</p>
<ul>
<li>因为 负负得正，一个负数乘一个很小的负数可能得到一个很大的乘积，所以对每个i索引要分别保存最大乘积和最小乘积</li>
<li><code>dp[i][0]</code>表示<code>i</code>索引元素结尾的连续子数组的最大乘积 <code>dp[i][1]</code>表示最小乘积</li>
<li>初始化<code>dp[0][0]=dp[0][1]=nums[0]</code>; 终点<code>dp[i][0]</code>数组的最大值</li>
<li>动态迭代 <code>dp[i][0] = max(dp[i-1][0]*numd[i],dp[i-1][1]*nums[i],nums[i])</code>; <code>dp[i][1] = min(...)</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][0]表示i索引元素结尾的连续子数组的最大乘积 dp[i][1]表示最小乘积</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>]*nums[i],dp[i-<span class="number">1</span>][<span class="number">1</span>]*nums[i]),nums[i]);</span><br><span class="line">            max = Math.max(max,dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><blockquote>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</li>
<li><code>dp[i]</code>表示第<code>i</code>个字符前的子串解码方法的总数，<strong>因为要用到<code>i-2</code>所以令<code>dp[0]=1</code>代表空字符串</strong></li>
<li>初始化 <code>dp[0]=dp[1]=1</code>; 终点<code>dp[n]</code></li>
<li>动态迭代 单个字符结尾<code>s[i]!=&#39;0&#39; dp[i] += dp[i-1]</code>;</li>
<li>两个字符结尾 <code>s[i-1]!=&#39;0&#39;&amp;&amp; s[i-1]s[i]&lt;=26 dp[i] += dp[i-2]</code>;</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 迭代方程需要分一下类：单个字符结尾/两个字符结尾</span></span><br><span class="line">        <span class="comment">//dp[i]表示第i个字符前的子串解码方法的总数</span></span><br><span class="line">        <span class="comment">//因为要用到i-2所以令dp[0]=1代表空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)!=<span class="string">&#x27;0&#x27;</span>) dp[i] +=dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>)!=<span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">2</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(s.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h3><blockquote>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：k &#x3D; 1, n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f &#x3D; 0 。 </span><br><span class="line">否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f &#x3D; 1 。 </span><br><span class="line">如果它没碎，那么肯定能得出 f &#x3D; 2 。 </span><br><span class="line">因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：k &#x3D; 2, n &#x3D; 6</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：k &#x3D; 3, n &#x3D; 14</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：动态规划+二分查找</p>
<ul>
<li>动态规划 <code>dp[i][j]</code>表示用<code>i</code>个鸡蛋确定<code>j</code>层楼房的f值 的最小操作数</li>
<li>初始化 <code>dp[i][1]= 1 </code>一层楼房 抛一次就确定了 ；<code>dp[1][j]=j </code>一个鸡蛋确定<code>j</code>层楼房 从下往上试直到摔破共<code>j</code>次</li>
<li>终点<code> dp[k][n]</code></li>
<li>动态迭代 外层<code>i从2到k个鸡蛋</code> 内层<code>j从2层到n层楼房</code>； 如果不用二分、第三层 <code>x从1到n</code></li>
<li><code>dp[k][n] = 1+ min( max( dp[k-1,x-1] , dp[k,n-x]) )</code> 摔破/没摔破 取所有x的小值</li>
<li><strong><code>dp[k-1][x-1]</code>随x递增 <code>dp[k][x-k]</code>随x递减,，注意画这两个单调数列的图（两条直线），就明白如何用二分了，取两个函数的大值，就是上边的折线，然后找整个折线的最小值</strong></li>
<li>使用二分找到 <code>dp[k-1][x-1] &lt; dp[k][n-x]</code> 的最后一个x0，，然后比较获得<code>min(T1(x0+1), T2(x0))</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示用i个鸡蛋确定j层楼房的f值 的最小操作数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) dp[i][<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) dp[<span class="number">1</span>][j]= j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果不用二分算法</span></span><br><span class="line">                <span class="comment">// int min = n+1;</span></span><br><span class="line">                <span class="comment">// for(int x=1;x&lt;=j;x++)&#123;</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = 1 + Math.min(min, Math.max(dp[i-1][x-1],dp[i][j-x])) </span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//二分算法</span></span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = j;</span><br><span class="line">                <span class="comment">//要找T1小于T2的最大x0</span></span><br><span class="line">                <span class="keyword">int</span> x0=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">                    x0 = left+(right-left)/<span class="number">2</span>; </span><br><span class="line">                    <span class="keyword">if</span>( dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&lt;dp[i][j-x0])&#123;</span><br><span class="line">                        left = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i-<span class="number">1</span>][x0-<span class="number">1</span>]&gt;dp[i][j-x0])&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right = x0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断right和left谁才是真正要找的x0的位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][right-<span class="number">1</span>]&lt;=dp[i][j-right]) x0=right;</span><br><span class="line">                <span class="keyword">else</span> x0= left;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//所以最小值 min(T1(x0+1),T2(x0))</span></span><br><span class="line">                dp[i][j] =<span class="number">1</span> + Math.min(dp[i-<span class="number">1</span>][x0+<span class="number">1</span>-<span class="number">1</span>], dp[i][j-x0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h3><blockquote>
<p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：</p>
<ul>
<li>动态规划 <code>dp[i][j]</code>表示索引<code>i</code>之前的数能够构造出结果<code>j</code>的表达式数目</li>
<li>因为属于j[-1000,1000], 所以事实上用<code>dp[i][j+1000]</code>，</li>
<li>动态规划 <code>dp[i][j+1000-nums[i]] += dp[i-1][j+1000];</code> //对应-号</li>
<li><code>dp[i][j+1000+nums[i]] += dp[i-1][j+1000]</code>; //对应+号</li>
<li><code>i</code>外层循环<code>[0，n-1]</code>；<code> j</code>内层循环<code>[-1000，1000]</code></li>
<li>不知道初始化谁，就手动循环一遍发现只用<code>i=0, dp[0][j+1000]+=1</code>就好了,其中<code>j=nums[0]/-nums[0]</code>,一定要+=防止出现多个0的情况！！、其他必然为0</li>
<li>终点 <code>dp[n-1][target+1000]</code>;</li>
<li>对于<code>j</code>的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别，就是用<code>[j]</code>更新<code>[j+/-nums[i]]</code><ul>
<li>如果<code>dp[i - 1][j]==0</code>就没有进入更新的必要</li>
</ul>
</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划 dp[i][j]表示索引i之前的数能够构造出结果j的表达式数目</span></span><br><span class="line">        <span class="comment">// 因为属于j[-1000,1000],所以事实上用dp[i][j+1000]，</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2001</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>]+<span class="number">1000</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1000</span>;j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//对于j的遍历来说，是在等式的右边体现的，这里与其他动规相比较特别</span></span><br><span class="line">                <span class="comment">//就是用[j]更新[j+/-nums[i]]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j + <span class="number">1000</span>] &gt; <span class="number">0</span>)&#123; <span class="comment">//如果==0就没有进入更新的必要</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>-nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应-号</span></span><br><span class="line">                    dp[i][j+<span class="number">1000</span>+nums[i]] += dp[i-<span class="number">1</span>][j+<span class="number">1000</span>]; <span class="comment">//对应+号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleavingz-string/">97. 交错字符串</a></h3><blockquote>
<p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p>
<p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p>
<p>s = s1 + s2 + … + sn<br>t = t1 + t2 + … + tm<br>|n - m| &lt;= 1<br>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>提示：a + b 意味着字符串 a 和 b 连接。</p>
</blockquote>
<p>思路:</p>
<ul>
<li><del>开始我想错了 以为i、j之差不能超过1,没必要没必要</del></li>
<li><code>dp[i][j]</code>表示s1的前<code>i</code>个与s2的前<code>j</code>个能否交错组成s3的前<code>(i+j)</code>个s3，，s1+s2与s3长度若不相等直接返回false</li>
<li>初始化<code>dp[0][j]=true</code>仅当<code>s2[0:j-1]=s3[0:j]</code>;    <code>dp[i][0]=true仅当s1[0:i-1]=s3[0:i]</code></li>
<li>动态迭代 <code>dp[i][j] = dp[i-1][j]&amp;&amp;s1[i-1]==s3[i+j-1] || dp[i][j-1]&amp;&amp;s2[j-1]==s3[i+j-1]</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示s1的前i个与s2的前j个能否交错组成s3的前(i+j)个s3</span></span><br><span class="line">        <span class="keyword">int</span> m =s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(n+m!=s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = ( dp[i-<span class="number">1</span>][j]&amp;&amp;s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>+j) ) || </span><br><span class="line">                        (dp[i][j-<span class="number">1</span>]&amp;&amp;s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-背包问题-领扣）"><a href="#5-背包问题-领扣）" class="headerlink" title="5 背包问题(领扣）"></a>5 背包问题(领扣）</h2><p>我为什么这么菜？还是直接以题代学。领扣上面有全套的背包题。</p>
<h3 id="125-·-背包问题（二）"><a href="#125-·-背包问题（二）" class="headerlink" title="125 · 背包问题（二）"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/125/description">125 · 背包问题（二）</a></h3><blockquote>
<p>描述</p>
<p>有 <code>n</code> 个物品和一个大小为 <code>m</code> 的背包. 给定数组 <code>A</code> 表示每个物品的大小和数组 <code>V</code> 表示每个物品的价值.</p>
<p>问最多能装入背包的总价值是多大?</p>
<p><code>A[i], V[i], n, m</code> 均为整数你不能将物品进行切分你所挑选的要装入背包的物品的总大小不能超过 <code>m</code>每个物品只能取一次</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D; 10</span><br><span class="line">A &#x3D; [2, 3, 5, 7]</span><br><span class="line">V &#x3D; [1, 5, 2, 4]</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9</p>
</blockquote>
<p><strong>就是最基础的01背包问题，每一个物品只能用一次。</strong></p>
<p>思路1：二维数组</p>
<ul>
<li><code>dp[i][j]</code>表示前<code>i</code>个物品装入<code>j</code>大小的背包 的最大总价值数</li>
<li>初始化<code>dp=[i][0]0</code>; 终点<code>dp[n][m]</code></li>
<li>动态迭代：i的范围<code>[1,n]</code>  j的范围<code>[0,m]</code>  状态分别对应将第i个物品装入背包和不装入背包两种情况</li>
</ul>
<p>$$<br>dp[i][j]=max(dp[i-1][j], dp[i-1][j-A[i-1]]+V[i-1])<br>$$</p>
<p>代码1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品装入j大小的背包 的最大总价值数</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&lt;<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max( dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-A[i-<span class="number">1</span>]]+ V[i-<span class="number">1</span>] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：空间优化的一维数组</p>
<p>我们发现，欲求<code> dp[i][j]</code>需要使用<code>dp[i-1][j]</code>和<code>dp[i-1][j-A[i-1]]</code>两种状态，显然就是计算<code>i</code>时需要<code>i-1</code>时候的状态！！ 令状态<code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>能装的最大价值数，每遍历完一次、就更新了该数组一次。状态转移方程：<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$<br>但是这时出现了一个问题：如果<code>j</code>仍然从0遍历到最大容量m，，，<code>dp[j-A[i-1]]</code>总是先于<code>dp[j]</code>更新，所以更新过程，用到了更新的数组的值、当然就有问题了。。</p>
<p><strong>这个时候就需要反向遍历,<code>j</code>仍然从m遍历到0，，计算索引靠右边的<code>dp[j]</code>时，利用的是上一个数组中的<code>dp[j]</code>和没有更新的索引位置较小的<code>dp[j-x]</code></strong></p>
<p>动态规划的要素如下：</p>
<ul>
<li><code>dp[j]</code>标识默认<code>i</code>个物品时容量为<code>j</code>的背包能装的最大价值数</li>
<li>初始化dp[j]=0标识0个物品时的最大价值 , 终点dp[m]标识n个物品时容量m背包的最大价值数</li>
<li>动态迭代 j从m迭代到0，状态转移方程如上 ，<strong>i还是从1迭代到n，，时间并没有优化！！</strong></li>
</ul>
<p>代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: Given n items with value V[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>) dp[j] = Math.max(dp[j],dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="92-·-背包问题"><a href="#92-·-背包问题" class="headerlink" title="92 · 背包问题"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/92/description">92 · 背包问题</a></h3><blockquote>
<p>在<code>n</code>个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为<code>m</code>，每个物品的大小为A[i]</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组 &#x3D; [3,4,8,5]</span><br><span class="line">backpack size &#x3D; 10</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：就是01背包问题，然后体积和价值是同一个数组</p>
<p>代码：一维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer m denotes the size of a backpack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: Given n items with size A[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: The maximum size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实就是01背包问题，然后体积和价值是同一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=A[i-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+A[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="440-·-背包问题-III"><a href="#440-·-背包问题-III" class="headerlink" title="440 · 背包问题 III"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/440/">440 · 背包问题 III</a></h3><blockquote>
<p>给定 <code>n</code> 种物品, 每种物品都有无限个. 第 <code>i</code> 个物品的体积为 <code>A[i]</code>, 价值为 <code>V[i]</code>.</p>
<p>再给定一个容量为 <code>m</code> 的背包. 问可以装入背包的最大价值是多少?</p>
<p>不能将一个物品分成小块.放入背包的物品的总大小不能超过 <code>m</code>.</p>
<p><strong>样例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: A &#x3D; [2, 3, 5, 7], V &#x3D; [1, 5, 2, 4], m &#x3D; 10</span><br><span class="line">输出: 15</span><br><span class="line">解释: 装入三个物品 1 (A[1] &#x3D; 3, V[1] &#x3D; 5), 总价值 15.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>就是最经典的完全背包问题，每一个物品只能无限次。</strong></p>
<p>思路1：三层循环</p>
<ul>
<li><code>dp[i][j]</code>表示前i个物品任意取，背包容量为j时的最大价值</li>
<li>初始化 <code>dp[i][0]=0</code>; 终点<code>dp[n][m]</code></li>
<li>动态迭代 第<code>i</code>个物品最多使用的个数是 <code>m/A[i-1]</code>    k取0到<code>m/A[i-1]</code></li>
<li><code>dp[i][j] = max( dp[i-1][j-k*A[i-1]]+k*V[i-1])</code></li>
</ul>
<p>代码1：就嗯循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i][j]表示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j];</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;=m/A[i-<span class="number">1</span>];k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-k*A[i-<span class="number">1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*A[i-<span class="number">1</span>]]+k*V[i-<span class="number">1</span>] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：O(nm)的算法，翻转01背包的遍历顺序即可！！这里摘用一下《背包九讲》中的解释</p>
<blockquote>
<p>首先想想为什么 01 背包中要按照 j 递减的次序来循环。让 j 递减是为了保证第i次循环中的状态 <code>dp[i, j]</code> 是由状态 <code>dp[i − 1, j − Ai]</code> 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 <code>i </code>件物品”这件策略时，依据的是一个绝无已经选入第 <code>i </code>件物品的子结果 <code>dp[i − 1, j − Ai]</code>。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第<code> i</code> 种物品”这种策略时，却正需要一个可能已选入第<code>i</code>种物品的子结果 <code>dp[i, j − Ai]</code>，所以就可以并且必须采用 <code>j</code>递增的顺序循环。这就是这个简单的程序为何成立的道理。</p>
</blockquote>
<ul>
<li><p>//完全背包 时间空间都优化</p>
</li>
<li><p>//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</p>
</li>
<li><p>//初始化 dp[0]=0; 终点dp[m]</p>
</li>
<li><p>//动态迭代 j从0迭代到m，，i还是从1迭代到n，，O(mn)时间复杂度！！<br>$$<br>dp[j] = Math.max(dp[j], dp[j-A[i-1]]+ V[i-1] )<br>$$</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> V: an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: An integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: an array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//完全背包 时间空间都优化</span></span><br><span class="line">        <span class="comment">//dp[j]表示示前i个物品任意取，背包容量为j时的最大价值</span></span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i-<span class="number">1</span>];j&lt;=m;j++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-A[i-<span class="number">1</span>]]+V[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    <div>
      
          
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------感谢阅读<i class="fa fa-paw"></i>没事常来-------------
        </div>
    
</div>
      
    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag"># 力扣</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/18/%E7%AE%97%E6%B3%95_07_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="prev" title="动态规划-力扣题解">
      <i class="fa fa-chevron-left"></i> 动态规划-力扣题解
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.</span> <span class="nav-text">1 如何使用动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 使用场景[2]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%9B%9B%E7%82%B9%E8%A6%81%E7%B4%A0-2"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 四点要素[2]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%A4%BA%E4%BE%8B%E6%A8%A1%E6%9D%BF-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 示例模板-斐波那契数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%8B%E7%BB%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">2.</span> <span class="nav-text">2 介绍动态规划[1]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">重复子问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">3 力扣题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">3.1.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">3.2.</span> <span class="nav-text">64. 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="nav-number">3.3.</span> <span class="nav-text">63. 不同路径 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">3.4.</span> <span class="nav-text">55. 跳跃游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">3.5.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-II"><span class="nav-number">3.6.</span> <span class="nav-text">132. 分割回文串 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.7.</span> <span class="nav-text">300. 最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">3.8.</span> <span class="nav-text">139. 单词拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">3.9.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">3.10.</span> <span class="nav-text">72. 编辑距离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">4 面试高频题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">4.1.</span> <span class="nav-text">221. 最大正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">4.2.</span> <span class="nav-text">44. 通配符匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.3.</span> <span class="nav-text">32. 最长有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">4.4.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="nav-number">4.5.</span> <span class="nav-text">123. 买卖股票的最佳时机 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="nav-number">4.6.</span> <span class="nav-text">188. 买卖股票的最佳时机 IV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">4.7.</span> <span class="nav-text">718. 最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">4.8.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="nav-number">4.9.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">4.10.</span> <span class="nav-text">152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.11.</span> <span class="nav-text">91. 解码方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="nav-number">4.12.</span> <span class="nav-text">887. 鸡蛋掉落</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">4.13.</span> <span class="nav-text">494. 目标和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.14.</span> <span class="nav-text">97. 交错字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E9%A2%86%E6%89%A3%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">5 背包问题(领扣）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#125-%C2%B7-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">125 · 背包问题（二）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-%C2%B7-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.</span> <span class="nav-text">92 · 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#440-%C2%B7-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-III"><span class="nav-number">5.3.</span> <span class="nav-text">440 · 背包问题 III</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wu kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu kang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
