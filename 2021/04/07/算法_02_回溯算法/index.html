<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wukang555.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="首先给回溯算法模板，然后10道力扣经典回溯题，模板包教包会、力图统一化 最后的结论是：首先手绘回溯路径、然后分析选择列表、路径和结束条件、最后套模板yyds">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯算法模板-力扣题解">
<meta property="og:url" content="https://wukang555.github.io/2021/04/07/%E7%AE%97%E6%B3%95_02_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="落风的风">
<meta property="og:description" content="首先给回溯算法模板，然后10道力扣经典回溯题，模板包教包会、力图统一化 最后的结论是：首先手绘回溯路径、然后分析选择列表、路径和结束条件、最后套模板yyds">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161131.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161245.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161253.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161259.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161311.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161316.png">
<meta property="article:published_time" content="2021-04-07T14:55:00.000Z">
<meta property="article:modified_time" content="2021-11-12T14:25:00.210Z">
<meta property="article:author" content="Wu kang">
<meta property="article:tag" content="力扣">
<meta property="article:tag" content="回溯">
<meta property="article:tag" content="dfs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161131.png">

<link rel="canonical" href="https://wukang555.github.io/2021/04/07/%E7%AE%97%E6%B3%95_02_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>回溯算法模板-力扣题解 | 落风的风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="落风的风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落风的风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://wukang555.github.io/2021/04/07/%E7%AE%97%E6%B3%95_02_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wu kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落风的风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          回溯算法模板-力扣题解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-07 22:55:00" itemprop="dateCreated datePublished" datetime="2021-04-07T22:55:00+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-12 22:25:00" itemprop="dateModified" datetime="2021-11-12T22:25:00+08:00">2021-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>首先给回溯算法模板，然后10道力扣经典回溯题，模板包教包会、力图统一化</p>
<p>最后的结论是：首先手绘回溯路径、然后分析选择列表、路径和结束条件、最后套模板yyds</p>
<a id="more"></a>

<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote>
<p>[1] 参考了开源项目github.com/greyireland/algorithm-pattern<br>[2] 参考了labuladong的算法小抄必读文章中的回溯算法解题套路框架（不建议看）</p>
</blockquote>
<h2 id="1-定义及模板"><a href="#1-定义及模板" class="headerlink" title="1 定义及模板"></a>1 定义及模板</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>回溯法（backtrack）是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能。遍历列表所有子集的过程实际是<strong>一个决策树的遍历过程</strong>。决策树的遍历过程为做选择和撤销选择的过程，这其中有着“一路选择到底，而后又一路撤销到起点”的过程，因此称为回溯。</p>
<p>回溯算法就是纯暴力穷举，复杂度一般都很高，时间复杂度一般 O(N!)。</p>
<h3 id="回溯过程"><a href="#回溯过程" class="headerlink" title="回溯过程"></a>回溯过程</h3><p><strong>通过分析发现，回朔法实现的三大关键点分别是：</strong></p>
<ol>
<li>一条路走到黑</li>
<li>回退一步</li>
<li>另寻他路</li>
</ol>
<p><strong>通过for 循环和递归来实现三个关键点，解释如下</strong></p>
<ul>
<li>for循环的作用在于另寻他路： 你可以用for循环可以实现一个路径选择器的功能，该路径选择器可以逐个选择当前节点下的所有可能往下走下去的分支路径。 例如： 现在你走到了节点a，a就像个十字路口，你从上面来到达了a，可以继续向下走。若此时向下走的路有i条，那么你肯定要逐个的把这i条都试一遍才行。而for的作用就是可以让你逐个把所有向下的i个路径既不重复，也不缺失的都试一遍</li>
<li>递归可以实现一条路走到黑和回退一步： 一条路走到黑： 递归意味着继续向着for给出的路径向下走一步。 如果我们把递归放在for循环内部，那么for每一次的循环，都在给出一个路径之后，进入递归，也就继续向下走了。直到递归出口（走无可走）为止。 那么这就是一条路走到黑的实现方法。 递归从递归出口出来之后，就会实现回退一步。</li>
<li>for循环和递归配合可以实现回朔： 当递归从递归出口出来之后。上一层的for循环就会继续执行了。而for循环的继续执行就会给出当前节点下的下一条可行路径。而后递归调用，就顺着这条从未走过的路径又向下走一步。这就是回朔</li>
</ul>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function">def <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> 满足结束条件:</span></span><br><span class="line"><span class="function">        result.<span class="title">add</span><span class="params">(路径)</span></span></span><br><span class="line"><span class="function">        return</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">        <span class="comment">//做选择</span></span></span><br><span class="line"><span class="function">        将该选择从选择列表移除</span></span><br><span class="line"><span class="function">        路径.<span class="title">add</span><span class="params">(选择)</span></span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span></span><br><span class="line"><span class="function">        <span class="comment">//撤销选择</span></span></span><br><span class="line"><span class="function">        路径.<span class="title">remove</span><span class="params">(选择)</span></span></span><br><span class="line"><span class="function">        将该选择再加入选择列表</span></span><br></pre></td></tr></table></figure>

<ol>
<li>路径：也就是已经做出的选择。cur</li>
<li></li>
<li>c结束条件：也就是到达决策树底层，无法再做选择的条件。</li>
</ol>
<h2 id="2-力扣经典回溯题型解答"><a href="#2-力扣经典回溯题型解答" class="headerlink" title="2 力扣经典回溯题型解答"></a>2 力扣经典回溯题型解答</h2><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
</blockquote>
<p><strong>套用模板</strong></p>
<p>如果是直接套模板的话，就直接分析<strong>选择列表</strong>、路径和结束条件。</p>
<ul>
<li><p>用原数组nums的索引<code>index</code>和表示<strong>选择列表</strong>，并用<code>index</code>索引表示做选择，每做一次选择后递归调用<code>index+1</code>，表示下一次要选择下一个索引的元素（因为要求子集）</p>
</li>
<li><p>用一个list集合<code>List&lt;Integer&gt; cur</code>储存<strong>本条选择路径</strong>、每条路径都是原数组的子集</p>
</li>
<li><p>结束条件？好像没有条件，任意路径都是子集，然后index索引的选择已经避免了重复</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结果集 和 选择路径</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backtrack(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 这里无</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="comment">//做选择 1添加到路径 2选择列表移除</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//递归调用 回溯</span></span><br><span class="line">            backtrack(nums,i);</span><br><span class="line">            <span class="comment">//撤销选择 1移出路径 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历过程：自顶找一条路径到底，然后回溯撤回往前找。</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161131.png" alt="backtrack" style="zoom: 50%;">



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><blockquote>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
</blockquote>
<p><strong>套用模板</strong></p>
<p>如果是直接套模板的话，就直接分析<strong>选择列表</strong>、路径和结束条件。</p>
<ul>
<li><p>每次对数组nums的for循环表示做选择，<strong>选择列表</strong>就是<code>visited</code>中未被访问的部分：即如果<code>i</code>索引已经被访问过了，就直接跳过本次循环、不做选择；否者选择<code>nums[i]</code>进入某条路径结果<code>cur</code>中</p>
</li>
<li><p>用一个数组<code>visited = new boolean[nums.length]</code>来表示<strong>已经访问过的路径</strong>。用一个List集合<code>cur = new ArrayList&lt;Integer&gt;()</code>来保存<strong>一条路径结果</strong>，每一条路径结果都是全排列的一种。</p>
</li>
<li><p><strong>结束条件</strong>，当某条路径结果<code>cur</code>的长度等于原数组长度时，表示这条路径已经选择完毕，就将其加入到结果集中，并return结束。</p>
</li>
</ul>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161245.jpg" alt="img" style="zoom: 50%;">

<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个结果集res 和 一个存放路径选择cur的集合</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//定义记录历史路径的visited数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否满足结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果在选择列表里面 1做选择 2选择列表移除</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归调用、回溯</span></span><br><span class="line">            backtrack(nums,visited);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//撤销选择 1撤销选择 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历过程：自顶找一条路径到底，然后回溯撤回往前找。通过选择列表避免重复的元素选择。</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161253.jpg" alt="img" style="zoom:50%;">

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><blockquote>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能包含重复的子集。返回的解集中，子集可以按任意顺序 排列。</p>
</blockquote>
<p><strong>套用模板</strong></p>
<p>如果是直接套模板的话，就直接分析<strong>选择列表</strong>、路径和结束条件。</p>
<ul>
<li><p>用原数组nums的索引<code>index</code>表示<strong>选择列表</strong>，并用<code>index</code>索引表示做选择，每做一次选择递归调用时<code>index+1</code>，表示选择下一个索引的元素。选择列表还要：</p>
<ul>
<li>排除已经选择过了的值相等的元素<code>nums[i]!=nums[i-1]</code>，并用类似<code>(i！=index)&amp;&amp;()</code>的判断来区别<strong>是当前路径还是同一层的其他路径</strong></li>
<li>去重的原则是当前树枝（本条路径）元素可以重复，而同一树层不能重复选择！</li>
<li><code>i==index</code>表示是当前路径….无论下一个是否重复都可以选！！<ul>
<li><code>i!=index</code>表示是通过for循环另寻出路，就是一条新的路径！！此时相同元素不能再次选择</li>
</ul>
</li>
</ul>
</li>
<li><p>路径用一个list集合<code>cur</code>保存<strong>某条选择的路径</strong>，</p>
</li>
<li><p>结束条件，因为已经去重，所以所有的路径都是子集，直接添加到结果集中。</p>
</li>
</ul>
<p><del>这里有一个思考？什么时候用index索引来做选择，什么时候用visited数组来做选择呢？</del><strong>我终于知道了，所有的回溯都需要循环都需要索引index，区别只是从0开始循环还是从index开始循环。而仅仅只有类似全排列这样的题目才需要从0开始循环并用visited数组保存是否使用</strong></p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161259.png" alt="90.子集II.png" style="zoom: 50%;">

<p><strong>代码实现</strong></p>
<p>含重复元素的查找，因为要比较当前元素与上一个元素是否相等，都要先排序！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//排序</span></span><br><span class="line">        backtrack(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否满足结束条件、一律满足</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="comment">// nums[i]==nums[i-1]说明同一树层（其他路径）已经使用过这个值</span></span><br><span class="line">            <span class="keyword">if</span>(i!=index &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择 1加入路径 2选择列表移除</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归调用，回溯</span></span><br><span class="line">            backtrack(nums,i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//撤销选择 1移出路径 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><p><strong>套用模板</strong></p>
<p>我特么还是直接套模板考虑<strong>选择列表</strong>、路径和结束条件。</p>
<ul>
<li><strong>选择列表</strong>：每次对数组nums的for循环表示做选择，visited数组里面未访问的部分就是选择列表。<ul>
<li>因为含重复元素，所以去重原则是同一树枝（同一条路径）允许重复、而同一树层不允许重复</li>
<li><code>nums[i]==nums[i-1]&amp;&amp;visited[i-1]==false</code>表示元素重复在同一树层上出现了，直接跳过</li>
<li>为了防止<code>i-1</code>越界，所以使用&amp;&amp;的特性来避免：<code>i!=0&amp;&amp;nums[i]==nums[i-1]</code></li>
</ul>
</li>
<li><strong>路径</strong>：用一个list集合<code>cur</code>表示某一条路径，每一条完全的路径都是一个全排列；<code>visited</code>数组表示当前路径下已经访问过的位置</li>
<li><strong>结束条件</strong>：当<code>cur</code>的长度等于原数组的长度，代表该路径完成，将该路径加到结果集中</li>
</ul>
<p><strong>代码实现</strong></p>
<p>含重复元素的查找，因为要比较当前元素与上一个元素是否相等，都要先排序！！！</p>
<p>去重最关键的是：前一个元素没有选择的话，当前元素与之相同所以也不能选（前面的都不选、还轮不到你这个后面的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否满足结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size()==nums.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//选择列表</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;visited[i-<span class="number">1</span>]==<span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择， 1加入路径 2选择列表移除</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//递归调用 回溯</span></span><br><span class="line">            backtrack(nums,visited);</span><br><span class="line">            <span class="comment">//撤销选择，1移出路径 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><blockquote>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>皇后的走法是：可以横直斜走，格数不限。因此要求皇后彼此之间不能相互攻击，等价于要求任何两个皇后都不能在同一行、同一列以及同一条斜线上。</p>
</blockquote>
<p><strong>先决条件：这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</strong></p>
<p><strong>套用模板</strong></p>
<p>直接看蒙，反正就是模板拿过来套，考虑<strong>选择列表</strong>、路径和结束条件（还是要背的）</p>
<ul>
<li><strong>选择列表</strong>，一个行的索引row表示每一行，每一次递归调用row++；for循环中对列col进行迭代；用一个<code>char[][] cur</code>来表示当前选择的路径；写一个函数判断当前row和col的位置是否可用，如下。<ul>
<li>首先判断<strong>当前列直线上</strong>有没有使用过（遍历0到row行），如果有就<code>return false</code></li>
<li>然后判断当前位置的<strong>左上斜直线的位置</strong>有没有使用过，如果有就<code>return false</code></li>
<li>然后判断当前位置的<strong>右上斜直线的位置</strong>有没有使用过，如果有就<code>return false</code></li>
<li>如果都没有就<code>return true</code></li>
</ul>
</li>
<li>路径，就是<code>cur</code>表示的二维数组集合，放了皇后的位置置字符<code>Q</code>，其他位置置字符<code>.</code></li>
<li>结束条件，当<code>row==n</code>到了最后一行，表示各行都放置完成。将数组转换为list集合后加入结果集中</li>
</ul>
<p><strong>代码实现</strong></p>
<p>注意点：1回溯调用每行row，内部循环调用每列col；2利用一个char数组来表示当前的选择（也就是当前的路径）；3写一个判断当前位置是否可用的函数；4写一个char数组转list集合的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res; <span class="comment">//结果集</span></span><br><span class="line">    <span class="keyword">char</span>[][] cur; <span class="comment">//某条路径</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                cur[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        backtrack(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否符合结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            <span class="comment">//将数组转为集合 再添加进结果集合种中</span></span><br><span class="line">            res.add(arrayToList(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;++col)&#123;</span><br><span class="line">            <span class="comment">//选择列表 写一个判断该位置是否可放的函数           </span></span><br><span class="line">            <span class="keyword">if</span>(!available(row,col)) <span class="keyword">continue</span>; <span class="comment">//如果不能放置就跳过</span></span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            cur[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            backtrack(n,row+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            cur[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将二维集合转为list集合</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">char</span>[][] cur)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.length;++i)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(cur[i]));<span class="comment">//可以用cur[i]表示第i行的char数组!!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前位置是否可以放置皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">available</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断 当前列上 有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[i][col]==<span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断 当前位置的左上斜线上 有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[i][j]==<span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断 当前位置的右上斜线上 有没有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;cur.length;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[i][j]==<span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
</blockquote>
<p><strong>套用模板</strong> </p>
<p>直接看<strong>选择列表</strong> 、路径和结束条件：</p>
<ul>
<li><strong>选择列表</strong>有两个原则：1选择的那个元素不能使总和&gt;target；2同一层的分枝不能使用前面分枝已经使用过的元素（避免最后求出两个相同的分枝）<ul>
<li>对于总和，一个判断如果相加超过target跳过该次的遍历（target动态变化）</li>
<li><strong>对于同一层上的元素不能重复使用前面分支的元素，直接用索引index就可以了，每次for遍历从从index开始。另外因为可以重复所以递归是不需要index+1；</strong></li>
</ul>
</li>
<li>路径用一个list集合cur存着，一条路走到黑、然后撤销再选择</li>
<li>结束条件，当target动态变化到0表示获得了一组解，此时加到结果集中</li>
</ul>
<p><strong>代码实现</strong>: </p>
<p>==从每一层的第 2 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。所以可以通过先排序然后用index的递归来实现！！！因为排序之后使用index，不会再次选择比我小的元素，就自然的剪枝了==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否满足结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i&lt;candidates.length;++i)&#123;</span><br><span class="line">            <span class="comment">//选择列表 如果小了后面的必然也小直接跳出</span></span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//做选择 1加入路径 2选择列表移出</span></span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line">            <span class="comment">//递归调用 回溯</span></span><br><span class="line">            backtrack(candidates,target,i); <span class="comment">//允许元素重复</span></span><br><span class="line">            <span class="comment">//撤销选择 1路径移出 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            target += candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h3><blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>注意：解集不能包含重复的组合。 </p>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>排序后，同一层中，如果相同的数已经选择过了，这当前元素不应再选。<ul>
<li><code>if(i!=index&amp;&amp;candidates[i]==candidates[i-1]) continue;</code></li>
</ul>
</li>
<li>排序之后如果target&lt;0，直接break，因为后面的数都更大、一定不满足条件。直接剪枝后面所有的</li>
<li>因为同一个元素只能用一次，所以，回溯调用时使用 <code>index+1</code></li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=index&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            cur.add(candidates[i]);</span><br><span class="line">            backtrack(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h3><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明： 1所有数字都是正整数。 2解集不能包含重复的组合。<br>示例 1:  输入: k = 3, n = 7   输出: [[1,2,4]]<br>示例 2:   输入: k = 3, n = 9   输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
</blockquote>
<p>思路</p>
<ul>
<li><p>k代表结果集的大小</p>
</li>
<li><p>n可以用来判断结束状态,选择集合就是1-9这9个数</p>
</li>
<li><p>当n或者k超过范围的时候直接可以判断结果集合为空</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//k代表结果集的大小</span></span><br><span class="line">        <span class="comment">//n可以用来判断结束状态,选择集合就是1-9这9个数</span></span><br><span class="line">        <span class="comment">//当n或者k超过范围的时候直接可以判断结果集合为空</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">45</span>||k&gt;<span class="number">9</span>) <span class="keyword">return</span> res;</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size()==k&amp;&amp;target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.size()&gt;=k||target&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            cur.add(i);</span><br><span class="line">            backtrack(k,target-i,i+<span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。例如：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161311.png" alt="img" style="zoom:33%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>套用模板</strong></p>
<p>分析<strong>选择列表</strong>、路径和结束条件</p>
<ul>
<li>选择列表就是每个数字对应的三个字母。当前数字索引选择完之后，索引加一；每个数字索引下有3或4个字母选择，作为内部的for循环。<ul>
<li>这里需要注意的是键盘最好用一个String数组储存，</li>
</ul>
</li>
<li>路径用一个StringBuilder字符串来表示，注意删除元素的函数时是<code>sb.deleteCharAt(sb.length()-1);</code></li>
<li>结束条件就是sb的长度达到给出数字字符的长度<code>sb.length()==digits.length()</code></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    StringBuilder sb;</span><br><span class="line">    <span class="comment">//在这里定义一个字符串数组，根据索引找到字符串，然后再找字母</span></span><br><span class="line">    String[] numMap = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">if</span>(digits.length()&lt;<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrack(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否满足结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length()==digits.length())&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">        String numString = numMap[c-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numString.length();++i)&#123;</span><br><span class="line">            <span class="comment">//选择列表就是numString</span></span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            sb.append(numString.charAt(i));</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            backtrack(digits,index+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h3><blockquote>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
</blockquote>
<p><strong>套用模板</strong></p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211020161316.png" alt="image.png" style="zoom: 25%;">

<p><strong>不理解题目直接套模板的方法是错的</strong>，还是要先分析如何遍历、如何剪枝、选择列表是哪些，也就是要先用一个简单的例子画出如上的递归树模型，一般是一个多叉树。然后看看递归的过程：</p>
<p>根据索引截取字串，而每一条路径选择子串元素的原则就是判断这个子串元素是不是回文性质的。截取子串是需要前后两个索引，start和end，start就是回溯函数的参数index，end为for循环遍历的i，直到字符串末尾。</p>
<p>然后进行分析<strong>选择列表</strong>、路径和结束条件</p>
<ul>
<li><strong>选择列表</strong>简单来讲就是所有可能的子字符串。选择这样的遍历方式<ul>
<li>起始索引start由递归函数的索引index调用递增（外层）</li>
<li>结束索引end由函数内部的for循环遍历（内层），由start到字符串结尾</li>
<li>根据索引得到子字符串之后，如果该子串不是回文串就直接跳过``</li>
</ul>
</li>
<li>路径由<code>List&lt;String&gt;</code>集合cur表示，选择和撤销操作</li>
<li>结束条件指找到了一整个集合，里面包含的所有字符串组合起来就是原字符串。这意味着内层for循环需要找到最后一位字符，<ul>
<li>如果我们已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。这里需要<code>index=n</code> 因为start=end+1，所以如果end=len-1，那么start=len就结束了</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结果集和路径</span></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    List&lt;String&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        backtrack(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 处理到最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(start==s.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=start;end&lt;s.length();end++)&#123;</span><br><span class="line">            <span class="comment">//选择列表 如果子串不是回文 则直接跳过（剪枝）</span></span><br><span class="line">            <span class="keyword">if</span>(!isPartition(s,start,end)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择 1加入路径 选择列表移出</span></span><br><span class="line">            cur.add(s.substring(start,end+<span class="number">1</span>));<span class="comment">//实际上是取[start,end]这部分的子串</span></span><br><span class="line">            <span class="comment">//start = end+1; //下一个要从end+1索引开始找了</span></span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            backtrack(s,end+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择 1路径移出 2选择列表加入</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//start = 原本的start;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是回文子串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPartition</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断s字符串[start end]范围的子字符串是否回文</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处判断是否为回文串的函数还可以优化，使用动态规划利用之前的判断结果，减少下循环的次数，本处不着重故不表。</p>
<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3><p><strong>1 官方题解</strong></p>
<p>思路其实就是遍历+筛选，“对所有可能的字符串分隔方式进行搜索，并筛选出满足要求的作为答案。” </p>
<ul>
<li><p>使用一个List<String>集合<strong>res</strong>表示结果集合。</String></p>
</li>
<li><p>使用一个int[]数组<strong>numCur</strong>表示路径，长度为4，储存每一次路径的结果。添加进结果集时需要转换为一个字符串。(用list集合也可以，更统一吧)</p>
</li>
<li><p>使用一个int变量<strong>times</strong>表示当前搜索IP地址的第几段times∈{0,1,2,3}。</p>
</li>
<li><p>使用一个索引<strong>start</strong>表示搜索的开始位置，由于 IP 地址的每一段必须是 [0,255] 中的整数，因此我们从start 开始，从小到大依次枚举当前这一段 IP 地址的结束位置end，如果满足范围要求就加入到路径中。</p>
</li>
</ul>
<p><strong>考虑结束条件、选择列表和路径</strong></p>
<ul>
<li><strong>结束条件</strong>，start索引或者times任意一个达到最大都应该结束<ul>
<li>如果两个同时达到最大，就将当前路径添加进结果集，并返回</li>
<li>如果只有一个先达到最大，就直接返回、继续寻找下一个可能的路径</li>
</ul>
</li>
<li>选择列表，什么时候跳过选择<ul>
<li>首先考虑一种特殊情况，当是0元素开头时，直接将其设为一段添加进结果集，递归迭代找一个个路径</li>
<li>一般情况就先判断start和end之间的当前值，是否在0-225之间，在、就添加递归撤销</li>
</ul>
</li>
<li>路径，为方便比较大小，此处路径就由一个长为4的int数组表示，每个索引代表IP的一段值</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一些细节的地方还是蛮麻烦的..</span></span><br><span class="line">        <span class="comment">//官方题解的思路 其实就是没有刻意的去剪枝。。只是简单的判断了一下每次选择元素的范围</span></span><br><span class="line">        <span class="comment">//自己写一遍吧 递归函数中包含start、times,分别表示开始索引和ip地址的第几位</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==s.length()&amp;&amp;times==<span class="number">4</span>)&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.size();i++)&#123;</span><br><span class="line">                sb.append(cur.get(i));</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">3</span>) sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有一个遍历完了 另一个没完就直接返回（该路径不满足要求）</span></span><br><span class="line">        <span class="keyword">if</span>(start==s.length() || times==<span class="number">4</span>) <span class="keyword">return</span>; </span><br><span class="line">        <span class="comment">//先特判一下0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            cur.add(<span class="number">0</span>);</span><br><span class="line">            backtrack(s,start+<span class="number">1</span>,times+<span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end = start;end&lt;s.length();end++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(s.substring(start,end+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">255</span>||num==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            cur.add(num);</span><br><span class="line">            backtrack(s,end+<span class="number">1</span>,times+<span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2 我的思路</strong></p>
<p>其实我的思路也没有错吧，，，判断位数和的大小是否满足条件 不满足直接退出，，，试一试</p>
<ul>
<li>选择列表，当前段的位数应该满足<code>max(1,afterLength-3*(3-times)&lt;=end-start+1&lt;=3</code><ul>
<li>并且当位数为3时应该&lt;=255，，如果值大于255,直接break</li>
<li>如果位数小于max（1，…），就continue，增加位数</li>
<li>也需要单独考虑0为首位的情况</li>
</ul>
</li>
<li>路径，用一个list<Integer>来保存。正确的路径先转为String然后再加入结果集中。</Integer></li>
<li>结束条件，与官方题解一致</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结果集和路径</span></span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        backtrack(s,<span class="number">0</span>,<span class="number">0</span>,s.length());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> times, <span class="keyword">int</span> afterLength)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 1同时达到最大 有结果 2只有一个达到最大 没结果</span></span><br><span class="line">        <span class="keyword">if</span>(start==s.length() &amp;&amp; times==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//将路径转换为字符串 加入到结果集中</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.size();++i)&#123;</span><br><span class="line">                sb.append(cur.get(i));</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">3</span>) sb.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==s.length() || times==<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑0出现的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>&lt;Math.max(<span class="number">1</span>,afterLength-<span class="number">3</span>*(<span class="number">3</span>-times)))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.add(<span class="number">0</span>);</span><br><span class="line">                backtrack(s,start+<span class="number">1</span>,times+<span class="number">1</span>,afterLength-<span class="number">1</span>);</span><br><span class="line">                cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end=start;end&lt;s.length();++end)&#123;</span><br><span class="line">            <span class="comment">//这里只考虑位数</span></span><br><span class="line">            <span class="keyword">int</span> old = Integer.parseInt(s.substring(start,end+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(end-start+<span class="number">1</span>&gt;<span class="number">3</span> || old&gt;<span class="number">255</span> ||old==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(end-start+<span class="number">1</span>&lt;Math.max(<span class="number">1</span>,afterLength-<span class="number">3</span>*(<span class="number">3</span>-times))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            cur.add(old);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            backtrack(s,end+<span class="number">1</span>,times+<span class="number">1</span>,s.length()-end-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h3><blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
</blockquote>
<p><strong>1 解法一 使用hashset去重 44ms</strong></p>
<p>与含有重复元素的数字的全排列问题相同，但开始不了解字符串的排序，所以第一的想法就是直接生成所有可能的排列情况（一个元素只能使用一次），然后将每种可能也就是路径添加进set集合中实现去重，也就获得了最终的结果集合。未避免元素重复使用、这里因为是全排列问题（元素的使用没有先后关系、只有使用与否的判断），所以需要定义一个visitied数组，表示访问的历史路径。</p>
<ul>
<li>选择列表，未选择的任意一元素。内层循环从0开始知道最大长度，如果已经访问过就跳过<code>if(visited[i]) continue;</code></li>
<li>结束条件，路径sbCur的长度等于原字符串的长度</li>
<li>路径，用一个StringBuilder表示、append()添加  delectCharAt()移除</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这题还有些特殊 字符串不能排序，不能用判断的方法剪枝同层相同的元素</span></span><br><span class="line">    <span class="comment">//用hashSet去重 作为结果集的集合 那么选择列表就变为了下一个索引元素 无需判断</span></span><br><span class="line">    <span class="comment">//路径 可以用一个list集合来存（虽然优点浪费） 或者用StringBuilder也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义结果集和路径</span></span><br><span class="line">    Set&lt;String&gt; hashset;</span><br><span class="line">    StringBuilder sbCur;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        hashset = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        sbCur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        backtrack(s,visited);</span><br><span class="line">        <span class="keyword">return</span> hashset.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 当sbCur的长度等于s.length()</span></span><br><span class="line">        <span class="keyword">if</span>(sbCur.length()==s.length())&#123;</span><br><span class="line">            hashset.add(sbCur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="comment">//选择列表 已经用的元素不能再次使用</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            sbCur.append(s.charAt(i));</span><br><span class="line">            visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            backtrack(s,visited);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            sbCur.deleteCharAt(sbCur.length()-<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2 解法二 字符串排序 手动去重 10ms</strong></p>
<p>参考含重复数字的全排列问题，同样对字符串的字符先排序，然后遍历排序。</p>
<ul>
<li><strong>选择列表</strong>，同一树层，不能选择已经使用过的元素 内层循环i从0到最大长度<ul>
<li><code>char[i]==char[i-1]&amp;&amp;visited[i-1]==false</code> 表示如果元素相同、前一个元素没有用、你也就必然用不了，直接跳过</li>
</ul>
</li>
<li>结束条件，同样是路径长度等于原字符串长度</li>
<li>路径，用StringBuilder存结果，用visited数组当前选择的历史路径</li>
</ul>
<p><strong>代码实现</strong>：没什么意思，跟含重复元素的全排列是一样的…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义结果集和路径</span></span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    StringBuilder sbCur;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        sbCur = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        Arrays.sort(ch); <span class="comment">//应该就是这么排序吧</span></span><br><span class="line">        <span class="comment">//回溯函数</span></span><br><span class="line">        backtrack(ch,visited);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[] ch,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sbCur.length()==ch.length)&#123;</span><br><span class="line">            res.add(sbCur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ch.length;++i)&#123;</span><br><span class="line">            <span class="comment">//选择列表</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;ch[i]==ch[i-<span class="number">1</span>]&amp;&amp;visited[i-<span class="number">1</span>]==<span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//做选择 1添加路径 2选择列表移除</span></span><br><span class="line">            sbCur.append(ch[i]);</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            backtrack(ch,visited);</span><br><span class="line">            <span class="comment">//撤销选择 1路径移出 2选择列表加入</span></span><br><span class="line">            sbCur.deleteCharAt(sbCur.length()-<span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h3><blockquote>
<p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>示例 1：输入：nums = [4,6,7,7]<br>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</p>
<p>示例 2：输入：nums = [4,4,3,2,1]<br>输出：[[4,4]]</p>
</blockquote>
<p>思路一：通过剪枝和set集合去重的方式</p>
<ul>
<li>决策树的图是很好画的，就是暴力选择，选择当前元素i后，下一层的选择就是i之后的所有元素</li>
<li>涉及到两个剪枝的操作：1下一层元素不能小于上层元素  2 同一层选择相同元素的需要剪枝<ul>
<li>1的操作是必须的，因为要求“递增子序列”。每次比较判断一下就好了，不满足就跳过</li>
<li>2 的操作，一半在数组已经排序时，我们可以通过判断与建一个元素相等来剪枝。但是这里求子序列，数组是不可以排序的，所以先想到用set做结果集去重！！</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; set;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//决策树比较好画，就是去重的话因为不能排序，所以只能用set去重</span></span><br><span class="line">        <span class="comment">//（同一层已经使用过的元素，只要值相等都不能再用）</span></span><br><span class="line">        set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">            <span class="comment">//return; //这里千万不能return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=index&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.size()&gt;=<span class="number">1</span> &amp;&amp; nums[i]&lt;cur.get(cur.size()-<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            <span class="comment">//System.out.println(&quot;回溯前&quot;+cur);</span></span><br><span class="line">            backtrack(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(&quot;回溯后&quot;+cur);</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：用一个set数组记录本层使用过的元素，手动剪枝去重，结果集中list集合</p>
<ul>
<li>这个思路是完全正确的，唯一要考虑的是，如何保存本层已经选择过的所有元素。<ul>
<li>回溯中的backtrack()调用实际上是向下层继续选择。而for循环是只选择其他的路径！！所以一个for循环对应着一层中的所有路径！！在for循环上new 一个Set集合。迭代时将<code>nums[i]</code>加入集合中。没进入一层会重新new一个set，所以无需考虑回溯删除set中的元素。</li>
<li>也开始通过一个桶数组boolean[201]，来存是否当前值的元素被使用过</li>
</ul>
</li>
<li>剪枝条件就是同层元素不能选择前面用过的值相等的元素<code>if(i!=index&amp;&amp;set.contains(nums[i])) continue;</code></li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//决策树比较好画，就是去重的话用set存已经使用过的值</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">            <span class="comment">//return; //千万不能+return</span></span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set  = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=index&amp;&amp;set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.size()&gt;=<span class="number">1</span> &amp;&amp; nums[i]&lt;cur.get(cur.size()-<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            set.add(nums[i]); <span class="comment">//set集合存本层已经使用过的元素，无需回溯！！</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backtrack(nums,i+<span class="number">1</span>);</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p><strong>什么时候要用到回溯的算法？</strong></p>
<p>当题目种出现排列、所有可能的排序方案，这样需要全局遍历的时候</p>
<p><strong>模板中最关键的其实是选择列表。</strong></p>
<ul>
<li>不重复元素子集问题的选择列表，是下一个索引的位置；</li>
<li>重复元素子集问题的选择列表，是同一个树层不能有值相同的元素，即排序之后的数组，当 当前索引与前一个相等并且前一个元素没有被访问时，就不能选择当前元素（轮不到你，前一个相等的都没选，为什么要选你这个后面的呢？）<code>if(i!=index&amp;&amp;nums[i]==nums[i-1]) continue;</code></li>
<li>不重复元素的全排列问题的选择列表，是当前索引处未被访问；<code>if(visited[i]) continue;</code></li>
<li>重复元素的全排列问题的选择列表，两个<ul>
<li>当前元素已经使用过，就不能选<code>if(visited[i]) continue;</code></li>
<li>是同一树层不能有值相同的元素（轮不到你） <code>if(i!=0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;visited[i-1]==false) continue;</code></li>
</ul>
</li>
<li>N皇后问题的选择列表就是当前行row的某几个列col；遍历这行的每一列，不能放置的地方就跳过<code>if(!available(row,col)) continue;</code></li>
</ul>
<p><strong>这里又要思考一个问题了，什么时候回溯函数中要带index索引，什么时候不要？</strong></p>
<p>全排列、全排列2中没有用到index迭代；子集和子集2以及N皇后问题中用到了index索引，其共同点在于某一行（或某个元素）选择之后就不再需要、已经不在选择队列之中了，并且每选择完某一行（或某个元素）后需要继续向下一行（下一个元素）继续做同样的选择。这个时候就需要索引index+1。（先暂且这么猜这么用）</p>
<p>再修改一下，只有像全排列这种，选择了一个数对选择下一个数没有先后关系（只有是否重复的关系）时，就不用索引index遍历，其他大多数时刻都需要索引：</p>
<ul>
<li>一种情况是有两层循环，像N皇后这种走棋牌格</li>
<li>一种情况是有明显的前后关系，<ul>
<li>如子集问题选完这一个、需要判断下一个。</li>
<li>如求组合总数，判断完当前元素需要继续判断当前元素（因为可以重复）。</li>
<li>如分隔回文串、复原IP地址，下一个分隔的开始位置，是由前一个分隔的结束位置判断的</li>
</ul>
</li>
</ul>
<p><strong>还有一个问题，什么时候回溯函数中要带visited[]数组，什么时候不要？</strong></p>
<p>现在想来就是只有全排列这种遍历需要从0开始的就需要借助visited数组判断是否使用过，其他用index索引的情况都不需要！！</p>
<p><strong><em>反正就是套模板呗，模板永远滴神！！</em></strong></p>
<h2 id="4-补充题"><a href="#4-补充题" class="headerlink" title="4 补充题"></a>4 补充题</h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p>
<p>输入：nums = []<br>输出：[]</p>
</blockquote>
<p>这题使用回溯会超时，但也不失为一种解决思路</p>
<p>思路：</p>
<ul>
<li>先对数组排序、避免同层选到相同值得数，另外遍历时索引index不断+1，作为<strong>选择列表</strong>，即选择下一个索引位置的元素</li>
<li>路径，即以作得选择由一个cur得list集合保存</li>
<li>结束条件，cur长度为3，且其元素值之和为0。结果集先用set保存以便去重</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//典型的回溯算法</span></span><br><span class="line">    Set&lt;List&lt;Integer&gt;&gt; set;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//调用回溯函数 </span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束条件 cur的size为3且3数之和为0</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size()==<span class="number">3</span> &amp;&amp; cur.get(<span class="number">0</span>)+cur.get(<span class="number">1</span>)+cur.get(<span class="number">2</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合 选择列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            <span class="comment">//回溯调用</span></span><br><span class="line">            backtrack(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    <div>
      
          
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------感谢阅读<i class="fa fa-paw"></i>没事常来-------------
        </div>
    
</div>
      
    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag"># 力扣</a>
              <a href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag"># 回溯</a>
              <a href="/tags/dfs/" rel="tag"># dfs</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/01/%E7%AE%97%E6%B3%95_01_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="prev" title="排序算法java实现">
      <i class="fa fa-chevron-left"></i> 排序算法java实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/19/%E7%AE%97%E6%B3%95_04_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="next" title="滑动窗口算法-力扣题解">
      滑动窗口算法-力扣题解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.</span> <span class="nav-text">1 定义及模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">回溯过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.3.</span> <span class="nav-text">代码模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF%E9%A2%98%E5%9E%8B%E8%A7%A3%E7%AD%94"><span class="nav-number">1.2.</span> <span class="nav-text">2 力扣经典回溯题型解答</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">78. 子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">1.2.2.</span> <span class="nav-text">46. 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="nav-number">1.2.3.</span> <span class="nav-text">90. 子集 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="nav-number">1.2.4.</span> <span class="nav-text">47. 全排列 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-%E7%9A%87%E5%90%8E"><span class="nav-number">1.2.5.</span> <span class="nav-text">51. N 皇后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">1.2.6.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">1.2.7.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III"><span class="nav-number">1.2.8.</span> <span class="nav-text">216. 组合总和 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">1.2.9.</span> <span class="nav-text">17. 电话号码的字母组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">1.2.10.</span> <span class="nav-text">131. 分割回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.11.</span> <span class="nav-text">93. 复原 IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">1.2.12.</span> <span class="nav-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.2.13.</span> <span class="nav-text">491. 递增子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">3、总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%A1%A5%E5%85%85%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">4 补充题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.4.1.</span> <span class="nav-text">15. 三数之和</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wu kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu kang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
