<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wukang555.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一部分介绍二叉树的三种遍历、要达到默写水平；第二部分力扣二叉树小卡片的几乎所有题目； 第三部分剑指offer上面几道经典的题；第四部分是不那么简单的总结；">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树遍历-力扣题解">
<meta property="og:url" content="https://wukang555.github.io/2021/05/03/%E7%AE%97%E6%B3%95_03_%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="落风的风">
<meta property="og:description" content="第一部分介绍二叉树的三种遍历、要达到默写水平；第二部分力扣二叉树小卡片的几乎所有题目； 第三部分剑指offer上面几道经典的题；第四部分是不那么简单的总结；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213131.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213140.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213145.jpg">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213155.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213159.png">
<meta property="og:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213203.jpg">
<meta property="article:published_time" content="2021-05-03T08:55:00.000Z">
<meta property="article:modified_time" content="2021-11-12T14:26:23.074Z">
<meta property="article:author" content="Wu kang">
<meta property="article:tag" content="递归">
<meta property="article:tag" content="力扣">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="分治算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213131.png">

<link rel="canonical" href="https://wukang555.github.io/2021/05/03/%E7%AE%97%E6%B3%95_03_%E4%BA%8C%E5%8F%89%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>二叉树遍历-力扣题解 | 落风的风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="落风的风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">落风的风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://wukang555.github.io/2021/05/03/%E7%AE%97%E6%B3%95_03_%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wu kang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="落风的风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树遍历-力扣题解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 16:55:00" itemprop="dateCreated datePublished" datetime="2021-05-03T16:55:00+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-12 22:26:23" itemprop="dateModified" datetime="2021-11-12T22:26:23+08:00">2021-11-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>第一部分介绍二叉树的三种遍历、要达到默写水平；第二部分力扣二叉树小卡片的几乎所有题目；</p>
<p>第三部分剑指offer上面几道经典的题；第四部分是不那么简单的总结；</p>
<a id="more"></a>

<blockquote>
<p>[1]部分代码思想参考了开源项目github.com/greyireland/algorithm-pattern</p>
<p>[2]题目基本来源力扣学习小卡片《二叉树》<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/">https://leetcode-cn.com/leetbook/detail/data-structure-binary-tree/</a></p>
</blockquote>
<h2 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1 二叉树的遍历"></a>1 二叉树的遍历</h2><p>二叉树的增删改查的前提都是遍历找到某一个结点，所以遍历是二叉树的基本功（至少想要做的了题是这样），遍历分为三类：</p>
<ul>
<li>二叉树的递归遍历</li>
<li>二叉树的非递归遍历（借用栈）</li>
<li>二叉树BFS的层次遍历（借用队列）</li>
</ul>
<p>先建一个结点类，搭建二叉树的环境，类中含一个按结点值大小插入成二叉搜索树的函数<code>insertIntoBST</code>，节点类放在Main类的外面即可，不要加public</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;=val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="keyword">null</span>) root.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">this</span>.insertIntoBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="keyword">null</span>) root.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">this</span>.insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-递归遍历"><a href="#1-1-递归遍历" class="headerlink" title="1.1 递归遍历"></a>1.1 递归遍历</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
</blockquote>
<p>ACM模式一般需要自己建立二叉树，这里给出<strong>用有序数组建立一个平衡的二叉搜索树的递归代码</strong>（直接写在主类中作为一个静态方法，mian方法里面调用之）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    TreeNode leftNode = helper(nums, left, mid-<span class="number">1</span>);</span><br><span class="line">    TreeNode rightNode = helper(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    root.left = leftNode;</span><br><span class="line">    root.right = rightNode;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为更具一般性，我这里遍历时统一将元素放在list数组中。想要存入数组中，需要在调用前新建res集合，每次调用时作为参数传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line">List&lt;Integer&gt; resPre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">preorderTraversal(root,resPre);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">List&lt;Integer&gt; resIn = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">inorderTraversal(root,resIn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">List&lt;Integer&gt; resPost = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">postorderTraversal(root,resPost);</span><br></pre></td></tr></table></figure>



<p><strong>1前序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(ListNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorderTraversal(root.left,res);</span><br><span class="line">    preorderTraversal(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(ListNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversal(root.left,res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorderTraversal(root.right,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3后续遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(ListNode root,List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorderTraversal(root.left,res);</span><br><span class="line">    postorderTraversal(root.right,res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-非递归遍历（stark）"><a href="#1-2-非递归遍历（stark）" class="headerlink" title="1.2 非递归遍历（stark）"></a>1.2 非递归遍历（stark）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res1 = preorderTraversal(root);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res2 = inorderTraversal(root);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res3 = postorderTraversal(root);</span><br></pre></td></tr></table></figure>

<p><strong>1前序遍历</strong></p>
<p>我画了一下迭代过程，过程有点像深度优先搜索，跟下面这个经典的回溯很像、只是选择集合变成了二叉树。</p>
<ul>
<li>先把所有的<code>left</code>结点存入结果集，<strong>根结点先进结果集</strong>、同时也存入栈中，</li>
<li>然后一个一个的出栈，看出栈的结点有没有<code>right</code>结点，</li>
<li>有的话以该结点为<code>root</code>，同样的方式进行搜索、进结果集。</li>
</ul>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213131.png" alt="backtrack" style="zoom: 50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归 前序遍历stack</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(ListNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stack弹出 最后进入也就是最左子结点</span></span><br><span class="line">        ListNode tempNode = stack.pop();</span><br><span class="line">        root = tempNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2中序遍历</strong></p>
<p>中序遍历与前序遍历的差别就是：先把元素存入栈中，元素从栈中弹出后再加入到结果集res中，也就是<strong>先把最左边的加入结果集</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归 中序遍历stack</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(ListNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span> ||  !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tempNode = stack.pop();</span><br><span class="line">        res.add(tempNode.val);</span><br><span class="line">        root = tempNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3后序遍历</strong></p>
<p>因为栈中的元素始终是先左再右的，对后序遍历麻烦一些。要保证根节点必须要在右结点弹出之后再弹出，所以<strong>通过设置<code>lastVisit</code>结点来标识右子节点是否已经弹出</strong>，即弹出之前多加一层判断，看<strong>当前结点的right是否为空或者是否上次已弹出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归 后续遍历stack root必须要在right弹出之后再弹出</span></span><br><span class="line"><span class="comment">// 通过lastVisit标识右子节点是否已经弹出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(ListNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode lastVisited = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;ListNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span> ||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先看看能不能弹出</span></span><br><span class="line">        ListNode tempNode = stack.peek();</span><br><span class="line">        <span class="comment">//多一层判断</span></span><br><span class="line">        <span class="keyword">if</span>(tempNode.right==<span class="keyword">null</span>||tempNode.right==lastVisited)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            res.add(tempNode.val);</span><br><span class="line">            lastVisited = tempNode; <span class="comment">//标记已经加入结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = tempNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-层序遍历"><a href="#1-3-层序遍历" class="headerlink" title="1.3 层序遍历"></a>1.3 层序遍历</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></p>
</blockquote>
<p>层序遍历利用队列的先进先出的特性，<strong>队列一次存入每一层的所有元素、然后一次循环一次性弹出该层的所有元素加入临时list集合中</strong>，弹出的过程中、顺手将下一次的元素入队，每次循环结束、将临时list集合加入二维结果集res中。</p>
<p>层序遍历的考察点挺多的，比较重要，是基本功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrderTraversal(ListNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayDeque&lt;ListNode&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    deque.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//取队列的长度 也就是当前层有多少的元素、便于循环</span></span><br><span class="line">        <span class="keyword">int</span> length = deque.size();</span><br><span class="line">        List&lt;Integer&gt; leverList = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//保存每层元素的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            ListNode leverNode = deque.poll();</span><br><span class="line">            leverList.add(leverNode.val);</span><br><span class="line">            <span class="comment">//下一次元素入队</span></span><br><span class="line">            <span class="keyword">if</span>(leverNode.left!=<span class="keyword">null</span>) deque.offer(leverNode.left);</span><br><span class="line">            <span class="keyword">if</span>(leverNode.right!=<span class="keyword">null</span>) deque.offer(leverNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(leverList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-二叉树力扣题解"><a href="#2-二叉树力扣题解" class="headerlink" title="2 二叉树力扣题解"></a>2 二叉树力扣题解</h2><p><strong>分治算法应用[1]</strong></p>
<p>思路：先分别处理局部，再合并结果。二叉树的大部分题解思想都用到了分治算法、快排和归并排序也是分治算法的经典应用。</p>
<p>分治法模板：1递归结束条件 2分段处理 3合并结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultType <span class="title">traversal</span><span class="params">(ListNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// do something and return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2分治处理</span></span><br><span class="line">    ResultType left = traversal(root.Left);</span><br><span class="line">    ResultType right = traversal(root.Right);</span><br><span class="line">    <span class="comment">//3合并结果</span></span><br><span class="line">    ResultType result = Merge from left and right；</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>遍历都学会了、又学了分治算法的思想，就可以莽力扣题了~</p>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，返回它的最大深度 3 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line">&#x2F; \</span><br><span class="line">9  20</span><br><span class="line"> &#x2F;  \</span><br><span class="line">15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：<strong>二叉树的最大深度等于 其左子树和右子树最大深度的大值 +1</strong></p>
<p>代码：直接套分治法模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树的最大深度 为左右子树的最大深度+1</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p>思路：<strong>平衡二叉树的条件是左右子树都是平衡二叉树且左右子树高差不超过1</strong></p>
<p>代码：先写一个算最大深度的函数，三个判断条件同时满足时为平衡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> left = isBalanced(root.left);</span><br><span class="line">        <span class="keyword">boolean</span> right = isBalanced(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right&amp;&amp; (Math.abs(maxDepth(root.left)-maxDepth(root.right))&lt;<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写一个计算最大深度的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以优化一下<code>maxdepth</code>函数，当不是平衡二叉树的时候返回-1，如果暂且还是平衡才返回最大深度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepth(root)==-<span class="number">1</span>? <span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个计算最大深度的函数 判断过程出现不平衡直接返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>||right==-<span class="number">1</span> || Math.abs(left-right)&gt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><blockquote>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code> 1
 / \</code></pre>
<p>   2   2<br>  / \ / <br> 3  4 4  3</p>
</blockquote>
<p><strong>方法一：自下而上的分治算法解题</strong></p>
<p>思路：要想本节点对称，需要他的左右节点对称。所以要想树的根节点对称，我们可以自底向上的递归判断，<strong>只有底层节点对称了、才推出其上一层对称、最后推之根节点对称</strong>。直接套用分治法模板：<strong>1递归结束条件 2分段处理 3合并结果</strong></p>
<ul>
<li>递归结束条件<ul>
<li>当节点左右子节点都为空，则当前节点对称返回true</li>
<li>当左右子节点只有一个为空，或者两者都非空但值不等，则返回false</li>
</ul>
</li>
<li>分段处理：如果两节点都非空且值相等，就要继续分段考察这两个子节点的对称情况<ul>
<li>递归调用 判断左子节点的左子节点 和 右子节点的右子节点 是不是对称</li>
<li>递归调用 判断 左子节点的右子节点 和 右子节点的左子节点 是不是对称</li>
</ul>
</li>
<li>合并结果<ul>
<li>如果递归出来都是真 就返回true</li>
</ul>
</li>
</ul>
<p>代码比较简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分治的思想 本节点对称 需要左右子节点对称</span></span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//都为空表示父节点是叶子节点 返回真</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果只有一个为空 或者都不空但值不相等 返回假</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span> ||left.val!=right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面是出口 这里是递归调用</span></span><br><span class="line">        <span class="keyword">return</span> helper(left.right,right.left) &amp;&amp; helper(left.left , right.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法二：自顶而下的迭代方法</strong></p>
<p>思路：和层序遍历的想法一样利用队列来实现二叉树的迭代遍历，不同的是为了验证二叉树的对称属性，每次出队入队两个节点元素。如果出现两个都为空的情况注意continue进入下一次循环直到队列为空。</p>
<p>代码：细节处要注意，运算速度比分治稍慢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法二 非递归的解决 利用队列 每次同时入队两个出队两个</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//出队两个</span></span><br><span class="line">            TreeNode left = queue.poll();</span><br><span class="line">            TreeNode right = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>||left.val!=right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//子节点入队 注意顺序</span></span><br><span class="line">            queue.offer(left.left);</span><br><span class="line">            queue.offer(right.right);</span><br><span class="line">            queue.offer(left.right);</span><br><span class="line">            queue.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和系列"><a href="#112-路径总和系列" class="headerlink" title="112. 路径总和系列"></a>112. 路径总和系列</h3><h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><blockquote>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213140.jpg" alt="img" style="zoom:50%;">

<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>输出：true</p>
</blockquote>
<p>思路：</p>
<p>分治算法：如果想要<code>root</code>下的某条路径和为<code>target</code>，需要先判断其子节点下是否存在某条路径的和为<code>target-root.val</code>，(<strong>向下细分、下层的结果影响上层的结果</strong>)</p>
<p>分治算法的三个步骤：<strong>1递归结束条件 2分段处理 3合并结果</strong>。递归结束条件是已经找到叶子节点、</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//还是分治算法 递归出口就是root为空 或者root为叶子节点</span></span><br><span class="line">        <span class="comment">// 分段处理 就是要判断其左右子节点 是否等满足值等于targetSum-root.val </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//为空false</span></span><br><span class="line">        <span class="comment">//叶子节点出口</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span> &amp;&amp; root.val==targetSum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//分段处理</span></span><br><span class="line">        <span class="keyword">boolean</span> left = hasPathSum(root.left, targetSum-root.val);</span><br><span class="line">        <span class="keyword">boolean</span> right = hasPathSum(root.right, targetSum-root.val);</span><br><span class="line">        <span class="keyword">return</span> left||right; <span class="comment">//有一个的和满足就行 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4><blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 target = 22，</p>
<pre><code>       5
      / \
     4   8
    /   / \
   11  13  4
  /  \    / \
 7    2  5   1</code></pre>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[5,4,11,2],</span><br><span class="line">[5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：回溯算法</p>
<p>与判断是否存在不同，这里需要找到所有和为target的路径。但分治算法的思想仍然是一致的。</p>
<ul>
<li>递归出口就是已经找到叶子节点或为null</li>
<li>注意list集合的深拷贝</li>
</ul>
<p>代码：每次选择完之后撤销选择、、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; cur;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="comment">//简单用回溯的思想看看 两个选择左右子节点</span></span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;root.val==target)&#123;</span><br><span class="line">            cur.add(root.val);<span class="comment">//做选择</span></span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(cur));</span><br><span class="line">            cur.remove(cur.size()-<span class="number">1</span>);<span class="comment">//撤销选择</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是非叶子节点（或叶子节点值不匹配） 做选择</span></span><br><span class="line">        cur.add(root.val);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backtrack(root.left,target-root.val);</span><br><span class="line">        backtrack(root.right,target-root.val);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h4><blockquote>
<p>给定一个二叉树的根节点 root ，。</p>
<p>和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>示例 1：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213145.jpg" alt="img" style="zoom:33%;">

<p>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。</p>
</blockquote>
<p>思路:前缀和+dfs回溯       </p>
<ul>
<li>一个节点的前缀和：根节点到达该节点的路径的和</li>
<li>两个节点的路径和（一个几点必须是另一个节点的祖先）：两节点的前缀和之差</li>
<li>将所有节点的前缀和记录在map数组中，键是前缀和的大小，值是同一个前缀和出现的次数（因为有正负数和0，所以可能出现多次）</li>
<li>先用分治递归调用的手段计算出每个节点的前缀和，然后找它的的祖先中有多少前缀和之差等于curSum-target的，有几个res就加几</li>
<li>全局变量：map数组、res、targetSum，局部变量：当前节点的前缀和</li>
<li>dfs函数可以无返回值，每次更新记录res。。计算完当前节点后向左右子节点回溯！！</li>
<li>要注意回溯撤销选择，当map一个子树中的的前缀值用完之后要立马删除，因为要满足“两个节点是同一个子树的条件”</li>
</ul>
<p>代码：思路挺难的其实</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用map存前缀和，和出现的次数（前缀和为根节点到当前节点路径的值）</span></span><br><span class="line">        <span class="comment">//注意回溯从map中删除前缀和，因为要满足“两个节点是同一个子树的条件”</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//节点和为0的节点必须有1个</span></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        getNums(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNums</span><span class="params">(TreeNode node, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> curSum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        curSum += node.val;</span><br><span class="line">        <span class="comment">//map中找存在几个 curSum-targetSum 的元素</span></span><br><span class="line">        res += map.getOrDefault(curSum-targetSum,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该curSum加入map中</span></span><br><span class="line">        map.put(curSum, map.getOrDefault(curSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左右子树递归回溯 计算个数</span></span><br><span class="line">        getNums(node.left, targetSum, curSum);</span><br><span class="line">        getNums(node.right, targetSum, curSum);</span><br><span class="line">        <span class="comment">//将curSum从map中删除</span></span><br><span class="line">        map.put(curSum, map.getOrDefault(curSum,<span class="number">1</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><blockquote>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code> 3
 / \</code></pre>
<p>   9  20<br>     /  <br>    15   7</p>
</blockquote>
<p>思路：</p>
<ul>
<li>仍然是分治的思想： 1递归出口为后序数组已经遍历完成 </li>
<li>2分段处理 由后序遍历找到根节点 由中序遍历找到左右子树的节点个数<ul>
<li>分段处理中序数组中根节点 左边子树部分 和 右边的子树部分</li>
</ul>
</li>
<li>3合并结果将root指向递归得到的两个子树</li>
<li>要用一个map集合存中序数组，键是node值 值是索引 方便找左右子树的元素个数</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">        <span class="comment">//要用一个map集合存中序数组，键是node值 值是索引 方便找左右子树的元素个数</span></span><br><span class="line">        <span class="keyword">int</span> n = postorder.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">return</span> hepler(<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">hepler</span><span class="params">(<span class="keyword">int</span> inoLeft, <span class="keyword">int</span> inoRight, <span class="keyword">int</span> postLeft, <span class="keyword">int</span> postRight, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(postLeft&gt;postRight) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(postLeft == postRight) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(postorder[postRight]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分段处理 由后序遍历找到根节点 由中序遍历找到左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postRight];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> rootIndex = map.get(rootVal);</span><br><span class="line">        <span class="keyword">int</span> leftNums = rootIndex-inoLeft;</span><br><span class="line">        <span class="keyword">int</span> rightNums = inoRight-rootIndex;</span><br><span class="line">        <span class="comment">//分别递归获得左右子树</span></span><br><span class="line">        TreeNode left = hepler(inoLeft,inoLeft+leftNums-<span class="number">1</span>, postLeft, postLeft+leftNums-<span class="number">1</span>, map);</span><br><span class="line">        TreeNode right = hepler(rootIndex+<span class="number">1</span>,inoRight, postRight-<span class="number">1</span>-rightNums+<span class="number">1</span>, postRight-<span class="number">1</span>,map);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right =right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>思路：分治思想，注意用map集合保存中序遍历的数组、方便找root的索引和计算左右子树的节点个数</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="comment">//保存中序至map中</span></span><br><span class="line">        <span class="keyword">int</span> n = inorder.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数获得树</span></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,n-<span class="number">1</span>,<span class="number">0</span>,n-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inoLeft, <span class="keyword">int</span> inoRight, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(preLeft&gt;preRight) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(preLeft==preRight) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preLeft]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由前序遍历找根节点 由中序遍历找左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preLeft];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = map.get(rootVal);</span><br><span class="line">        <span class="keyword">int</span> leftNums = rootIndex-inoLeft;</span><br><span class="line">        <span class="keyword">int</span> rightNums = inoRight - rootIndex;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分段迭代</span></span><br><span class="line">        TreeNode left = helper(preLeft+<span class="number">1</span>, preLeft+<span class="number">1</span>+leftNums-<span class="number">1</span>, inoLeft, rootIndex-<span class="number">1</span> , map);</span><br><span class="line">        TreeNode right = helper(preRight-rightNums+<span class="number">1</span>, preRight, rootIndex+<span class="number">1</span>,inoRight, map);</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><blockquote>
<p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213155.png" alt="img" style="zoom:50%;">

<p>输入：root = [1,2,3,4,5,6,7]<br>输出：[1,#,2,3,#,4,5,6,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。</p>
</blockquote>
<p>思路：直接层序遍历，队列中存每一层的元素，遍历时给next指针赋值</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//菜鸡我的直白想法其实也是层序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">                Node temp = queue.poll();</span><br><span class="line">                <span class="comment">//如果不是最后一个元素就指向下一个元素，否则指向空</span></span><br><span class="line">                <span class="keyword">if</span>(i==length-<span class="number">1</span>) temp.next=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> temp.next = queue.peek();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><h4 id="236-二叉树的最近公共祖先-1"><a href="#236-二叉树的最近公共祖先-1" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><blockquote>
<p>示例 1：</p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213159.png" alt="img" style="zoom: 80%;">

<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
</blockquote>
<p>思路：注意p,q必然存在树内, 且所有节点的值唯一。 递归思想, 对以root为根的(子)树进行查找p和q, 如果<code>root==p||root=q</code> 直接返回root 表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:</p>
<ul>
<li>1**. 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA**</li>
<li>2.如果左右子树返回值只有一个不为null, 说明只有p和q存在于左或右子树中, 最先找到的那个节点为LCA</li>
<li>3.左右子树返回值均为null, p和q均不在树中, 返回null</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p|| root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">//左右子节点分别是p q</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//p q 都在左子树内 或者都在右子树内</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span> || right!=<span class="keyword">null</span>) <span class="keyword">return</span> left==<span class="keyword">null</span>? right:left;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//p q不存在与树中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>方法一：递归，比较值的大小</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：迭代 while死循环 直到root的值在p和q之间</p>
<p>代码：如果p q在同一边继续向那一边往下找，如果位于两边则此时的root就是最近祖先。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode res = root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;res.val&amp;&amp;q.val&lt;res.val)&#123;</span><br><span class="line">                res=res.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&gt;res.val&amp;&amp;q.val&gt;res.val)&#123;</span><br><span class="line">                res=res.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><blockquote>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>示例 1：</strong></p>
<img src="https://gitee.com/wukang555/blog-figure-bed/raw/master/img/20211112213203.jpg" alt="img" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="方法一：层序遍历迭代的方式"><a href="#方法一：层序遍历迭代的方式" class="headerlink" title="方法一：层序遍历迭代的方式"></a>方法一：层序遍历迭代的方式</h4><p>1、将二叉树序列化为字符串，比较容易，直接套用层序遍历过程，并用<code>StringBuilder</code>存结果就好、空节点也要保留，用字符<code>＃</code>代替</p>
<p>2、将字符串反序列化为二叉树：</p>
<ul>
<li>先将字符串分隔尾字符数组 遍历数组</li>
<li>每次遍历 出队一个 为该节点指定两个子节点 并将这两个子节点进队 </li>
<li>当所有的元素都进队完毕时表示二叉树已经建立完成</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//层序遍历 取出字符存为sb</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(temp.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">//无论是否为空都加入队列</span></span><br><span class="line">            queue.offer(temp.left);</span><br><span class="line">            queue.offer(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历字符数组，如果不为空，就作为左子节点或者右子节点加到队列中的节点上</span></span><br><span class="line">        <span class="comment">//队列中首先存根节点，然后每次循环，入队两个节点（当前节点的左右子节点）</span></span><br><span class="line">        <span class="keyword">if</span>(data==<span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;++i)&#123;</span><br><span class="line">            <span class="comment">//每次出队一个 入队两个</span></span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="comment">//指定左右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(!arr[i].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">                TreeNode left = <span class="keyword">new</span> TreeNode( Integer.parseInt(arr[i]));</span><br><span class="line">                temp.left = left;</span><br><span class="line">                queue.offer(left);<span class="comment">//入队第一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!arr[++i].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">                TreeNode right = <span class="keyword">new</span> TreeNode( Integer.parseInt(arr[i]) );</span><br><span class="line">                temp.right = right;</span><br><span class="line">                queue.offer(right); <span class="comment">//入队第二个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：前序遍历递归实现（更容易实现）"><a href="#方法二：前序遍历递归实现（更容易实现）" class="headerlink" title="方法二：前序遍历递归实现（更容易实现）"></a>方法二：前序遍历递归实现（更容易实现）</h4><p>1、序列化也容易，前序遍历</p>
<p>2、反序列化：</p>
<ul>
<li>将字符串分隔为数组并转换为队列（方便一个一个的按顺序出队列）</li>
<li>递归函数：出口为#表示的空节点，分别处理左子树和右子树，返回根节点</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    StringBuilder sb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二叉树序列化输出前序遍历的字符串</span></span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        helper01(root);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper01</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        helper01(root.left);</span><br><span class="line">        helper01(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; dataList = Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList(dataList);</span><br><span class="line">        <span class="keyword">return</span> helper(queue);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String nodeVal = queue.poll(); <span class="comment">//先出根结点</span></span><br><span class="line">        <span class="keyword">if</span>(nodeVal.equals(<span class="string">&quot;#&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(nodeVal));</span><br><span class="line">        root.left = helper(queue); <span class="comment">//再出左子结点</span></span><br><span class="line">        root.right = helper(queue); <span class="comment">//再出右子结点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-剑指offer闭眼题"><a href="#3-剑指offer闭眼题" class="headerlink" title="3 剑指offer闭眼题"></a>3 剑指offer闭眼题</h2><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3><blockquote>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<pre><code>     3
    / \
   4   5
  / \
 1   2</code></pre>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 </span><br><span class="line">&#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>


<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
</blockquote>
<p>思路：很巧妙的两层递归 </p>
<ul>
<li>第一层递归找到A中与B树根节点相同的那个结点，用或运算递归调用A树的左右子节点</li>
<li>第二层递归  逐个判断B树和A树的一个子结构是否相同 直到B树为空</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> </span><br><span class="line">        (TreeNode A, TreeNode B) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//空节点不是任何树的子结构</span></span><br><span class="line">        <span class="comment">//第一层递归A树调用子函数 存在即可 找第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> isSubTree(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//B先遍历完 表示B是子结构</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//A先为空 或者A B值不等，表示不匹配</span></span><br><span class="line">        <span class="comment">//向下递归A B的子节点</span></span><br><span class="line">        <span class="keyword">return</span> isSubTree(A.left,B.left)&amp;&amp;isSubTree(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3><blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>   4
  /   \</code></pre>
<p>   2     7<br>  / \   / <br> 1   3 6   9</p>
<p>镜像输出：</p>
<pre><code>    4
   /   \</code></pre>
<p>   7     2<br>  / \   / <br> 9   6 3   1<br>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
</blockquote>
<p>思路：每个结点的左右子树交换位置即可、怎么操作呢？   <strong>选一种方式遍历二叉树、对每个结点 交换其左右结点的位置</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个结点的左右子树交换位置即可、怎么操作呢</span></span><br><span class="line">        <span class="comment">//选一种方式遍历二叉树、对每个结点 交换其左右结点的位置</span></span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">        <span class="comment">//交换当前结点的左右子节点</span></span><br><span class="line">        TreeNode temp = root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：递归调用返回节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//交换每个节点的左右子节点， 先交换底层叶子节点，然后通过递归向上</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = mirrorTree(root.left);</span><br><span class="line">        TreeNode right = mirrorTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3><blockquote>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。例如: 给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code> 3
 / \</code></pre>
<p>   9  20<br>     /  <br>    15   7</p>
<p>返回其层次遍历结果：</p>
<p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p>
</blockquote>
<p>思路：和层序遍历一样，内部循环保存一层的所有结点。区别是 设置一个<code>flag</code>标识，交替从集合头部或尾部进入集合。因为链表适合插入所以这里用<code>LinkedList</code>而不是<code>ArrayList</code>集合。注意每循环一次也就是每处理完一层需要将改变<code>flag</code>的值</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//拿手菜 唯一的区别是进list时交替 一个逆序一个顺序 用linkedList 加入头加入尾</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            List&lt;Integer&gt; levelList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode tempNode = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    levelList.add(tempNode.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    levelList.add(<span class="number">0</span>,tempNode.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tempNode.left!=<span class="keyword">null</span>) queue.offer(tempNode.left);</span><br><span class="line">                <span class="keyword">if</span>(tempNode.right!=<span class="keyword">null</span>) queue.offer(tempNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            res.add(levelList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><blockquote>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:</p>
<p>输入: root = [3,1,4,null,2], k = 1</p>
<p>  3<br>/ <br>1   4<br> <br>    2<br>输出: 4</p>
</blockquote>
<p>思路：二叉搜索树一般用前序遍历，<del>可以直接前序遍历出来数组再找倒数第K个</del>。也可以直接逆选取遍历、设置一个计数标识，找到了第k个自动跳出。</p>
<ul>
<li>计数标识count 和 结果res 都需要定义为全局变量方便储存</li>
<li><strong>加一个判断res是否已经改变，可以避免全局遍历，提前跳出中序遍历！！</strong></li>
<li>明明这么简单、我为什么还是做不出来，，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        findK(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findK</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res!=-<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//提前跳出</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        findK(root.right);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k) &#123;</span><br><span class="line">            res=root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findK(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>有一说一，当我把递归遍历和层次遍历基本能够默写之后、还是不能做题；又学了自下而上的分治算法（常用且实现简单）和自上而下的迭代算法，这时候做题也不能一次到位，递归的流程的确称得上是千变万化。</p>
<p>递归的代码确实简单，但很多小细节只有总结了记住了才能迅速AC，不然也会很难办。总结如下吧，愿能常看常新：</p>
<hr>
<p><strong>二叉树的最大深度</strong>等于 其左子树和右子树最大深度的大值 +1</p>
<p><strong>平衡二叉树</strong>的条件是左右子树都是平衡二叉树且左右子树高差不超过1（两层递归）</p>
<p><strong>对称二叉树</strong>：只有底层节点对称了、才推出其上一层对称、最后推之根节点对称</p>
<ul>
<li>递归出口 叶子节点或者左右子节点不对称</li>
<li>递归调用检查左右子节点是否对称，左左右右 左右右左</li>
</ul>
<p><strong>路径总和为target：</strong></p>
<ul>
<li>递归出口： 当前节点为空 或者 找到叶子节点</li>
<li>递归调用左子树是否存在路径 或者 右子树是否存在路径 <code>target-root.val</code></li>
<li>如果要存所有路径进集合中，用list集合，思路一样（回溯提高效率）</li>
</ul>
<p><strong>中序和前序构造二叉树</strong>一般右前序找根节点、由中序的<code>map</code>找索引进而得到左右子树的元素个数</p>
<ul>
<li>递归出口：后序数组已经遍历完成 </li>
<li>分段处理 由后序遍历找到根节点 由中序遍历找到左右子树的节点个数，分别递归获得左右子树</li>
</ul>
<p><strong>填充每个节点的下一个右侧节点指针</strong>：层序遍历是直接给<code>next</code>指针赋值，注意最后一个赋值null</p>
<p><strong>二叉树的最近公共祖先</strong></p>
<ul>
<li>递归出口：<code>root</code>为空 或者 当前<code>root</code>为最近祖先</li>
<li>左右分别递归调用。根据返回的结果、判断返回<code>root</code>或者<code>left</code>或者<code>right</code>或者<code>null</code></li>
</ul>
<p><strong>二叉树的序列化与反序列化</strong>：推荐递归方式</p>
<ul>
<li>序列化也容易，前序遍历直接拼接返回 递归 yyds</li>
<li>反序列化：先将所有元素存入<code>String</code>的队列中，按前序的方法一个一个的取出来。如果为<code>#</code>返回<code>null节点</code>，否则返回有<code>val</code>的节点</li>
</ul>
<p><strong>树的子结构</strong>：很巧妙的两层递归 （和平衡树相似）</p>
<ul>
<li>第一层递归找到A中与B树根节点相同的那个结点，用 或运算 递归调用A树的左右子节点</li>
<li>第二层递归  逐个判断B树和A树的一个子结构是否相同 直到B树为空</li>
</ul>
<p><strong>二叉树的镜像</strong>：选一种方式遍历二叉树、对每个结点 交换其左右结点的位置</p>
<p><strong>Z字形从上到下打印二叉树</strong>：和层序遍历一致，就是进list集合时分别从尾部进、从头部进，所以注意用<code>LinkedList</code>哦</p>
<p><strong>二叉搜索树的第k大节点</strong>：建立全局变量的计数标识<code>count</code> 和 结果<code>res </code>，前序遍历模板把输出变成了一个判断，注意<code>count++</code></p>
<hr>
<p>All in all, 我是菜鸡。</p>

    </div>

    <div>
      
          
<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">
              -------------感谢阅读<i class="fa fa-paw"></i>没事常来-------------
        </div>
    
</div>
      
    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%80%92%E5%BD%92/" rel="tag"># 递归</a>
              <a href="/tags/%E5%8A%9B%E6%89%A3/" rel="tag"># 力扣</a>
              <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"># 二叉树</a>
              <a href="/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/" rel="tag"># 分治算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/28/%E7%AE%97%E6%B3%95_05_%E9%93%BE%E8%A1%A8/" rel="prev" title="链表练习-力扣题解">
      <i class="fa fa-chevron-left"></i> 链表练习-力扣题解
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/15/%E7%AE%97%E6%B3%95_06_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="next" title="二分查找-力扣题解">
      二分查找-力扣题解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text">1 二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 递归遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88stark%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 非递归遍历（stark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">2 二叉树力扣题解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">110. 平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.3.</span> <span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E7%B3%BB%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text">112. 路径总和系列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">2.4.1.</span> <span class="nav-text">112. 路径总和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">2.4.2.</span> <span class="nav-text">113. 路径总和 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">2.4.3.</span> <span class="nav-text">437. 路径总和 III</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.5.</span> <span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.6.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">2.7.</span> <span class="nav-text">116. 填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.8.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-1"><span class="nav-number">2.8.1.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.8.2.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.9.</span> <span class="nav-text">297. 二叉树的序列化与反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.1.</span> <span class="nav-text">方法一：层序遍历迭代的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%9B%B4%E5%AE%B9%E6%98%93%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="nav-number">2.9.2.</span> <span class="nav-text">方法二：前序遍历递归实现（更容易实现）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%89%91%E6%8C%87offer%E9%97%AD%E7%9C%BC%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">3 剑指offer闭眼题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">剑指 Offer 26. 树的子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">3.2.</span> <span class="nav-text">剑指 Offer 27. 二叉树的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="nav-number">3.3.</span> <span class="nav-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">3.4.</span> <span class="nav-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">4 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wu kang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu kang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
